<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>https</title>
      <link href="/2018/10/24/https/"/>
      <url>/2018/10/24/https/</url>
      <content type="html"><![CDATA[<p>https跟http不同，在传输层tcp和应用层http之间还需要加入一个表现层TLS/SSL。</p><h3 id="HTTPS的工作流程"><a href="#HTTPS的工作流程" class="headerlink" title="HTTPS的工作流程"></a>HTTPS的工作流程</h3><ol><li>客户端通过HTTPS的URL访问服务器的443端口，并且发送一个<code>随机数（Client random）</code>和<code>加密算法</code>给服务器</li><li>服务器会将网站证书传送给客户端，还会发送一个<code>随机数（Server random）</code>和协商的<code>加密算法</code>客户端</li><li>客户端如果验证证书有效，生成一个新的随机数（Premaster random），并使用证书中的公钥加密发送给服务器</li><li>服务器使用私钥解密客户端发来的随机数</li><li>双方使用先前的加密算法，根据3个随机数生成一个对称加密的密钥用于加密接下来所有的传输</li></ol><h3 id="证书结构"><a href="#证书结构" class="headerlink" title="证书结构"></a>证书结构</h3><ol><li>CA</li><li>使用者</li><li>有效期</li><li>公钥</li><li>签名算法</li><li>指纹</li><li>…</li></ol><h3 id="证书验证流程"><a href="#证书验证流程" class="headerlink" title="证书验证流程"></a>证书验证流程</h3><ol><li>浏览器对证书的有效期和使用者进行校验</li><li>浏览器查找操作系统中受信任的CA，和服务器证书的CA进行比对</li><li>比对不成功，说明服务器证书的CA不合法</li><li>比对成功，浏览器取出操作系统相关CA的公钥，并对证书的签名进行解密</li><li>根据证书指定哈希算法对证书进行hash，然后和指纹比对是否一致</li><li>这样就能判断该证书有效且合法</li></ol>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务的架构</title>
      <link href="/2018/10/24/Restful-API/"/>
      <url>/2018/10/24/Restful-API/</url>
      <content type="html"><![CDATA[<h1 id="服务对外的描述（框架）"><a href="#服务对外的描述（框架）" class="headerlink" title="服务对外的描述（框架）"></a>服务对外的描述（框架）</h1><h3 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h3><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">Rest理解</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">Restful API设计指南</a></p><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><h3 id="IDL文件"><a href="#IDL文件" class="headerlink" title="IDL文件"></a>IDL文件</h3><h1 id="通信的协议"><a href="#通信的协议" class="headerlink" title="通信的协议"></a>通信的协议</h1><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP是封装在TCP上的，所以每建立一次通信就是进行tcp的3次握手过程：</p><ol><li>A  -&gt;  (SYN=1 seq=x)</li><li>B  -&gt;  ACK=x+1,(SYN=1 seq=y)</li><li>A  -&gt;  ACK=y+1</li></ol><p>结束还需要进行4次挥手阶段：</p><ol><li>A  -&gt;  (FIN=1 seq=x)</li><li>B  -&gt;  ACK=x+1</li><li>B  -&gt;  (FIN=1 seq=y),ACK=x+1</li><li><p>A  -&gt;  ACK=y+1</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>socket是基于TCP/IP封装的，所以建立连接需要一对套接字：</p></li><li><p>Server绑定某个端口：bind()</p></li><li>Server监听指定端口：listen()</li><li>Client对服务器进行拨号：dial()</li><li>Server对客户端的连接进行响应：accept()</li><li>Client发送数据：send()</li><li>Server接收数据：receive()</li><li>关闭连接：close()</li></ol><h1 id="服务器端处理请求的方式"><a href="#服务器端处理请求的方式" class="headerlink" title="服务器端处理请求的方式"></a>服务器端处理请求的方式</h1>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> restful </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>切片</title>
      <link href="/2018/10/21/%E5%88%87%E7%89%87/"/>
      <url>/2018/10/21/%E5%88%87%E7%89%87/</url>
      <content type="html"><![CDATA[<h3 id="切片的注意点"><a href="#切片的注意点" class="headerlink" title="切片的注意点"></a>切片的注意点</h3><ul><li>当slice的cap没有变化时，始终是对原数组的引用，使用append会修改引用数组的值</li></ul><h3 id="切片的坑"><a href="#切片的坑" class="headerlink" title="切片的坑"></a>切片的坑</h3><p>FindDigits函数是加载整个文件到内存，然后搜索第一个连续的数字，结果以切片形式返回<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">"[0-9]+"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">    b,_:=ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这段代码有问题，因为返回的切片<code>[]byte</code>指向保存整个文件的数组。所以<code>GC</code>不能释放数组空间，浪费了内存。</p><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>将获得的数据复制到新的切片中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">    b,_:=ioutil.ReadFile(filename)</span><br><span class="line">    b = digitRegexp.Find(b)</span><br><span class="line">    c:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="built_in">len</span>(b))</span><br><span class="line">    <span class="built_in">copy</span>(c,b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> slice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式</title>
      <link href="/2018/10/21/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2018/10/21/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      <content type="html"><![CDATA[<ul><li><a href="https://www.zhihu.com/question/23645117" target="_blank" rel="noopener">知乎：分布式系统</a><ul><li><a href="http://www.cs.cmu.edu/~dga/15-440/S14/syllabus.html" target="_blank" rel="noopener">15-440</a></li><li><a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15712-s12/www/" target="_blank" rel="noopener">15-712</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>矩阵置零</title>
      <link href="/2018/10/19/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
      <url>/2018/10/19/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
      <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> N,M <span class="keyword">int</span>=<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">Input:=[<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;N;i++&#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;M;j++&#123;</span><br><span class="line"><span class="keyword">if</span> Input[i][j]==<span class="number">0</span>&#123;</span><br><span class="line">Input[i][j]=<span class="number">1</span>&lt;&lt;<span class="number">7</span><span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;N;i++&#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;M;j++&#123;</span><br><span class="line"><span class="keyword">if</span> Input[i][j]==<span class="number">1</span>&lt;&lt;<span class="number">7</span><span class="number">-1</span>&#123;</span><br><span class="line"><span class="keyword">for</span> z:=<span class="number">0</span>;z&lt;M;z++&#123;</span><br><span class="line">Input[i][z]=<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> x:=<span class="number">0</span>;x&lt;N;x++&#123;</span><br><span class="line">Input[x][j]=<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(Input)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[[0,0,0,0],[0,0,0,0],[4,5,0,0]]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>orm</title>
      <link href="/2018/10/09/orm/"/>
      <url>/2018/10/09/orm/</url>
      <content type="html"><![CDATA[<h1 id="orm笔记"><a href="#orm笔记" class="headerlink" title="orm笔记"></a>orm笔记</h1><ul><li>在创建对象的时候，将本来是<code>Time</code>类型字段改为<code>string</code>类型，因为<code>Time</code>类型的地址取不到。</li></ul><p><a href="https://github.com/gongshen/sorm/" target="_blank" rel="noopener">github地址</a></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 反射 </tag>
            
            <tag> orm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端</title>
      <link href="/2018/10/08/html+css+js%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/08/html+css+js%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot;</span><br></pre></td></tr></table></figure><h3 id="标签样式"><a href="#标签样式" class="headerlink" title="标签样式"></a>标签样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h3><p>*{<br>padding:;<br>margin:;<br>}</p><h3 id="类选择器：能多次使用"><a href="#类选择器：能多次使用" class="headerlink" title="类选择器：能多次使用"></a>类选择器：能多次使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h1 class=&quot;box1&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="ID选择器：只能使用一次"><a href="#ID选择器：只能使用一次" class="headerlink" title="ID选择器：只能使用一次"></a>ID选择器：只能使用一次</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#box2&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;h1 id=&quot;box2&quot;</span><br></pre></td></tr></table></figure><h3 id="子类选择器"><a href="#子类选择器" class="headerlink" title="子类选择器"></a>子类选择器</h3><p>选择h2中的p标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h2&gt;p&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>选择body中的后代p标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body p&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h3><p>选择第一个p标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p:first-child&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>选择h2中的id属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h2[id]&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="浮动和定位"><a href="#浮动和定位" class="headerlink" title="浮动和定位"></a>浮动和定位</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//绝对定位：脱离标准的文档流，相对于祖先元素的相对定位来用。</span><br><span class="line">position: absolute;</span><br><span class="line">//相对定位：不脱离文档流</span><br><span class="line">position: relative;</span><br><span class="line">//固定定位：始终相对于浏览器来定位</span><br><span class="line">position：fixed;</span><br><span class="line">//将块元素进行左右浮动</span><br><span class="line">float:right;</span><br><span class="line">//清除右浮动对它的影响</span><br><span class="line">clear:right;</span><br></pre></td></tr></table></figure><h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var num=10.1;</span><br><span class="line">document.write(typeof(num));</span><br><span class="line">//对象创建</span><br><span class="line">var obj1=new Student(&quot;张三&quot;,21);</span><br><span class="line"></span><br><span class="line">function func1() &#123;</span><br><span class="line">    alert(&quot;哈哈哈哈哈哈哈！&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//数组</span><br><span class="line">var num=[2,3,4,5];</span><br><span class="line">//遍历</span><br><span class="line">for(var op in num)&#123;</span><br><span class="line">    document.write(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>反射</title>
      <link href="/2018/10/02/%E5%8F%8D%E5%B0%84/"/>
      <url>/2018/10/02/%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<p><code>reflect.Zero(reflect.TypeOf(23))</code>：返回Value（Kind为Int类型，值为0）<br><code>Addr()</code>：用于取得Value的struct字段或者slice元素的指针<br><code>TypeOf</code>方法得出静态类型<br><code>Kind</code>方法得出底层类型<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line">v:=reflect.TypeOf(x)</span><br><span class="line">k:=v.Kind()</span><br><span class="line">fmt.Println(v)</span><br><span class="line">fmt.Println(k)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">main.MyInt</span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure></p><p><code>Value</code>的<code>CanSet</code>方法返回值是否可以被改变。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span>=<span class="number">3.14</span></span><br><span class="line">v:=reflect.ValueOf(x)</span><br><span class="line">fmt.Println(v.CanSet())</span><br><span class="line"><span class="comment">//false：表明这时v是不能被修改的</span></span><br></pre></td></tr></table></figure></p><p>先取得x的地址，然后使用p间接指向，就可以修改<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span>=<span class="number">3.14</span></span><br><span class="line">v:=reflect.ValueOf(&amp;x)</span><br><span class="line">p:=v.Elem()</span><br><span class="line">fmt.Println(p.CanSet())</span><br><span class="line"><span class="comment">//true：这时可以修改了</span></span><br></pre></td></tr></table></figure></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    B <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">    <span class="comment">//可设置的反射对象</span></span><br><span class="line">    s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">    typeOfT := s.Type()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">        f := s.Field(i)</span><br><span class="line">        fmt.Printf(<span class="string">"%d: %s %s = %v\n"</span>, i,</span><br><span class="line">        typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从地址创建发射对象,从结构体的类型中解析字段名字。</span></span><br><span class="line"><span class="comment">//字段本身是reflect.Value对象</span></span><br><span class="line"><span class="comment">//可设置字段必须大写</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 反射 </tag>
            
            <tag> orm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>interface理解</title>
      <link href="/2018/10/02/interface%E7%90%86%E8%A7%A3/"/>
      <url>/2018/10/02/interface%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="一、interface"><a href="#一、interface" class="headerlink" title="一、interface"></a>一、interface</h1><h3 id="接口内部的对总是-value-实际类型-格式。接口不能保存接口值。"><a href="#接口内部的对总是-value-实际类型-格式。接口不能保存接口值。" class="headerlink" title="接口内部的对总是(value,实际类型)格式。接口不能保存接口值。"></a>接口内部的对总是<code>(value,实际类型)</code>格式。接口不能保存接口值。</h3><ul><li>value是底层的数据类型</li><li>实际类型是这个项目完整的类型</li></ul><p><strong>看下面这个例子</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">file,_:=os.OpenFile(name,flag,perm)</span><br><span class="line">r=file</span><br><span class="line"><span class="comment">//此时的r的内部对是(file,*os.File)</span></span><br><span class="line"><span class="comment">//因为os.File实现了io.Reader接口的要求</span></span><br><span class="line">w:=r.(io.Writer)</span><br><span class="line"><span class="comment">//因为要把r虽然是io.Reader类型,但是内部包含了*os.File所有的信息.</span></span><br><span class="line"><span class="comment">//通过类型断言</span></span><br><span class="line"><span class="comment">//w现在提供io.Writer的方法，w包含的也是(file,*os.File)</span></span><br><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty=w</span><br><span class="line"><span class="comment">//因为empty是空接口值也包含了(file,*os.File),无需类型断言</span></span><br></pre></td></tr></table></figure></p><hr><p><code>e</code>是(*data,nil)类型的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取底层结构数据</span></span><br><span class="line">d:=(*<span class="keyword">struct</span>&#123;</span><br><span class="line">    down <span class="keyword">uintptr</span></span><br><span class="line">    data <span class="keyword">uintptr</span></span><br><span class="line">&#125;)(unsafe.Pointer(&amp;e))</span><br><span class="line">    fmt.Println(d)</span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line">&amp;&#123;<span class="number">3078907912</span> <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></p><h1 id="二、指针为nil时"><a href="#二、指针为nil时" class="headerlink" title="二、指针为nil时"></a>二、指针为nil时</h1><p>下面这种写法在指针为nil时会panic<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">  v <span class="keyword">int</span></span><br><span class="line">  l *tree</span><br><span class="line">  r *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  sum := t.v</span><br><span class="line">  <span class="keyword">if</span> t.l != <span class="literal">nil</span> &#123;</span><br><span class="line">    sum += t.l.Sum()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> t.r != <span class="literal">nil</span> &#123;</span><br><span class="line">    sum += t.r.Sum()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就算指针为nil也不会panic<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t.v + t.l.Sum() + t.r.Sum()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(t *tree)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(t.l, t.v, t.r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Find</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> t.v == v || t.l.Find(v) || t.r.Find(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> interface </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>流处理</title>
      <link href="/2018/09/29/%E6%B5%81%E5%A4%84%E7%90%86/"/>
      <url>/2018/09/29/%E6%B5%81%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="一、strings包和bytes包"><a href="#一、strings包和bytes包" class="headerlink" title="一、strings包和bytes包"></a>一、strings包和bytes包</h1><p>不处理数据流时使用</p><h3 id="rune的概念"><a href="#rune的概念" class="headerlink" title="rune的概念"></a>rune的概念</h3><p><code>rune</code>是<code>int32</code>的别名，字符串是用<code>byte</code>类型来存储的，<code>byte</code>类型是<code>uint8</code>的别名，而中文占3个字节，所以不通过转换是读不出中文字符的。<br>当我们使用<code>for-range</code>遍历字符串得到的value其实就是<code>rune</code>类型的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//str占9个字节</span></span><br><span class="line">str:=<span class="string">"abc一二"</span></span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> str&#123;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(v))<span class="comment">//abc一二</span></span><br><span class="line">fmt.Println(str[i])<span class="comment">//97 98 99 228 228</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//str占5个字节</span></span><br><span class="line">r:=[]<span class="keyword">rune</span>(str)</span><br><span class="line"><span class="keyword">for</span> i,_:=<span class="keyword">range</span> r&#123;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(str[i]))<span class="comment">//abc一二</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="字符串是否包含：Contains"><a href="#字符串是否包含：Contains" class="headerlink" title="字符串是否包含：Contains"></a>字符串是否包含：Contains</h3><h3 id="子串中任何字符有包含在字符串中：ContainsAny"><a href="#子串中任何字符有包含在字符串中：ContainsAny" class="headerlink" title="子串中任何字符有包含在字符串中：ContainsAny"></a>子串中任何字符有包含在字符串中：ContainsAny</h3><h3 id="子串中是否有rune类型的包含在字符串中：ContainsRune"><a href="#子串中是否有rune类型的包含在字符串中：ContainsRune" class="headerlink" title="子串中是否有rune类型的包含在字符串中：ContainsRune"></a>子串中是否有rune类型的包含在字符串中：ContainsRune</h3><h3 id="最后一个匹配的子串的位置：LastIndex"><a href="#最后一个匹配的子串的位置：LastIndex" class="headerlink" title="最后一个匹配的子串的位置：LastIndex"></a>最后一个匹配的子串的位置：LastIndex</h3><h3 id="大小写转换：ToLower"><a href="#大小写转换：ToLower" class="headerlink" title="大小写转换：ToLower"></a>大小写转换：ToLower</h3><h3 id="返回字符串出现的次数：Count"><a href="#返回字符串出现的次数：Count" class="headerlink" title="返回字符串出现的次数：Count"></a>返回字符串出现的次数：Count</h3><h3 id="将字符串按分隔符切割：Split"><a href="#将字符串按分隔符切割：Split" class="headerlink" title="将字符串按分隔符切割：Split"></a>将字符串按分隔符切割：Split</h3><p>不会自动处理字符串末尾的换行符</p><h3 id="将字符串按空格分割成切片：Fields"><a href="#将字符串按空格分割成切片：Fields" class="headerlink" title="将字符串按空格分割成切片：Fields"></a>将字符串按空格分割成切片：Fields</h3><p>会自动将字符串末尾的换行符去掉<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以自定义切割方式：'#'</span></span><br><span class="line">canSplit:= <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span><span class="title">bool</span></span> &#123;<span class="keyword">return</span> r==<span class="string">'#'</span>&#125;</span><br><span class="line">fmt.Println(strings.FieldsFunc(str,canSplit))</span><br></pre></td></tr></table></figure></p><h3 id="查找字串是否在字符串开头：HasPrefix"><a href="#查找字串是否在字符串开头：HasPrefix" class="headerlink" title="查找字串是否在字符串开头：HasPrefix"></a>查找字串是否在字符串开头：HasPrefix</h3><h3 id="按字典顺序比较字符串-Compare"><a href="#按字典顺序比较字符串-Compare" class="headerlink" title="按字典顺序比较字符串:Compare"></a>按字典顺序比较字符串:Compare</h3><h3 id="比较字符串是否相等，忽略大小写：EqualFold"><a href="#比较字符串是否相等，忽略大小写：EqualFold" class="headerlink" title="比较字符串是否相等，忽略大小写：EqualFold"></a>比较字符串是否相等，忽略大小写：EqualFold</h3><h3 id="判断字符串前缀：HasPrefix"><a href="#判断字符串前缀：HasPrefix" class="headerlink" title="判断字符串前缀：HasPrefix"></a>判断字符串前缀：HasPrefix</h3><h3 id="将切片中的字符串按特定符号连接起来：Join"><a href="#将切片中的字符串按特定符号连接起来：Join" class="headerlink" title="将切片中的字符串按特定符号连接起来：Join"></a>将切片中的字符串按特定符号连接起来：Join</h3><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>对字符串进行Mapping函数修改，如果Mapping函数返回负值，那么就删除字符串而不是替代<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rot13=<span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span><span class="title">rune</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r&gt;=<span class="string">'A'</span> &amp;&amp; r &lt;= <span class="string">'Z'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">'A'</span>+(r-<span class="string">'A'</span>+<span class="number">13</span>)%<span class="number">26</span></span><br><span class="line"><span class="keyword">case</span> r &gt;=<span class="string">'a'</span> &amp;&amp; r &lt;=<span class="string">'z'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">'a'</span>+(r-<span class="string">'a'</span>+<span class="number">13</span>)%<span class="number">26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(strings.Map(rot13,<span class="string">"Twas brilling and the slithy gopher..."</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Gjnf oevyyvat naq gur fyvgul tbcure...</span></span><br></pre></td></tr></table></figure></p><h3 id="进行字符串重复输出：Repeat"><a href="#进行字符串重复输出：Repeat" class="headerlink" title="进行字符串重复输出：Repeat"></a>进行字符串重复输出：Repeat</h3><h3 id="进行字符串的替代：Replace"><a href="#进行字符串的替代：Replace" class="headerlink" title="进行字符串的替代：Replace"></a>进行字符串的替代：Replace</h3><p>第4个参数小于0，表示所有的都替换。</p><h3 id="对字符串的前后进行修剪：Trim"><a href="#对字符串的前后进行修剪：Trim" class="headerlink" title="对字符串的前后进行修剪：Trim"></a>对字符串的<code>前后</code>进行修剪：Trim</h3><h3 id="去掉字符串前后空格：TrimSpace"><a href="#去掉字符串前后空格：TrimSpace" class="headerlink" title="去掉字符串前后空格：TrimSpace"></a>去掉字符串<code>前后</code>空格：TrimSpace</h3><h3 id="将字符串包装成一个Reader：NewReader"><a href="#将字符串包装成一个Reader：NewReader" class="headerlink" title="将字符串包装成一个Reader：NewReader"></a>将字符串包装成一个Reader：NewReader</h3><h1 id="二、bufio包"><a href="#二、bufio包" class="headerlink" title="二、bufio包"></a>二、bufio包</h1><p>处理数据流时使用</p><h3 id="读字符串直到分隔符：ReadString"><a href="#读字符串直到分隔符：ReadString" class="headerlink" title="读字符串直到分隔符：ReadString"></a>读字符串直到分隔符：ReadString</h3><p>s</p><h1 id="三、Scanner的使用"><a href="#三、Scanner的使用" class="headerlink" title="三、Scanner的使用"></a>三、Scanner的使用</h1><ul><li>默认读到空格时为一个Token，可以自定义</li><li>new一个scanner：NewScanner</li><li>设置scanner的splitFunc：scanner.Split</li><li>开始扫描，当缓冲区不为空或者读到EOF时，调用切割函数：Scan</li><li>以字符串的形式显示：Text</li></ul><h3 id="1、需要更多的值"><a href="#1、需要更多的值" class="headerlink" title="1、需要更多的值"></a>1、需要更多的值</h3><p>当split函数的返回值为<code>0,nil,nil</code>时，表示传递的数据不足以获得<code>token</code>。<br>那么当缓冲区满时，它会翻倍。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">input:=<span class="string">"abcdefghijkl"</span></span><br><span class="line">scanner:=bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">split:=<span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>,atEOF <span class="keyword">bool</span>)</span><span class="params">(advance <span class="keyword">int</span>,token []<span class="keyword">byte</span>,err error)</span></span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%t\t%d\t%s\n"</span>,atEOF,<span class="built_in">len</span>(data),data)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="literal">nil</span>,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">scanner.Split(split)</span><br><span class="line">buf:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">2</span>)<span class="comment">//将缓冲区设置为2</span></span><br><span class="line">scanner.Buffer(buf,bufio.MaxScanTokenSize)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan()&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>,scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="literal">false</span><span class="number">2</span>ab</span><br><span class="line"><span class="literal">false</span><span class="number">4</span>abcd</span><br><span class="line"><span class="literal">false</span><span class="number">8</span>abcdefgh</span><br><span class="line"><span class="literal">false</span><span class="number">12</span>abcdefghijkl</span><br><span class="line"><span class="literal">true</span><span class="number">12</span>abcdefghijkl</span><br></pre></td></tr></table></figure></p><p><code>split</code>函数返回的错误信息会保存在<code>scanner.err</code>中</p><h3 id="2、找到了Token"><a href="#2、找到了Token" class="headerlink" title="2、找到了Token"></a>2、找到了Token</h3><p><code>split</code>函数返回在缓冲区中向前移动的字节数和Token本身。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">input:=<span class="string">"foofoofoo"</span></span><br><span class="line">scanner:=bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">split:=<span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>,atEOF <span class="keyword">bool</span>)</span><span class="params">(advance <span class="keyword">int</span>,token []<span class="keyword">byte</span>,err error)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> bytes.Equal(data[:<span class="number">3</span>],[]<span class="keyword">byte</span>&#123;<span class="string">'f'</span>,<span class="string">'o'</span>,<span class="string">'o'</span>&#125;)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>,[]<span class="keyword">byte</span>&#123;<span class="string">'F'</span>&#125;,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atEOF&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="literal">nil</span>,errors.New(<span class="string">"bad luck!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="literal">nil</span>,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">scanner.Split(split)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan&#123;</span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">F</span><br><span class="line">F</span><br><span class="line">F</span><br></pre></td></tr></table></figure></p><h3 id="3、返回错误"><a href="#3、返回错误" class="headerlink" title="3、返回错误"></a>3、返回错误</h3><p>如果<code>split</code>方法返回错误，那么<code>scanner</code>立即停止。<br>但是如果返回的是最后的Token，会返回True然后再停止。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrFinalToken &#123;</span><br><span class="line">s.token = token</span><br><span class="line">s.done = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果字符串超过了默认缓冲区的最大长度（MaxScanTokenSize），会报错。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input := strings.Repeat(<span class="string">"x"</span>, bufio.MaxScanTokenSize)</span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Println(scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> scanner.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(scanner.Err())</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">bufio.Scanner: token too long</span><br></pre></td></tr></table></figure></p><h1 id="四、模拟shell"><a href="#四、模拟shell" class="headerlink" title="四、模拟shell"></a>四、模拟shell</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">reader:=bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">string</span>,err:=reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"ReadStringError:%v"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修剪后缀符</span></span><br><span class="line">input:=strings.TrimSuffix(<span class="keyword">string</span>,<span class="string">"\n"</span>)</span><br><span class="line">cmd:=exec.Command(input)</span><br><span class="line">cmd.Stderr=os.Stderr</span><br><span class="line">cmd.Stdout=os.Stdout</span><br><span class="line">cmd.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 流处理 </tag>
            
            <tag> package </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP</title>
      <link href="/2018/09/21/HTTP/"/>
      <url>/2018/09/21/HTTP/</url>
      <content type="html"><![CDATA[<h3 id="自定义Mutex"><a href="#自定义Mutex" class="headerlink" title="自定义Mutex"></a>自定义Mutex</h3><p><code>http.Handle</code>和<code>http.HandleFunc</code>都是默认调用<code>http.DafaultServeMux</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mux:=http.NewServeMux</span><br></pre></td></tr></table></figure></p><h3 id="HTTP包中的适配器"><a href="#HTTP包中的适配器" class="headerlink" title="HTTP包中的适配器"></a>HTTP包中的适配器</h3><p>创建自己的handler<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(my *myHandler)</span><span class="title">ServeHTTP</span><span class="params">(w http.RsponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello!"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">http.Handle(<span class="string">"/"</span>,&amp;myHandler&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为<code>Handler</code>这个接口只有一个<code>ServeHTTP</code>方法，只要实现这个方法的类型就实现了<code>Handler</code>这个接口。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们使用适配器来避免每次实现<code>Handler</code>都要创建一个对象和<code>ServeHTTP</code>方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myHandler</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello!"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>,myHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>HandlerFunc</code>实现了<code>Handler</code>这个接口，然后将<code>w和r</code>作为参数传给<code>f(w,r)</code>，也就是普通函数本身。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter,*http.Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandleFunc)</span><span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">f(w,r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将普通函数<code>handler</code>转换成<code>HandlerFunc</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>os包</title>
      <link href="/2018/09/21/os%E5%8C%85/"/>
      <url>/2018/09/21/os%E5%8C%85/</url>
      <content type="html"><![CDATA[<h3 id="读出数据"><a href="#读出数据" class="headerlink" title="读出数据"></a>读出数据</h3><p>在使用Read函数时，当读到的<code>n==0</code>并且<code>err==io.EOF</code>时，那么就终止读。</p><h3 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h3><p>一般写入文件时，文件默认的偏移量都是0，那么就是从0开始覆盖写入，那么我们怎么指定偏移量从最后添加写入呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出文件末尾的偏移量</span></span><br><span class="line">n,_:=f.Seek(<span class="number">0</span>,os.SEEK_END)</span><br><span class="line"><span class="comment">//在末尾添加数据</span></span><br><span class="line">f.WriteAt([]<span class="keyword">byte</span>(<span class="string">"Add Someting"</span>),n)</span><br></pre></td></tr></table></figure><h3 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h3><p>GC操作只会针对内存有用，文件描述符是资源，需要使用<code>defer f.Close()</code>关闭。</p><h3 id="截断目标文件"><a href="#截断目标文件" class="headerlink" title="截断目标文件"></a>截断目标文件</h3><p>将文件调整为目标size的大小</p><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>判断文件是否存在<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, err := os.Stat(filename)</span><br><span class="line"><span class="keyword">return</span> err == <span class="literal">nil</span> || os.IsExist(err)</span><br></pre></td></tr></table></figure></p><p>文件的权限<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Stat(filename)</span><br><span class="line">f.Mode()</span><br></pre></td></tr></table></figure></p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>使用<code>chown</code>方法改变属性</p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> package </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跳转语句</title>
      <link href="/2018/09/21/%E6%B5%81%E7%A8%8B%E8%B7%B3%E8%BD%AC/"/>
      <url>/2018/09/21/%E6%B5%81%E7%A8%8B%E8%B7%B3%E8%BD%AC/</url>
      <content type="html"><![CDATA[<h3 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h3><p>跳出LABEL1当前循环，进入下一次循环<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LABEL1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> LABEL1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>直接跳转到标志位<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> LABEL1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">LABEL1:</span><br></pre></td></tr></table></figure></p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>在不使用标签时，只是跳出第一层for循环；使用标签时，跳出标签的循环。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a:=<span class="number">0</span>;a&lt;<span class="number">5</span>;a++&#123;</span><br><span class="line">       <span class="keyword">break</span> Loop</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 跳转语句 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>闭包的使用</title>
      <link href="/2018/09/21/%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/21/%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Golang是一门函数式编程的语言。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Model        <span class="keyword">string</span></span><br><span class="line">Manufacturer <span class="keyword">string</span></span><br><span class="line">BuildYear    <span class="keyword">int</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cars []*Car</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// make some cars:</span></span><br><span class="line">ford := &amp;Car&#123;<span class="string">"Fiesta"</span>, <span class="string">"Ford"</span>, <span class="number">2008</span>&#125;</span><br><span class="line">bmw := &amp;Car&#123;<span class="string">"XL 450"</span>, <span class="string">"BMW"</span>, <span class="number">2011</span>&#125;</span><br><span class="line">merc := &amp;Car&#123;<span class="string">"D600"</span>, <span class="string">"Mercedes"</span>, <span class="number">2009</span>&#125;</span><br><span class="line">bmw2 := &amp;Car&#123;<span class="string">"X 800"</span>, <span class="string">"BMW"</span>, <span class="number">2008</span>&#125;</span><br><span class="line"><span class="comment">// query:</span></span><br><span class="line">allCars := Cars([]*Car&#123;ford, bmw, merc, bmw2&#125;)</span><br><span class="line">allNewBMWs := allCars.FindAll(<span class="function"><span class="keyword">func</span><span class="params">(car *Car)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (car.Manufacturer == <span class="string">"BMW"</span>) &amp;&amp; (car.BuildYear &gt; <span class="number">2010</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(<span class="string">"AllCars: "</span>, allCars)</span><br><span class="line">fmt.Println(<span class="string">"New BMWs: "</span>, allNewBMWs)</span><br><span class="line"></span><br><span class="line">manufacturers := []<span class="keyword">string</span>&#123;<span class="string">"Ford"</span>, <span class="string">"Aston Martin"</span>, <span class="string">"Land Rover"</span>, <span class="string">"BMW"</span>, <span class="string">"Jaguar"</span>&#125;</span><br><span class="line">sortedAppender, sortedCars := MakeSortedAppender(manufacturers)</span><br><span class="line">allCars.Process(sortedAppender)</span><br><span class="line">fmt.Println(<span class="string">"Map sortedCars: "</span>, sortedCars)</span><br><span class="line">BMWCount := <span class="built_in">len</span>(sortedCars[<span class="string">"BMW"</span>])</span><br><span class="line">fmt.Println(<span class="string">"We have "</span>, BMWCount, <span class="string">" BMWs"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process all cars with the given function f:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs Cars)</span> <span class="title">Process</span><span class="params">(f <span class="keyword">func</span>(*Car)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line">f(c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all cars matching a given criteria.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs Cars)</span> <span class="title">FindAll</span><span class="params">(f <span class="keyword">func</span>(car *Car)</span> <span class="title">bool</span>) <span class="title">Cars</span></span> &#123;</span><br><span class="line">cars := <span class="built_in">make</span>([]*Car, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cs.Process(<span class="function"><span class="keyword">func</span><span class="params">(c *Car)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f(c) &#123;</span><br><span class="line">cars = <span class="built_in">append</span>(cars, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> cars</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process cars and create new data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs Cars)</span> <span class="title">Map</span><span class="params">(f <span class="keyword">func</span>(car *Car)</span> <span class="title">Any</span>) []<span class="title">Any</span></span> &#123;</span><br><span class="line">result := <span class="built_in">make</span>([]Any, <span class="built_in">len</span>(cs))</span><br><span class="line">ix := <span class="number">0</span></span><br><span class="line">cs.Process(<span class="function"><span class="keyword">func</span><span class="params">(c *Car)</span></span> &#123;</span><br><span class="line">result[ix] = f(c)</span><br><span class="line">ix++</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeSortedAppender</span><span class="params">(manufacturers []<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>(car *Car)</span>, <span class="title">map</span>[<span class="title">string</span>]<span class="title">Cars</span>)</span> &#123;</span><br><span class="line"><span class="comment">// Prepare maps of sorted cars.</span></span><br><span class="line">sortedCars := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Cars)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, m := <span class="keyword">range</span> manufacturers &#123;</span><br><span class="line">sortedCars[m] = <span class="built_in">make</span>([]*Car, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">sortedCars[<span class="string">"Default"</span>] = <span class="built_in">make</span>([]*Car, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare appender function:</span></span><br><span class="line">appender := <span class="function"><span class="keyword">func</span><span class="params">(c *Car)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := sortedCars[c.Manufacturer]; ok &#123;</span><br><span class="line">sortedCars[c.Manufacturer] = <span class="built_in">append</span>(sortedCars[c.Manufacturer], c)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sortedCars[<span class="string">"Default"</span>] = <span class="built_in">append</span>(sortedCars[<span class="string">"Default"</span>], c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> appender, sortedCars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>代理</title>
      <link href="/2018/09/17/%E4%BB%A3%E7%90%86/"/>
      <url>/2018/09/17/%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="下载golang-org-x-下的包"><a href="#下载golang-org-x-下的包" class="headerlink" title="下载golang.org/x/下的包"></a>下载golang.org/x/下的包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/golang/oauth2.git golang.org/x/oauth2</span><br></pre></td></tr></table></figure><h3 id="设置git代理"><a href="#设置git代理" class="headerlink" title="设置git代理"></a>设置git代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br></pre></td></tr></table></figure><h3 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.sh</span><br><span class="line">chmod +x shadowsocks-go.sh</span><br><span class="line">./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log</span><br><span class="line">systemctl start shadowsocks</span><br><span class="line">systemctl enable shadowsocks</span><br></pre></td></tr></table></figure><h3 id="安装kcptun"><a href="#安装kcptun" class="headerlink" title="安装kcptun"></a>安装kcptun</h3><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/kcptun</span><br><span class="line">cd /root/kcptun</span><br><span class="line">wget https://github.com/xtaci/kcptun/releases/download/v20180810/kcptun-linux-amd64-20180810.tar.gz</span><br><span class="line">tar -zxvf kcptun-linux-amd64-*.tar.gz</span><br></pre></td></tr></table></figure></p><p>做一个kcptun服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/kcptun.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=start kcptun!</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=./server_linux_amd64 -l :29900 -t 127.0.0.1:xxxx -key xxxxx -mtu 1400 -sndwnd 2048 -rcvwnd 2048 -mode fast2 &gt; kcptun.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p><p>载入服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl-daemon reload</span><br><span class="line">systemctl start kcptun</span><br><span class="line">systemctl enable kcptun</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2018/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2018/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="指针的理解"><a href="#指针的理解" class="headerlink" title="指针的理解"></a>指针的理解</h1><p>如果声明了地址变量，那么首先就要给地址变量赋值，不然不知道往哪里读写<br>两者都是<code>*p</code>，但是因为p的值不同，<code>*p</code>代表的内存地址也就不同<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">3</span>;</span><br><span class="line">p = p + <span class="number">3</span>;</span><br><span class="line">i = *p;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV  ECX,i                        //在cpu中执行</span><br><span class="line">MOV  BYTE [ECX],(i &amp; 0x0f)        //在内存芯片中执行</span><br></pre></td></tr></table></figure><p><code>*(p+i)</code>等价于<code>p[i]</code>，也等价于<code>i[p]</code>，所以<code>*p</code>，也就是<code>p[0]</code></p><h1 id="反码、补码、原码"><a href="#反码、补码、原码" class="headerlink" title="反码、补码、原码"></a>反码、补码、原码</h1><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><ul><li>正数的话原码、反码、补码都是一样的 </li><li>补码：从右往左数，每位取反，最后加1 </li><li>反码：原码的每位都取反，反码加一等于补码 </li><li>补码的补码就是原码 </li></ul><blockquote><p>一这样算术逻辑单元（LRU）做整数运算时，就不要区分符号位了，直接进行与运算。个负整数可以由它的绝对值-1，求补码得到</p></blockquote><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>如果给定一个数：<code>10000100=132</code><br>因为符号位是1，所以这个数是用补码表示的，取它的补码来显示原码：<code>01111100=124</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-1在golang中的表示形式</span></span><br><span class="line">^<span class="keyword">uint32</span>(-NN<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><h4 id="或：只有有一个1，该位就是1（特定位变1）"><a href="#或：只有有一个1，该位就是1（特定位变1）" class="headerlink" title="或：只有有一个1，该位就是1（特定位变1）"></a>或：只有有一个1，该位就是1（特定位变1）</h4><p>比如：1010 或 0010 等于 1010<br>那么对于1010来说，第三位就一定会变成1</p><h4 id="与：都是1时，该位就是1（特定位变0）"><a href="#与：都是1时，该位就是1（特定位变0）" class="headerlink" title="与：都是1时，该位就是1（特定位变0）"></a>与：都是1时，该位就是1（特定位变0）</h4><p>比如：1010 与 1101 等于 1000<br>那么对于1010来说，第三位就一定会变成0</p><h4 id="异或：值不相同，该位就是1（特定位反转）"><a href="#异或：值不相同，该位就是1（特定位反转）" class="headerlink" title="异或：值不相同，该位就是1（特定位反转）"></a>异或：值不相同，该位就是1（特定位反转）</h4><p>比如：0100 异或 0010 等于 0110<br>那么对于0100来说，第三位就一定反转</p>]]></content>
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据库资源</title>
      <link href="/2018/09/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B5%84%E6%BA%90/"/>
      <url>/2018/09/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B5%84%E6%BA%90/</url>
      <content type="html"><![CDATA[<h1 id="1、资源"><a href="#1、资源" class="headerlink" title="1、资源"></a>1、资源</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/23624390" target="_blank" rel="noopener">深入浅出数据库索引原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/32984037" target="_blank" rel="noopener">nosql技术体系合集</a></li><li><a href="https://www.zhihu.com/question/21760988/answer/197936695" target="_blank" rel="noopener">如何系统的学习MySQL</a></li></ul>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础算法和数据结构</title>
      <link href="/2018/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h3 id="数组的合并"><a href="#数组的合并" class="headerlink" title="数组的合并"></a>数组的合并</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求数组最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMax</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">max := a[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">if</span> num &gt; max &#123;</span><br><span class="line">max = num</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求数组最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">min := a[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">if</span> num &lt; min &#123;</span><br><span class="line">min = num</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有序数组合并</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeArray</span><span class="params">(a []<span class="keyword">int</span>, b []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a_i, b_i <span class="keyword">int</span> = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> a_i &lt; <span class="built_in">len</span>(a) &amp;&amp; b_i &lt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line"><span class="keyword">if</span> a[a_i] &lt; b[b_i] &#123;</span><br><span class="line">c = <span class="built_in">append</span>(c, a[a_i])</span><br><span class="line">a_i++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a[a_i] &gt; b[b_i] &#123;</span><br><span class="line">c = <span class="built_in">append</span>(c, b[b_i])</span><br><span class="line">b_i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c = <span class="built_in">append</span>(c, a[a_i], b[b_i])</span><br><span class="line">a_i++</span><br><span class="line">b_i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a_i &lt; <span class="built_in">len</span>(a) &#123;</span><br><span class="line">c = <span class="built_in">append</span>(c, a[a_i:]...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b_i &lt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line">c = <span class="built_in">append</span>(c, b[b_i:]...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 数组合并</span></span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+ 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i; j &gt; <span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="keyword">if</span> a[j] &lt; a[j<span class="number">-1</span>] &#123;</span><br><span class="line">a[j], a[j<span class="number">-1</span>] = a[j<span class="number">-1</span>], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+ 冒泡排序2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort2</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(a)-i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> a[j] &lt; a[j<span class="number">-1</span>] &#123;</span><br><span class="line">a[j], a[j<span class="number">-1</span>] = a[j<span class="number">-1</span>], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//- 冒泡排序</span></span><br></pre></td></tr></table></figure><h3 id="二分排序"><a href="#二分排序" class="headerlink" title="二分排序"></a>二分排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">halfSort</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">L := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> L &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">halfSort(a[<span class="number">0</span> : L/<span class="number">2</span>])</span><br><span class="line">halfSort(a[L/<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">copy</span>(a, mergeArray(a[<span class="number">0</span>:L/<span class="number">2</span>], a[L/<span class="number">2</span>:]))</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 二分排序</span></span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="\images\快速排序.png" alt="快速排序"></p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ol><li>待排序列6，1，2，7，9，3，4，5，10，8</li><li>首先取第一个数：6，首尾指针s和e</li><li>判断尾指针是否大于6，大于就替换：5，1，2，7，9，3，4，5，10，8</li><li>判断首指针是否大于尾指针，大于就替换：5，1，2，7，9，3，4，7，10，8</li><li>以此类推，首指针小于等于尾指针时，一轮结束：5，1，2，4，3，6，9，7，10，8</li><li>第一轮将比6大的放右边，比6小的放左边<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+ 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a) &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p := partition(a)</span><br><span class="line">quickSort(a[<span class="number">0</span>:p])</span><br><span class="line">quickSort(a[p+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">mid := nums[<span class="number">0</span>]</span><br><span class="line">s, e := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> s &lt; e &#123;</span><br><span class="line"><span class="keyword">for</span> s &lt; e &amp;&amp; nums[e] &gt; mid &#123;</span><br><span class="line">e -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s &lt; e &#123;</span><br><span class="line">nums[s] = nums[e]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s &lt; e &amp;&amp; nums[s] &lt;= mid &#123;</span><br><span class="line">s += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s &lt; e &#123;</span><br><span class="line">nums[e] = nums[s]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[s] = mid</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 快速排序</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="\images\堆的建立.png" alt="堆排序"></p><h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><ol><li>从上图中我们可以看出这是一个大根堆(顶端元素是最大的)</li><li>所以我们每次将最大的元素放在末尾，然后继续求出第二大的…</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+ 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//生成大根堆</span></span><br><span class="line"><span class="keyword">for</span> i := (<span class="built_in">len</span>(a) - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">heapDown(a, i, <span class="built_in">len</span>(a)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行排序</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">a[i], a[<span class="number">0</span>] = a[<span class="number">0</span>], a[i]</span><br><span class="line">heapDown(a, <span class="number">0</span>, i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapDown</span><span class="params">(a []<span class="keyword">int</span>, start <span class="keyword">int</span>, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">p := start</span><br><span class="line">l := left(start)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//拦截条件：当超出范围时跳出循环</span></span><br><span class="line"><span class="keyword">if</span> l &gt; end &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果“l”不是最后一个元素，比较左右孩子的大小，选出最大的孩子</span></span><br><span class="line"><span class="keyword">if</span> l &lt; end &amp;&amp; a[l] &lt; a[l+<span class="number">1</span>] &#123;</span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果节点比孩子中最大的小，那就替换</span></span><br><span class="line"><span class="keyword">if</span> a[p] &gt;= a[l] &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a[p], a[l] = a[l], a[p]</span><br><span class="line">p = l</span><br><span class="line">l = left(p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父母结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parents</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (a - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左孩子结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">left</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右孩子结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">right</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 堆排序</span></span><br></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+ 计数排序1：不利于处理数字隔度很大的数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSort</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">max := findMax(a)</span><br><span class="line">countArry := <span class="built_in">make</span>([]<span class="keyword">int</span>, max+<span class="number">1</span>)</span><br><span class="line">bucket := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">countArry[a[i]] = countArry[a[i]] + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(countArry); i++ &#123;</span><br><span class="line">countArry[i] = countArry[i] + countArry[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">bucket[countArry[a[i]]<span class="number">-1</span>] = a[i]</span><br><span class="line">countArry[a[i]] = countArry[a[i]] - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bucket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+ 计数排序2：基于投票的机制，速度快</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSort2</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">bucket := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="keyword">var</span> vote <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(a); j++ &#123;</span><br><span class="line">vote = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> a[i] &lt; a[j] &#123; <span class="comment">//3, 5, 10, 1, 6, 3, 2, 4, 9</span></span><br><span class="line">vote++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> bucket[vote] != <span class="number">0</span> &#123;</span><br><span class="line">bucket[vote+<span class="number">1</span>] = a[j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bucket[vote] = a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bucket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 计数排序</span></span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><img src="\images\基数排序.png" alt="基数排序"></p><ol><li>按照个位数进行排序</li><li>按照十位数进行排序</li><li>按照百位数进行排序<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+ 基数排序：不利于数字分隔较大的比较</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">max := findMax(a)</span><br><span class="line"><span class="comment">//记录最大是多少位</span></span><br><span class="line">d := <span class="number">0</span></span><br><span class="line">tmp_max := max</span><br><span class="line"><span class="keyword">for</span> tmp_max &gt; <span class="number">0</span> &#123;</span><br><span class="line">tmp_max /= <span class="number">10</span></span><br><span class="line">d += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; d; i += <span class="number">1</span> &#123;</span><br><span class="line">a = countingSort(a, i, max)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort</span><span class="params">(a []<span class="keyword">int</span>, d, max <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">bucket := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line">countArry := <span class="built_in">make</span>([]<span class="keyword">int</span>, max+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">countArry[getBit(a[i], d)] += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(countArry); i++ &#123;</span><br><span class="line">countArry[i] += countArry[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">bucket[countArry[getBit(a[i], d)]<span class="number">-1</span>] = a[i]</span><br><span class="line">countArry[getBit(a[i], d)] -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bucket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+ 基数排序2：基于投票机制，比较快</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort2</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">max := findMax(a)</span><br><span class="line"><span class="comment">//记录最大是多少位</span></span><br><span class="line">d := <span class="number">0</span></span><br><span class="line">tmp_max := max</span><br><span class="line"><span class="keyword">for</span> tmp_max &gt; <span class="number">0</span> &#123;</span><br><span class="line">tmp_max /= <span class="number">10</span></span><br><span class="line">d += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; d; i += <span class="number">1</span> &#123;</span><br><span class="line">a = countingSort2(a, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countingSort2</span><span class="params">(a []<span class="keyword">int</span>, bit <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> vote <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> iBit, jBit <span class="keyword">int</span></span><br><span class="line">bucket := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">vote = <span class="number">0</span></span><br><span class="line">iBit = getBit(a[i], bit)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(a); j++ &#123;</span><br><span class="line">jBit = getBit(a[j], bit)</span><br><span class="line"><span class="keyword">if</span> iBit &gt; jBit &#123;</span><br><span class="line">vote++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> bucket[vote] != <span class="number">0</span> &#123;</span><br><span class="line">vote++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bucket[vote] = a[i]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bucket</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取该位的数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBit</span><span class="params">(num, d <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> num != <span class="number">0</span> &amp;&amp; d &gt; <span class="number">0</span> &#123;</span><br><span class="line">num /= <span class="number">10</span></span><br><span class="line">d -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num % <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 基数排序</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p><img src="\images\桶排序.png" alt="桶排序"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+ 桶排序</span></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">num  <span class="keyword">int</span></span><br><span class="line">next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketSort</span><span class="params">(a []<span class="keyword">int</span>, bucketNum <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">buckets := <span class="built_in">make</span>([]*ListNode, bucketNum)</span><br><span class="line">max := findMax(a)</span><br><span class="line">min := findMin(a)</span><br><span class="line">average := <span class="keyword">float64</span>(max-min+<span class="number">1</span>) / <span class="keyword">float64</span>(bucketNum)</span><br><span class="line"><span class="comment">//将数据插入桶中</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> a &#123;</span><br><span class="line">index := <span class="keyword">int</span>(<span class="keyword">float64</span>(num-min) / average)</span><br><span class="line"><span class="comment">//重新赋值bucket[index]</span></span><br><span class="line">buckets[index] = insert(buckets[index], num)</span><br><span class="line">&#125;</span><br><span class="line">h := buckets[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//合并桶数据</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(buckets); i++ &#123;</span><br><span class="line">h = mergeBucket(h, buckets[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新排列数组</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">a[i] = h.num</span><br><span class="line">h = h.next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeBucket</span><span class="params">(first, second *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">firstNode := first</span><br><span class="line"><span class="keyword">var</span> previous *ListNode</span><br><span class="line"><span class="keyword">for</span> first != <span class="literal">nil</span> &#123;</span><br><span class="line">previous = first</span><br><span class="line">first = first.next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> second != <span class="literal">nil</span> &#123;</span><br><span class="line">previous.next = second</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> firstNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(h *ListNode, num <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">newNode := &amp;ListNode&#123;num: num&#125;</span><br><span class="line">dummyNode := &amp;ListNode&#123;next: h&#125;</span><br><span class="line">previous := dummyNode</span><br><span class="line">current := h</span><br><span class="line"><span class="keyword">for</span> current != <span class="literal">nil</span> &amp;&amp; current.num &lt;= num &#123;</span><br><span class="line">previous = current</span><br><span class="line">current = current.next</span><br><span class="line">&#125;</span><br><span class="line">newNode.next = current</span><br><span class="line">previous.next = newNode</span><br><span class="line"><span class="keyword">return</span> dummyNode.next</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//- 桶排序</span></span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h3 id="以切片来实现栈"><a href="#以切片来实现栈" class="headerlink" title="以切片来实现栈"></a>以切片来实现栈</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切片实现</span></span><br><span class="line"><span class="keyword">type</span> sliceInplement <span class="keyword">struct</span> &#123;</span><br><span class="line">element []Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSliceInplement</span><span class="params">()</span> *<span class="title">sliceInplement</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;sliceInplement&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si *sliceInplement)</span> <span class="title">Push</span><span class="params">(e Element)</span></span> &#123;</span><br><span class="line">si.element = <span class="built_in">append</span>(si.element, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si *sliceInplement)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(e Element)</span></span> &#123;</span><br><span class="line">size := si.Size()</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"The stack is empty!"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">lastElement := si.element[size<span class="number">-1</span>]</span><br><span class="line">si.element[size<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">si.element = si.element[:size<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> lastElement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si *sliceInplement)</span> <span class="title">Top</span><span class="params">()</span> <span class="params">(e Element)</span></span> &#123;</span><br><span class="line">size := si.Size()</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"The stack is empty!"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">lastElement := si.element[size<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> lastElement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si *sliceInplement)</span> <span class="title">Clear</span><span class="params">()</span><span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> si.IsEmpty()&#123;</span><br><span class="line">fmt.Println(<span class="string">"The stack is empty!"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;si.Size();i++&#123;</span><br><span class="line">si.element[i]=<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">si.element=<span class="built_in">make</span>([]Element,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si *sliceInplement)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(si.element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si *sliceInplement)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(si.element) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="以双向链表来实现"><a href="#以双向链表来实现" class="headerlink" title="以双向链表来实现"></a>以双向链表来实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> header *entry</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链的长度：栈的长度</span></span><br><span class="line"><span class="keyword">var</span> size <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">prev    *entry</span><br><span class="line">next    *entry</span><br><span class="line">element Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">interface</span> &#123;</span><br><span class="line">Pop() Element</span><br><span class="line">Push(e Element)</span><br><span class="line">Clear() <span class="keyword">bool</span></span><br><span class="line">Top() Element</span><br><span class="line">Size() <span class="keyword">int</span></span><br><span class="line">IsEmpty() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntry</span><span class="params">(prev, next *entry, e Element)</span> *<span class="title">entry</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;entry&#123;prev, next, e&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果这里使用了 header:=newEntry() 的话会产生空指针引用的错误</span></span><br><span class="line"><span class="comment">//因为变量header不在该函数的作用域，所以会重新定义新的变量header</span></span><br><span class="line"><span class="comment">//这样引用一个未分配内存的空指针变量会panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHeader</span><span class="params">()</span> *<span class="title">entry</span></span> &#123;</span><br><span class="line">header = newEntry(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">10</span>)</span><br><span class="line">header.next = header</span><br><span class="line">header.prev = header</span><br><span class="line"><span class="keyword">return</span> header</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将新节点插入在表头的前面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addBefore</span><span class="params">(e *entry, element Element)</span> <span class="title">Element</span></span> &#123;</span><br><span class="line">newEntry := newEntry(e.prev, e, element)</span><br><span class="line"><span class="comment">//两者换一个位置</span></span><br><span class="line">newEntry.prev.next = newEntry</span><br><span class="line">newEntry.next.prev = newEntry</span><br><span class="line">size++</span><br><span class="line"><span class="keyword">return</span> newEntry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">Push</span><span class="params">(element Element)</span></span> &#123;</span><br><span class="line">addBefore(e, element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">Element</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e.IsEmpty() &#123;</span><br><span class="line">fmt.Println(<span class="string">"The stack is empty!"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">prevEntry := header.prev</span><br><span class="line">header.prev = prevEntry.prev</span><br><span class="line">prevEntry.prev.next = header</span><br><span class="line">size--</span><br><span class="line"><span class="keyword">return</span> prevEntry.element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">Clear</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e.IsEmpty() &#123;</span><br><span class="line">fmt.Println(<span class="string">"The Stack is empty!"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">list := header.next</span><br><span class="line"><span class="keyword">for</span> list != header &#123;</span><br><span class="line">next_list := list.next</span><br><span class="line">list.next = <span class="literal">nil</span></span><br><span class="line">list.element = <span class="literal">nil</span></span><br><span class="line">list.prev = <span class="literal">nil</span></span><br><span class="line">list = next_list</span><br><span class="line">&#125;</span><br><span class="line">header.next = header</span><br><span class="line">header.prev = header</span><br><span class="line">size = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">Element</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e.IsEmpty() &#123;</span><br><span class="line">fmt.Println(<span class="string">"The Stack is empty!"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> header.prev.element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="迪克斯特拉算法"><a href="#迪克斯特拉算法" class="headerlink" title="迪克斯特拉算法"></a>迪克斯特拉算法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> processed []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">graph:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"start"</span>:&#123;</span><br><span class="line"><span class="string">"a"</span>:<span class="number">6</span>,</span><br><span class="line"><span class="string">"b"</span>:<span class="number">2</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"a"</span>:&#123;</span><br><span class="line"><span class="string">"终点"</span>:<span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"b"</span>:&#123;</span><br><span class="line"><span class="string">"a"</span>:<span class="number">3</span>,</span><br><span class="line"><span class="string">"终点"</span>:<span class="number">5</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">costs:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"a"</span>:<span class="number">6</span>,</span><br><span class="line"><span class="string">"b"</span>:<span class="number">2</span>,</span><br><span class="line"><span class="string">"终点"</span>:<span class="number">1</span>&lt;&lt;<span class="number">31</span><span class="number">-1</span>,</span><br><span class="line">&#125;</span><br><span class="line">parents:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"a"</span>:<span class="string">"起点"</span>,</span><br><span class="line"><span class="string">"b"</span>:<span class="string">"起点"</span>,</span><br><span class="line"><span class="string">"终点"</span>:<span class="string">""</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">node:=find_lowest_cost_node(costs)</span><br><span class="line"><span class="keyword">if</span> node==<span class="string">""</span>&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">cost:=costs[node]</span><br><span class="line">neighbors:=graph[node]</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> neighbors&#123;</span><br><span class="line">new_cost:=cost+neighbors[n]</span><br><span class="line"><span class="keyword">if</span> costs[n]&gt;new_cost&#123;</span><br><span class="line">costs[n]=new_cost</span><br><span class="line">parents[n]=node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">processed=<span class="built_in">append</span>(processed,node)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"graph:"</span>,graph)</span><br><span class="line">fmt.Println(<span class="string">"costs:"</span>,costs)</span><br><span class="line">fmt.Println(<span class="string">"parents:"</span>,parents)</span><br><span class="line">fmt.Println(<span class="string">"processed:"</span>,processed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find_lowest_cost_node</span><span class="params">(costs <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> lowest_cost <span class="keyword">int</span>=<span class="number">1</span>&lt;&lt;<span class="number">31</span><span class="number">-1</span></span><br><span class="line"><span class="keyword">var</span> lowest_cost_node <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> node:=<span class="keyword">range</span> costs&#123;</span><br><span class="line">cost:=costs[node]</span><br><span class="line"><span class="keyword">if</span> cost&lt;lowest_cost &amp;&amp; find_not_in_slice(node)&#123;</span><br><span class="line">lowest_cost = cost</span><br><span class="line">lowest_cost_node = node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lowest_cost_node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find_not_in_slice</span><span class="params">(node <span class="keyword">string</span>)</span><span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> processed&#123;</span><br><span class="line"><span class="keyword">if</span> v==node&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先遍历图"><a href="#深度优先遍历图" class="headerlink" title="深度优先遍历图"></a>深度优先遍历图</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q queue.Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RootNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Data         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">ChildNodeArr []ChildNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ChildNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AdjacentList []RootNode</span><br><span class="line"></span><br><span class="line"><span class="comment">//+ 深度优先遍历</span></span><br><span class="line"><span class="comment">// 0-&gt;1 0-&gt;4 1-&gt;3 3-&gt;2 4-&gt;5 6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dfs</span><span class="params">(adjacent AdjacentList,recordTable <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>, visitFunc <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//遍历所有节点</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(adjacent);i++ &#123;</span><br><span class="line">rootNode:=adjacent[i].Data</span><br><span class="line"><span class="keyword">if</span> visited[rootNode]!=<span class="number">1</span> &#123;</span><br><span class="line">dfsVisit(adjacent,i, recordTable,visited, visitFunc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于根节点进行路径递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsVisit</span><span class="params">(adjacent AdjacentList,i <span class="keyword">int</span>, recordTable,visited <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>, visitFunc <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">visited[adjacent[i].Data]=<span class="number">1</span></span><br><span class="line">visitFunc(adjacent[i].Data)</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(adjacent[i].ChildNodeArr);j++&#123;</span><br><span class="line">childNode:=adjacent[i].ChildNodeArr[j].Data</span><br><span class="line"><span class="keyword">if</span> visited[childNode]!=<span class="number">1</span>&#123;</span><br><span class="line">index:=recordTable[childNode]</span><br><span class="line">dfsVisit(adjacent,index,recordTable,visited,visitFunc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录节点索引对应关系</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recordTheNode</span><span class="params">(adjacent AdjacentList)</span><span class="title">map</span>[<span class="title">interface</span></span>&#123;&#125;]<span class="keyword">int</span>&#123;</span><br><span class="line">record:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(adjacent);i++&#123;</span><br><span class="line">record[adjacent[i].Data]=i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> record</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showDot</span><span class="params">(adjacent AdjacentList)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> info <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> adjacent &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(adjacent[i].ChildNodeArr); j++ &#123;</span><br><span class="line">node := adjacent[i]</span><br><span class="line">info += fmt.Sprintf(<span class="string">"%v-&gt;%v;\n"</span>, node.Data, node.ChildNodeArr[j].Data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历图"><a href="#广度优先遍历图" class="headerlink" title="广度优先遍历图"></a>广度优先遍历图</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+ 广度优先遍历</span></span><br><span class="line"><span class="comment">//0-&gt;1 0-&gt;4 1-&gt;3 3-&gt;2 4-&gt;5 6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bfs</span><span class="params">(adjacent AdjacentList,recordTable <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>, visitFunc <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">q = queue.NewHeader()</span><br><span class="line">visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(adjacent); i++ &#123;</span><br><span class="line">rootNode := adjacent[i].Data</span><br><span class="line"><span class="keyword">if</span> visited[rootNode] != <span class="number">1</span> &#123;</span><br><span class="line">bfsVisit(adjacent, i,recordTable,visited, visitFunc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfsVisit</span><span class="params">(adjacent AdjacentList, i <span class="keyword">int</span>, recordTable,visited <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>, visitFunc <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">recentElement := adjacent[i].Data</span><br><span class="line">visited[recentElement] = <span class="number">1</span></span><br><span class="line">visitFunc(recentElement)</span><br><span class="line">q.Push(recentElement)</span><br><span class="line"><span class="keyword">for</span> !q.IsEmpty() &#123;</span><br><span class="line">v:=q.Pop()</span><br><span class="line">index:=recordTable[v]</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(adjacent[index].ChildNodeArr);j++&#123;</span><br><span class="line">childElement:=adjacent[index].ChildNodeArr[j].Data</span><br><span class="line"><span class="keyword">if</span> visited[childElement]!=<span class="number">1</span>&#123;</span><br><span class="line">visitFunc(childElement)</span><br><span class="line">q.Push(childElement)</span><br><span class="line">visited[childElement]=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">adjacent := AdjacentList&#123;</span><br><span class="line">RootNode&#123;</span><br><span class="line">Data: <span class="number">0</span>,</span><br><span class="line">ChildNodeArr: []ChildNode&#123;</span><br><span class="line">ChildNode&#123;<span class="number">1</span>&#125;,</span><br><span class="line">ChildNode&#123;<span class="number">4</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">RootNode&#123;</span><br><span class="line">Data: <span class="number">1</span>,</span><br><span class="line">ChildNodeArr: []ChildNode&#123;</span><br><span class="line">ChildNode&#123;<span class="number">3</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">RootNode&#123;</span><br><span class="line">Data: <span class="number">2</span>,</span><br><span class="line">ChildNodeArr: []ChildNode&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">RootNode&#123;</span><br><span class="line">Data:         <span class="number">3</span>,</span><br><span class="line">ChildNodeArr: []ChildNode&#123;</span><br><span class="line">ChildNode&#123;<span class="number">2</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">RootNode&#123;</span><br><span class="line">Data: <span class="number">4</span>,</span><br><span class="line">ChildNodeArr: []ChildNode&#123;</span><br><span class="line">ChildNode&#123;<span class="number">5</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">RootNode&#123;</span><br><span class="line">Data: <span class="number">5</span>,</span><br><span class="line">ChildNodeArr: []ChildNode&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">RootNode&#123;</span><br><span class="line">Data: <span class="number">6</span>,</span><br><span class="line">ChildNodeArr: []ChildNode&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> recordTable=recordTheNode(adjacent)</span><br><span class="line">Dfs(adjacent, revordTable ,<span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Println(data)</span><br><span class="line">&#125;)</span><br><span class="line">Bfs(adjacent, recordTable, <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Println(data)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL深入浅出</title>
      <link href="/2018/09/06/MySQL%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"/>
      <url>/2018/09/06/MySQL%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</url>
      <content type="html"><![CDATA[<h1 id="1、MySQL基础"><a href="#1、MySQL基础" class="headerlink" title="1、MySQL基础"></a>1、MySQL基础</h1><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><ul><li>DDL（数据定义语言）：create、drop、alter<br>对数据库内部对象进行操作</li><li>DML（数据操纵语言）：insert、delete、update、select<br>对表内部数据进行操作</li><li>DCL（数据控制语言）：grant、revoke</li></ul><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><p>use mysql database changed<br>show databases;<br>drop database databaseName;<br>drop table tableName;<br>create table tmp(ename varchar(10),hiredate date,saliary decimal(10,2),deptno int(2));<br>desc tmp;<br>//修改表字段类型<br>alter table tableName modify ename varchar(20);<br>//添加表字段<br>alter table tableName add column age int(3);<br>alter table tableName add column age int(3) after ename;<br>alter table tableName add column age int(3) first;<br>//删除表字段<br>alter table tableName drop column age;<br>//修改字段名和类型<br>alter table tableName change column age new_age int(4);</p><p>//删除表记录<br>delete from tableName where …;<br>//更新表记录<br>update tableName set first_name = “z”, last_name = “zy” where first_name = “Tom” and last_name = “Curise”;</p><h3 id="综合建表语句"><a href="#综合建表语句" class="headerlink" title="综合建表语句"></a>综合建表语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">smallint</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  <span class="string">`first_name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'姓'</span>,</span><br><span class="line">  <span class="string">`last_name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'名'</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱地址'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`updated_at`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_email`</span> (<span class="string">`email`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'用户表'</span>;</span><br></pre></td></tr></table></figure><h1 id="2、MySQL细节"><a href="#2、MySQL细节" class="headerlink" title="2、MySQL细节"></a>2、MySQL细节</h1><h3 id="使用“”的作用："><a href="#使用“”的作用：" class="headerlink" title="使用“”的作用："></a>使用“<code></code>”的作用：</h3><p>当你创建表或者字段时，有时候表名或者字段名会和关键字冲突。那么使用“<code></code>”，就会避免这些问题。</p><h3 id="varchar-10-和-varchar-100-的区别"><a href="#varchar-10-和-varchar-100-的区别" class="headerlink" title="varchar(10) 和 varchar(100)的区别"></a>varchar(10) 和 varchar(100)的区别</h3><p>两者都是按实际变量的大小来存储在硬盘上的，但是前者在内存中只分配<code>10字节</code>的空间，后者分配<code>100字节</code>空间。<br>对于需要在内存中操作的字段，比如排序，要根据实际情况分配内存空间。</p><h3 id="int-10-和-int-1-的区别"><a href="#int-10-和-int-1-的区别" class="headerlink" title="int(10) 和 int(1)的区别"></a>int(10) 和 int(1)的区别</h3><p>其实没多大的区别，只有显示宽度的区别：比如<code>int(4)</code>，但是我储存的是个位数，那么前面用0填充（0003）。</p><h3 id="导入SQL语句的脚本："><a href="#导入SQL语句的脚本：" class="headerlink" title="导入SQL语句的脚本："></a>导入SQL语句的脚本：</h3><p>source d:\xxx.sql</p><h3 id="“where-1-1”和“where-1-0”的用法"><a href="#“where-1-1”和“where-1-0”的用法" class="headerlink" title="“where 1=1”和“where 1=0”的用法"></a>“where 1=1”和“where 1=0”的用法</h3><p>根据旧表的字段来构造新表，因为<code>where 1=0</code>永远不成立，所以只是读取了表结构，不考虑表数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> newtable <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> oldtable <span class="keyword">where</span> <span class="number">1</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang变量作用域的坑</title>
      <link href="/2018/09/02/Golang%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%9D%91/"/>
      <url>/2018/09/02/Golang%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(*<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">        <span class="keyword">return</span> &amp;i, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p, err := foo()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line">        bar()</span><br><span class="line">        fmt.Println(*p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果出现panic</span></span><br><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure><p>当使用<code>:=</code>赋值变量时，如果新变量与同名的变量不在一个作用域的话，那么就不会使用那个全局变量，而是定义新变量，所以<code>p</code>全局变量为nil，那么指向nil的指针会panic！</p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量 </tag>
            
            <tag> golang </tag>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大小端</title>
      <link href="/2018/08/31/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
      <url>/2018/08/31/%E5%A4%A7%E5%B0%8F%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h3 id="内存分布结构"><a href="#内存分布结构" class="headerlink" title="内存分布结构"></a>内存分布结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">| 栈底</span><br><span class="line"> .</span><br><span class="line"> .              栈</span><br><span class="line"> .</span><br><span class="line">| 栈顶</span><br><span class="line">-----------------------</span><br><span class="line"> |</span><br><span class="line"> |</span><br><span class="line">\|/</span><br><span class="line">NULL (空洞)</span><br><span class="line">/|\</span><br><span class="line"> |</span><br><span class="line"> |</span><br><span class="line">-----------------------</span><br><span class="line">                堆</span><br><span class="line">-----------------------</span><br><span class="line">未初始化的数据</span><br><span class="line">----------------(统称数据段)</span><br><span class="line">初始化的数据</span><br><span class="line">-----------------------</span><br><span class="line">正文段(代码段)</span><br><span class="line">----------------------- 最低内存地址 0x00000000</span><br></pre></td></tr></table></figure><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><ul><li>Litter-Endian：在内存的低地址中存放高位数据</li><li>Big-Endian：在内存的低地址中存放低位数据</li><li>数据<code>0x0806</code>的高位字节是08，低位字节是06</li></ul><blockquote><p>参考<a href="https://www.jianshu.com/p/5539033a23d3" target="_blank" rel="noopener">字节大小端</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>区块链</title>
      <link href="/2018/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2018/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      <content type="html"><![CDATA[<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li>一致性（consistency）</li><li>可用性（availablity）</li><li>分区容错性（partition）</li></ul><h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h2 id="哈希函数三个特性"><a href="#哈希函数三个特性" class="headerlink" title="哈希函数三个特性"></a>哈希函数三个特性</h2><h4 id="碰撞阻力"><a href="#碰撞阻力" class="headerlink" title="碰撞阻力"></a>碰撞阻力</h4><p>对于两个不同的值，不会产生了相同的哈希</p><h4 id="隐蔽性"><a href="#隐蔽性" class="headerlink" title="隐蔽性"></a>隐蔽性</h4><ol><li>比如<code>H</code>一个哈希函数，<code>msg</code>是信息，如果这时我要生成一个承诺</li><li>从高阶最小熵（随机变量的离散程度）选取一个<code>nonce</code></li><li>根据实施方案<code>承诺=H(msg || nonce)</code>生成一个承诺</li><li>没有人能根据最后的哈希值算出<code>msg</code>的值（隐蔽性）</li><li>最后如果我想公布这个<code>msg</code>，那么同时我们也公布随机数<code>nonce</code></li><li>所有人都可以将<code>msg</code>和<code>nonce</code>进行哈希验证，判断<code>msg</code>的值是否为我之前承诺的<code>msg</code></li></ol><h4 id="谜题友好"><a href="#谜题友好" class="headerlink" title="谜题友好"></a>谜题友好</h4><p>对于<code>H(nonce || x) ∈ Y</code>，如果我们以合适的随机方式产生<code>nonce</code>，那么想要求解那个公式是没有捷径的。</p><h4 id="安全哈希算法"><a href="#安全哈希算法" class="headerlink" title="安全哈希算法"></a>安全哈希算法</h4><p>我们将一个用于固定输入长度、具备碰撞阻力的哈希函数称为<code>压缩函数</code>，将一个固定长度输入的哈希函数转换成任意长度输入称为<code>MD变换</code>。</p><p><img src="\images\MD变换.jpg" alt="MD变换"><br>比如压缩函数的固定输入长度为768，产生256位输出，那么将输入分为<code>m-n</code>大小的区块，每</p><h2 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h2><p>####个区块和前一个区块的输出一起代入压缩函数<br> 区块链<br>我们使用<code>哈希指针</code>来构建区块链数据结构，<code>哈希指针</code>不仅指向上个区块的值的位置，还记录着上个区块的哈希值。所以能被防止篡改<br><img src="\images\区块链.jpg" alt="区块链"></p><h4 id="梅克尔树"><a href="#梅克尔树" class="headerlink" title="梅克尔树"></a>梅克尔树</h4><p>只要我们记住根节点，任何数据的篡改都会被检测到<br><img src="\images\梅克尔树.jpg" alt="梅克尔树"></p><h4 id="隶属证明"><a href="#隶属证明" class="headerlink" title="隶属证明"></a>隶属证明</h4><p><img src="\images\隶属证明.jpg" alt="隶属证明"></p><p>证明一个数据区块隶属于一个梅克尔树，验证花费·O(log(n))·</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书由3个算法构成：</p><ol><li>(privateKey,publicKey):=generateKey(nonce)</li><li>sig:=signature(privateKey,message)</li><li>isValid:=verify(publicKey,message,sig)</li></ol><p>对哈希后的信息进行签名，比如对区块链的链尾指针进行签名，那么等于签署了整条区块链。</p><h2 id="身份去中心化"><a href="#身份去中心化" class="headerlink" title="身份去中心化"></a>身份去中心化</h2><p>公钥就是我们的身份，有时公钥太长，那么我们可以以256位的公钥哈希作为身份。</p><h4 id="椭圆曲线数字签名算法"><a href="#椭圆曲线数字签名算法" class="headerlink" title="椭圆曲线数字签名算法"></a>椭圆曲线数字签名算法</h4><p>ECDSA是比特币使用的算法，注意不良随机可能导致密钥泄露。</p><h2 id="两种简单的加密货币"><a href="#两种简单的加密货币" class="headerlink" title="两种简单的加密货币"></a>两种简单的加密货币</h2><h4 id="高飞币"><a href="#高飞币" class="headerlink" title="高飞币"></a>高飞币</h4><p><img src="\images\高飞币.jpg" alt=""></p><ol><li>高飞生成唯一的随机ID，并建立字符串，然后使用私钥签名该字符串</li><li>高飞创建一个支付声明，并对其进行签名，这样爱丽丝就拥有这个币</li><li>爱丽丝创建一个支付声明，并对其进行签名，这样鲍勃就拥有这个币</li></ol><p><code>该币存在双重支付的问题和中心化的问题</code></p><h4 id="财奴币"><a href="#财奴币" class="headerlink" title="财奴币"></a>财奴币</h4><p>财奴币使用区块链结构，实现了仅增的功能，解决双重支付的问题。在链表的末尾财奴对哈希指针进行签名，保证区块链不被篡改。<br><img src="\images\财奴币.jpg" alt="财奴币"></p><p>财奴币中有两种交易：</p><ol><li>造币：跟高飞币一样，不过财奴币可以造多个币</li><li>付币：创建该交易的人会消耗币，并生成相同总值的新币，新币可能属于不同的人。付币交易必须进行签名，否则无效<br><code>该币还是存在中心化问题</code> </li></ol><h1 id="base58"><a href="#base58" class="headerlink" title="base58"></a>base58</h1><ul><li>base64是一种编码技术，不是加密技术。</li><li>将3个8位字节转换为4个6位的字节</li><li>如果剩下的字符不足3的倍数，用0填充，全0用字符“=”替换</li><li>可以使用base64对可执行文件进行编码，就不会有乱码了</li></ul><h3 id="base64编码表"><a href="#base64编码表" class="headerlink" title="base64编码表"></a>base64编码表</h3><table><thead><tr><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th><th>数值</th><th>字符</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>16</td><td>Q</td><td>32</td><td>g</td><td>48</td><td>w</td></tr><tr><td>1</td><td>B</td><td>17</td><td>R</td><td>33</td><td>h</td><td>49</td><td>x</td></tr><tr><td>2</td><td>C</td><td>18</td><td>S</td><td>34</td><td>i</td><td>50</td><td>y</td></tr><tr><td>3</td><td>D</td><td>19</td><td>T</td><td>35</td><td>j</td><td>51</td><td>z</td></tr><tr><td>4</td><td>E</td><td>20</td><td>U</td><td>36</td><td>k</td><td>52</td><td>0</td></tr><tr><td>5</td><td>F</td><td>21</td><td>V</td><td>37</td><td>l</td><td>53</td><td>1</td></tr><tr><td>6</td><td>G</td><td>22</td><td>W</td><td>38</td><td>m</td><td>54</td><td>2</td></tr><tr><td>7</td><td>H</td><td>23</td><td>X</td><td>39</td><td>n</td><td>55</td><td>3</td></tr><tr><td>8</td><td>I</td><td>24</td><td>Y</td><td>40</td><td>o</td><td>56</td><td>4</td></tr><tr><td>9</td><td>J</td><td>25</td><td>Z</td><td>41</td><td>p</td><td>57</td><td>5</td></tr><tr><td>10</td><td>K</td><td>26</td><td>a</td><td>42</td><td>q</td><td>58</td><td>6</td></tr><tr><td>11</td><td>L</td><td>27</td><td>b</td><td>43</td><td>r</td><td>59</td><td>7</td></tr><tr><td>12</td><td>M</td><td>28</td><td>c</td><td>44</td><td>s</td><td>60</td><td>8</td></tr><tr><td>13</td><td>N</td><td>29</td><td>d</td><td>45</td><td>t</td><td>61</td><td>9</td></tr><tr><td>14</td><td>O</td><td>30</td><td>e</td><td>46</td><td>u</td><td>62</td><td>+</td></tr><tr><td>15</td><td>P</td><td>31</td><td>f</td><td>47</td><td>v</td><td>63</td><td>/</td></tr></tbody></table><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><code>M</code>的ASCII码是：77，二进制是：01001101<br>那么取6位<code>010011</code>得到编码<code>T</code>，因为不足3个字节，所以进行补位，最终得到base64编码<code>T==</code></p><h3 id="比特币的地址使用base58编码，去掉了0-O-l-L"><a href="#比特币的地址使用base58编码，去掉了0-O-l-L" class="headerlink" title="比特币的地址使用base58编码，去掉了0,O,l,L"></a>比特币的地址使用base58编码，去掉了<code>0,O,l,L</code></h3><h1 id="比特币结构"><a href="#比特币结构" class="headerlink" title="比特币结构"></a>比特币结构</h1><p><img src="\images\区块结构.png" alt="区块结构"></p><h4 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h4><table><thead><tr><th>字节</th><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>区块大小</td><td></td></tr><tr><td>80</td><td>区块头</td><td></td></tr><tr><td>1-9</td><td>交易计数器</td><td>包含交易数量和币基交易</td></tr><tr><td>不定</td><td>交易</td></tr></tbody></table><h4 id="区块头"><a href="#区块头" class="headerlink" title="区块头"></a>区块头</h4><table><thead><tr><th>字节</th><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>版本号</td><td></td></tr><tr><td>32</td><td>前区块的哈希值</td><td></td></tr><tr><td>32</td><td>梅克尔树根</td><td></td></tr><tr><td>4</td><td>时间戳</td><td></td></tr><tr><td>4</td><td>难度目标</td><td>该区块pow难度</td></tr><tr><td>4</td><td>nonce</td><td>用于pow</td></tr></tbody></table><h4 id="区块体"><a href="#区块体" class="headerlink" title="区块体"></a>区块体</h4><pre><code>+ 币基交易：造币给矿工的奖励+ 普通交易</code></pre>]]></content>
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell script</title>
      <link href="/2018/08/28/shell-script/"/>
      <url>/2018/08/28/shell-script/</url>
      <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> function: 随机选择复习什么</span><br><span class="line"><span class="meta">#</span> version: </span><br><span class="line"><span class="meta">#</span> author: </span><br><span class="line"><span class="meta">#</span> history: 2018/8/28 21:30</span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">course[1]="Golang"</span><br><span class="line">course[2]="Linux"</span><br><span class="line">course[3]="MySQL"</span><br><span class="line">course[4]="计算机网络"</span><br><span class="line">course[5]="Docker"</span><br><span class="line">course[6]="分布式"</span><br><span class="line">course[7]="区块链"</span><br><span class="line">course[8]="Redis"</span><br><span class="line">course[9]="算法"</span><br><span class="line">courseNum=9</span><br><span class="line">courseChosed=0</span><br><span class="line">while [ "$&#123;courseChosed&#125;" -lt 3 ]</span><br><span class="line">do</span><br><span class="line">        mycheck=0</span><br><span class="line">        index=$(($&#123;RANDOM&#125; * $&#123;courseNum&#125; / 32768 + 1))</span><br><span class="line">        if [ "$&#123;courseChosed&#125;" -ge 1 ]; then</span><br><span class="line"><span class="meta">#</span>               for i in $(seq 1 $&#123;courseChosed&#125;)</span><br><span class="line">                for ((i=1;i&lt;=$&#123;courseChosed&#125;;i=i+1))</span><br><span class="line">                do</span><br><span class="line">                        if [ $&#123;courseArry[$i]&#125; == $&#123;index&#125; ]; then</span><br><span class="line">                                mycheck=1</span><br><span class="line">                        fi</span><br><span class="line">                done</span><br><span class="line">        fi</span><br><span class="line">        if [ $&#123;mycheck&#125; == 0 ];then</span><br><span class="line">                echo "I will review:$&#123;course[$&#123;index&#125;]&#125;"</span><br><span class="line">                courseChosed=$(($&#123;courseChosed&#125;+1))</span><br><span class="line">                courseArry[$&#123;courseChosed&#125;]=$&#123;index&#125;</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> script </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>test指令</title>
      <link href="/2018/08/28/test%E6%8C%87%E4%BB%A4/"/>
      <url>/2018/08/28/test%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="文件类型判断"><a href="#文件类型判断" class="headerlink" title="文件类型判断"></a>文件类型判断</h3><ul><li><code>-e</code>：该“文件名”是否存在？（常用）</li><li><code>-f</code>：该“文件名”是否存在且为文件（file）？（常用）</li><li><code>-d</code>：该“文件名”是否存在且为目录（directory）？（常用）</li><li><code>-b</code>：该“文件名”是否存在且为一个 block device 设备？</li><li><code>-c</code>：该“文件名”是否存在且为一个 character device 设备？</li><li><code>-S</code>：该“文件名”是否存在且为一个 Socket 文件？</li><li><code>-p</code>：该“文件名”是否存在且为一个 FIFO （pipe） 文件？</li><li><code>-L</code>：该“文件名”是否存在且为一个链接文件？</li></ul><h3 id="关于文件权限侦测"><a href="#关于文件权限侦测" class="headerlink" title="关于文件权限侦测"></a>关于文件权限侦测</h3><ul><li><code>-r</code>：侦测该文件名是否存在且具有“可读”的权限？</li><li><code>-w</code>：侦测该文件名是否存在且具有“可写”的权限？</li><li><code>-x</code>：侦测该文件名是否存在且具有“可执行”的权限？</li><li><code>-u</code>：侦测该文件名是否存在且具有“SUID”的属性？</li><li><code>-g</code>：侦测该文件名是否存在且具有“SGID”的属性？</li><li><code>-k</code>：侦测该文件名是否存在且具有“Sticky bit”的属性？</li><li><code>-s</code>：侦测该文件名是否存在且为“非空白文件”？</li></ul><h3 id="两个文件的比较"><a href="#两个文件的比较" class="headerlink" title="两个文件的比较"></a>两个文件的比较</h3><ul><li><code>-nt</code>：（newer than）判断 file1 是否比 file2 新</li><li><code>-ot</code>：（older than）判断 file1 是否比 file2 旧</li><li><code>-ef</code>：判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上。 主要意义在判定，两个文件是否均指向同一个 inode </li></ul><h3 id="比较两个整数：test-n1-eq-n2"><a href="#比较两个整数：test-n1-eq-n2" class="headerlink" title="比较两个整数：test n1 -eq n2"></a>比较两个整数：test n1 -eq n2</h3><ul><li><code>-eq</code>：两数值相等 （equal）</li><li><code>-ne</code>：两数值不等 （not equal）</li><li><code>-gt</code>：n1 大于 n2 （greater than）</li><li><code>-lt</code>：n1 小于 n2 （less than）</li><li><code>-ge</code>：n1 大于等于 n2 （greater than or equal）</li><li><code>-le</code>：n1 小于等于 n2 （less than or equal）</li></ul><h3 id="判定字符串"><a href="#判定字符串" class="headerlink" title="判定字符串"></a>判定字符串</h3><ul><li><code>test -z string</code>：判定字串是否为 0 ？若 string 为空字串，则为 true（常用）</li><li><code>test -n string</code>：判定字串是否不为 0 ？若 string 为空字串，则为 false</li><li><code>test str1 == str2</code>：判定 str1 是否等于 str2 ，若相等，则回传 true（常用）</li><li><code>test str1 != str2</code>：判定 str1 是否不等于 str2 ，若相等，则回传 false</li></ul><h3 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h3><ul><li><p><code>-a</code>：（and）两状况同时成立！<br>例如 test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true。</p></li><li><p><code>-o</code>：（or）两状况任何一个成立！<br>例如 test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true。</p></li><li><p><code>!</code>：反相状态，<br>例如 test ! -x file ，当 file 不具有 x 时，回传 true</p></li></ul>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 指令 </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bc计算指令</title>
      <link href="/2018/08/28/bc%E8%AE%A1%E7%AE%97%E6%8C%87%E4%BB%A4/"/>
      <url>/2018/08/28/bc%E8%AE%A1%E7%AE%97%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><ul><li><code>scale</code>：指定运算的小数点位数</li><li><code>ibase</code>：指定输入的进制数</li><li><code>obase</code>：制定输出的进制数</li><li><code>last或者.</code>：最近打印的数字</li></ul><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><ul><li><code>length</code>：得到变量的有效数字个数</li><li><code>read</code>：得到用户输入</li><li><code>scale</code>：得到变量小数点后的位数</li><li><code>sqrt</code>：开方运算</li></ul><h3 id="程序选项"><a href="#程序选项" class="headerlink" title="程序选项"></a>程序选项</h3><ul><li><code>-l</code>：提前加载数学库，将scale设为10</li><li><code>-q</code>：安静模式，不输出欢迎信息</li><li><code>-v</code>：版本信息</li><li><code>-s</code>：使用POSIX标准的bc语言，不是GNU扩展语言</li></ul><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul><li><code>s(x)</code>：sin函数</li><li><code>c(x)</code>：cos函数</li><li><code>a(x)</code>：atan函数，计算pi</li><li><code>l(x)</code>：ln函数</li><li><code>e(x)</code>：e的x次幂</li></ul><p>二进制转16进制<br>先指定16进制的输出，再指定2进制的输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bc</span><br><span class="line">obase=16</span><br><span class="line">ibase=2</span><br><span class="line">1010</span><br><span class="line">A</span><br></pre></td></tr></table></figure></p><p>使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# echo &quot;((11*31.5)+100)/3&quot; | bc -lq</span><br><span class="line">// 或者</span><br><span class="line">[root@study ~]# bc -lq &lt;&lt;&lt; &quot;((11*31.5)+100)/3&quot;</span><br></pre></td></tr></table></figure></p><p>计算pi，小数点后10000位，并显示计算时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time echo &quot;scale=10000;4*a(1)&quot; | bc -lq</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 指令 </tag>
            
            <tag> 计算 </tag>
            
            <tag> bc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bash</title>
      <link href="/2018/08/27/bash/"/>
      <url>/2018/08/27/bash/</url>
      <content type="html"><![CDATA[<h1 id="bash的操作环境"><a href="#bash的操作环境" class="headerlink" title="bash的操作环境"></a>bash的操作环境</h1><h3 id="login-shell和non-login-shell的概念"><a href="#login-shell和non-login-shell的概念" class="headerlink" title="login shell和non-login shell的概念"></a>login shell和non-login shell的概念</h3><ul><li>login：就是你取得bash时需要输入账号和密码</li><li>non-login：在当前bash状态下再启动一个bash是不要输密码的</li></ul><h3 id="login-shell配置文件读取"><a href="#login-shell配置文件读取" class="headerlink" title="login_shell配置文件读取"></a>login_shell配置文件读取</h3><p>login shell只会读这两个文件：<br>/etc/profile<br>~/.bash_profile或~/.bash_login或~/.profilea</p><p><img src="\images\login_shell配置文件读取.png" alt="login_shell配置文件读取"></p><h3 id="non-login-shell配置文件读取"><a href="#non-login-shell配置文件读取" class="headerlink" title="non-login shell配置文件读取"></a>non-login shell配置文件读取</h3><p><code>non-login shell</code>仅会读取<code>/.bashrc</code>这个文件夹</p><h3 id="etc-profile"><a href="#etc-profile" class="headerlink" title="/etc/profile"></a>/etc/profile</h3><ul><li>PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录</li><li>MAIL：依据帐号设置好使用者的 mailbox 到 /var/spool/mail/帐号名</li><li>USER：根据使用者的帐号设置此一变量内容</li><li>HOSTNAME：依据主机的 hostname 指令决定此一变量内容</li><li>HISTSIZE：历史命令记录笔数。CentOS 7.x 设置为 1000</li><li>umask：包括 root 默认为 022 而一般用户为 002</li><li>将<code>/etc/profile.d/*sh</code>文件全部调用尽来（规定了颜色，语系，别名…）</li><li><code>/etc/profile.d/lang.sh</code>会调用<code>/etc/locate.conf</code>来配置语系</li><li><code>/etc/profile.d/bash_completion.sh</code>会调用<code>/usr/share/bash-completion/completions/*</code>中相应的配置来处理补齐功能。</li></ul><h3 id="bash-profile"><a href="#bash-profile" class="headerlink" title="~/.bash_profile"></a>~/.bash_profile</h3><p>这是个人配置文件，当<code>.bash_profile</code>文件存在时，不会读取后两个文件的。<br><code>.bash_profile</code>会读取<code>.bashrc</code>文件的内容，所以最好将个人偏好写入<code>.bashrc</code>。</p><h3 id="source：将环境配置文件读入当前shell"><a href="#source：将环境配置文件读入当前shell" class="headerlink" title="source：将环境配置文件读入当前shell"></a>source：将环境配置文件读入当前shell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a>~/.bashrc</h3><p><code>.bashrc</code>会主动调用<code>/etc/bashrc</code>，（1）根据不同UID来规范umask的值；（2）根据不同的UID来规范提示字符(PS1)。所以如果你这个文件删掉了，那么提示字符就会变的很奇怪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/skel/.bashrc &gt; /root/.bashrc</span><br><span class="line">$ sourc .bashrc</span><br></pre></td></tr></table></figure></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h3 id="查看所有变量"><a href="#查看所有变量" class="headerlink" title="查看所有变量"></a>查看所有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ set</span><br></pre></td></tr></table></figure><p><span style="border-bottom:2px solid blue">PS1变量解析</span>：</p><ul><li>\d ：可显示出“星期 月 日”的日期格式，如：”Mon Feb 2”</li><li>\H ：完整的主机名称</li><li>\h ：仅取主机名称在第一个小数点之前的名字</li><li>\t ：显示时间，为 24 小时格式的“HH:MM:SS”</li><li>\T ：显示时间，为 12 小时格式的“HH:MM:SS”</li><li>\A ：显示时间，为 24 小时格式的“HH:MM”</li><li>\@ ：显示时间，为 12 小时格式的“am/pm”样式</li><li>\u ：目前使用者的帐号名称</li><li>\v ：BASH 的版本信息</li><li>\w ：完整的工作目录名称</li><li>\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。</li><li># ：下达的第几个指令。</li><li>\$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～</li></ul><h3 id="环境变量和自定义变量的概念"><a href="#环境变量和自定义变量的概念" class="headerlink" title="环境变量和自定义变量的概念"></a>环境变量和自定义变量的概念</h3><p>当前bash中的自定义变量不能在子程序bash中使用，除非使用<code>export</code>变成环境变量或者使用<code>declare</code>定义环境变量。<br><img src="\images\bash变量的继承.png" alt="bash"></p><h3 id="设置自定义变量"><a href="#设置自定义变量" class="headerlink" title="设置自定义变量"></a>设置自定义变量</h3><p>通过变量RANDOM得到0-9的随机数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ number=$(($&#123;RANDOM&#125;*10/32768))</span><br></pre></td></tr></table></figure></p><p>通过<code>declare</code>定义字符型变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ declare -x CNAME=&quot;gongshen&quot;</span><br></pre></td></tr></table></figure></p><h3 id="从键盘读入变量：read"><a href="#从键盘读入变量：read" class="headerlink" title="从键盘读入变量：read"></a>从键盘读入变量：read</h3><p><code>-p</code>是接提示字符，<code>-t</code>是接秒数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ read -p &quot;请输入你的名字：&quot; -t 30 named</span><br><span class="line">请输入你的名字:gongshen</span><br><span class="line">$ echo $&#123;named&#125;</span><br><span class="line">gongshen</span><br></pre></td></tr></table></figure></p><h3 id="设置环境变量：export"><a href="#设置环境变量：export" class="headerlink" title="设置环境变量：export"></a>设置环境变量：export</h3><p>更改系统语言变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export LC_ALL=zh_CN.utf8;export LANG=zh_CN.utf8</span><br><span class="line">$ locale</span><br></pre></td></tr></table></figure></p><h3 id="将环境变量变成自定义变量：declare"><a href="#将环境变量变成自定义变量：declare" class="headerlink" title="将环境变量变成自定义变量：declare"></a>将环境变量变成自定义变量：declare</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ declare +x 变量名</span><br></pre></td></tr></table></figure><h3 id="阵列变量类型"><a href="#阵列变量类型" class="headerlink" title="阵列变量类型"></a>阵列变量类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ var[1]=&quot;one&quot;</span><br><span class="line">$ var[2]=&quot;two&quot;</span><br><span class="line">$ var[3]=&quot;three&quot;</span><br></pre></td></tr></table></figure><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="${}:字符串长度"></a>${}:字符串长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ string=&quot;abcdefg&quot;</span><br><span class="line">$ echo $&#123;#string&#125;</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="变量内容的删除"><a href="#变量内容的删除" class="headerlink" title="${}:变量内容的删除"></a>${}:变量内容的删除</h3><p>删除第一个目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ path=$&#123;PATH&#125;;echo $&#123;path&#125;</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">$ echo $&#123;path#/*sbin:&#125;</span><br><span class="line">/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure></p><p>除最后一个目录之外全删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;path##/*bin:&#125;</span><br><span class="line">/root/bin</span><br></pre></td></tr></table></figure></p><p>删除最后一个目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;path%:/*&#125;</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin</span><br></pre></td></tr></table></figure></p><p>除了第一个目录其他全删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;path%%:/*&#125;</span><br><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure></p><h3 id="变量内容的替换"><a href="#变量内容的替换" class="headerlink" title="${}:变量内容的替换"></a>${}:变量内容的替换</h3><p>将string变量中的you替换成me（一次替换）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;string/you/me&#125;</span><br><span class="line">me and me with you</span><br></pre></td></tr></table></figure></p><p>将string变量中的you<code>全部</code>替换成me<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;string//you/me&#125;</span><br><span class="line">me and me with me</span><br></pre></td></tr></table></figure></p><h3 id="变量内容的判段"><a href="#变量内容的判段" class="headerlink" title="${}:变量内容的判段"></a>${}:变量内容的判段</h3><p>如果file变量没有被设定，那么就使用my.file.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;file:my.file.txt&#125;</span><br><span class="line">my.file.txt</span><br></pre></td></tr></table></figure></p><p>如果file变量没有被设定或为空，那么就使用my.file.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;file:-my.file.txt&#125;</span><br></pre></td></tr></table></figure></p><h3 id="脚本中的特殊变量"><a href="#脚本中的特殊变量" class="headerlink" title="脚本中的特殊变量"></a>脚本中的特殊变量</h3><ul><li>$#：执行脚本传入参数的个数</li><li>$*：执行脚本传入参数列表</li><li>$$：表示执行脚本进程号</li><li>$@：执行脚本传入的所有参数</li><li>$0：执行脚本名</li><li>$1：传入的第一个参数</li><li>$?：上个执行指令的回传值</li></ul><h1 id="数据流重导向"><a href="#数据流重导向" class="headerlink" title="数据流重导向"></a>数据流重导向</h1><p><img src="\images\linux数据传输情况.jpg" alt="指令执行过程数据传输情况"></p><h3 id="重导向概念"><a href="#重导向概念" class="headerlink" title="重导向概念"></a>重导向概念</h3><p>将正确输出和错误输出都<code>叠加</code>保存到list文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /home -name .bashrc 1&gt;&gt; list 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p><p>将错误输出丢弃<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /home -name .bashrc 2&gt; /dev/null</span><br></pre></td></tr></table></figure></p><p>将.bashrc文件作为输入，<code>覆盖</code>输出到list文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; list &lt; ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>用cat将键盘输入讯息<code>覆盖</code>重定向到list文件，并且输入流以字符eof结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; list &lt;&lt; &quot;eof&quot;</span><br><span class="line">&gt; This is a test.</span><br><span class="line">&gt; now stop the input!</span><br><span class="line">&gt; eof</span><br></pre></td></tr></table></figure></p><h3 id="一次输入多重指令"><a href="#一次输入多重指令" class="headerlink" title="一次输入多重指令"></a>一次输入多重指令</h3><p><span style="border-bottom:2px solid blue">;（不考虑指令相关性的连续指令下达）</span><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sync;sync;shutdown -h now</span><br></pre></td></tr></table></figure></p><p><span style="border-bottom:2px solid blue">&amp;&amp;和||</span><br>只有cmd1执行正确，就是$?=0，才执行cmd2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmd1 &amp;&amp; cmd2</span><br></pre></td></tr></table></figure></p><p>只有cmd1执行错误，就是$?≠0，才执行cmd2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmd1 || cmd2</span><br></pre></td></tr></table></figure></p><h1 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h1><p>要注意的是管道后接的指令必须能接收stand out的数据才行<br><img src="\images\管道命令处理.jpg" alt="管道命令处理"></p><h3 id="cut：撷取数据（用于对一行一行数据且排列整齐有优势）"><a href="#cut：撷取数据（用于对一行一行数据且排列整齐有优势）" class="headerlink" title="cut：撷取数据（用于对一行一行数据且排列整齐有优势）"></a>cut：撷取数据（用于对一行一行数据且排列整齐有优势）</h3><p>分析一些数据，将某些字符当作分隔符，切割数据，再获取需要的数据。<br>将PATH以:分割，取出第一块数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;PATH&#125;</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">$ echo $&#123;PATH&#125; | cut -d &apos;:&apos; -f 1</span><br><span class="line">/usr/local/sbin</span><br></pre></td></tr></table></figure></p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a><a href="https://www.llyltq.top/2018/08/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">grep</a></h3><p>这个grep命令是寻找匹配的数据。</p><h3 id="sort：可以对数据的某个部分进行排序"><a href="#sort：可以对数据的某个部分进行排序" class="headerlink" title="sort：可以对数据的某个部分进行排序"></a>sort：可以对数据的某个部分进行排序</h3><p>对passwd中的数据用 : 来分割的第 3 部分以数字进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -t &apos;:&apos; -k 3 -n</span><br></pre></td></tr></table></figure></p><h3 id="uniq：去掉重复的数据"><a href="#uniq：去掉重复的数据" class="headerlink" title="uniq：去掉重复的数据"></a>uniq：去掉重复的数据</h3><p>查看最新20条的登陆情况，以空格切割数据获取第一部分账号信息进行排序，消除重复的并且显示账号的数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ last -n 20 | cut -d &apos; &apos; -f1 | sort | uniq -c</span><br><span class="line">1 </span><br><span class="line">    11 gongshen</span><br><span class="line">    3 reboot</span><br><span class="line">    6 root</span><br><span class="line">    1 wtmp</span><br></pre></td></tr></table></figure></p><h3 id="wc：计算文件有多少行，多少字，多少字符"><a href="#wc：计算文件有多少行，多少字，多少字符" class="headerlink" title="wc：计算文件有多少行，多少字，多少字符"></a>wc：计算文件有多少行，多少字，多少字符</h3><p>计算有多少用户登陆系统（就是统计多少行）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ last | cut -d &apos; &apos; -f 1 | grep [a-zA-Z] | grep -v &apos;wtmp&apos; | grep -v &apos;reboot&apos; | grep -v &apos;unknown&apos; | sort | uniq -c | wc -l</span><br></pre></td></tr></table></figure></p><h3 id="tee：双重导向"><a href="#tee：双重导向" class="headerlink" title="tee：双重导向"></a>tee：双重导向</h3><p>可以将输入流导向文件和屏幕，用来保存需要的信息<br><img src="\images\tee工作流程.jpg" alt="tee工作流程"></p><p>home文件夹的信息既保存在文件list中，又输出在屏幕上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /home | tee -a list.txt | more</span><br></pre></td></tr></table></figure></p><h3 id="tr：用来删除一段文字或者文字替换"><a href="#tr：用来删除一段文字或者文字替换" class="headerlink" title="tr：用来删除一段文字或者文字替换"></a>tr：用来删除一段文字或者文字替换</h3><p>将所有小写变成大写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ last | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;</span><br></pre></td></tr></table></figure></p><p>删除passwd中所有的 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | tr -d &apos;:&apos;</span><br></pre></td></tr></table></figure></p><h3 id="col：将数据中的tab键转换成空格键"><a href="#col：将数据中的tab键转换成空格键" class="headerlink" title="col：将数据中的tab键转换成空格键"></a>col：将数据中的tab键转换成空格键</h3><p>数据中tab键是特殊符号：^I<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat -A /etc/man_db.conf | tr -x</span><br></pre></td></tr></table></figure></p><h3 id="join：处理两个相关数据文件时，将有相同数据那一行整合一起"><a href="#join：处理两个相关数据文件时，将有相同数据那一行整合一起" class="headerlink" title="join：处理两个相关数据文件时，将有相同数据那一行整合一起"></a>join：处理两个相关数据文件时，将有相同数据那一行整合一起</h3><p>将数据以 : 分割，比对第一个文件的第四个字段和第二个文件的第三个字段，默认都比对第一个字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ join -t &apos;:&apos; -1 4 /etc/passwd -2 3 /etc/group | head -n 3</span><br></pre></td></tr></table></figure></p><p>注意！在join之前，要将数据排序。</p><h3 id="paste：仅仅将数据贴在一起，以tab分隔"><a href="#paste：仅仅将数据贴在一起，以tab分隔" class="headerlink" title="paste：仅仅将数据贴在一起，以tab分隔"></a>paste：仅仅将数据贴在一起，以tab分隔</h3><p><code>-</code>代表了标准输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/group | paste /etc/passwd - | head -n 3</span><br></pre></td></tr></table></figure></p><h3 id="split：将大文件分为多个小文件"><a href="#split：将大文件分为多个小文件" class="headerlink" title="split：将大文件分为多个小文件"></a>split：将大文件分为多个小文件</h3><p>将文件以每个300k的大小分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ split -b 300k 文件1 file</span><br><span class="line">fileaa</span><br><span class="line">fileab</span><br><span class="line">fileac</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>合并上面的分区文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat file* &gt;&gt; 文件1</span><br></pre></td></tr></table></figure></p><p>将数据以每个文件10行来记录，因为没有指定文件，<code>-</code>表示标准输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l / | split -l 10 - lsroot</span><br><span class="line">lsrootaa</span><br><span class="line">lsrootab</span><br><span class="line">lsrootac</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="xargs：参数代换"><a href="#xargs：参数代换" class="headerlink" title="xargs：参数代换"></a>xargs：参数代换</h3><p>很多指令是不支持管道的，因为他们只能一次接收一个参数。</p><p>xargs从标准输入中每次只读1个数据来传给id执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -d &apos;:&apos; -f1 /etc/passwd | xargs -n 1 id</span><br></pre></td></tr></table></figure></p><p>如果xargs遇到标准输入中的’sync’时，就结束执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -d &apos;:&apos; -f1 /etc/passwd | xargs -e&apos;sync&apos; -n 1 id</span><br></pre></td></tr></table></figure></p><h3 id="减号（-）的用途"><a href="#减号（-）的用途" class="headerlink" title="减号（-）的用途"></a>减号（-）的用途</h3><p>前面的‘-’表示标准输出，后面的‘-’表示标准输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf - /home | tar -xvf - -C /tmp/homeback</span><br></pre></td></tr></table></figure></p><h1 id="shell-script知识"><a href="#shell-script知识" class="headerlink" title="shell script知识"></a>shell script知识</h1><h3 id="万用字符（注意和正则的区别）"><a href="#万用字符（注意和正则的区别）" class="headerlink" title="万用字符（注意和正则的区别）"></a>万用字符（注意和正则的区别）</h3><ul><li><code>*</code>：代表0到无穷多个任意字符</li><li><code>?</code>：代码1个任意字符</li><li><code>[]</code>：[abc]表示abc中任意一个字符</li><li><code>[-]</code>：[0-9]代表0-9中任意一个字符</li><li><code>[^]</code>：[^abc]代表非abc的任意一个字符</li></ul><h3 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h3><p>双引号中仍然可以保存变量的内容<br>单引号中全是一般字符，没有特殊字符</p><h3 id="和"><a href="#和" class="headerlink" title="$()和$(())"></a>$()和$(())</h3><p><code>$()</code>等同于``，表示命令替换<br><code>$(())</code>等同于<code>$[]</code>，其中可以进行数学运算</p><h3 id="expr用法"><a href="#expr用法" class="headerlink" title="expr用法"></a>expr用法</h3><p>进行数学运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expr 10 / 2</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><p>求字符串的长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ string=&quot;you and me with you&quot;</span><br><span class="line">$ expr length &quot;$&#123;string&#125;&quot;</span><br><span class="line">19</span><br></pre></td></tr></table></figure></p><p>求字符在字符串中的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expr index &quot;$&#123;string&#125;&quot; me</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><p>从第10个字符开始取出5个字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expr substr &quot;$&#123;string&#125;&quot; 10 5</span><br><span class="line">e wit</span><br></pre></td></tr></table></figure></p><h3 id="sh命令"><a href="#sh命令" class="headerlink" title="sh命令"></a>sh命令</h3><p>执行后面的一串指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u gonshen sh -c &quot;mkdir ~gongshen/www;cd ~gongshen/www;\</span><br><span class="line">&gt; echo &apos;This is a index file&apos; &gt; index.html&quot;</span><br></pre></td></tr></table></figure></p><p>进行逐条语句追踪（debug）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh -x shell.sh</span><br></pre></td></tr></table></figure></p><p>查询脚本语法是否有问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh -n shell.sh</span><br></pre></td></tr></table></figure></p><h3 id="使用date创建文件"><a href="#使用date创建文件" class="headerlink" title="使用date创建文件"></a>使用date创建文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ date=$(date --date=&apos;2 days age&apos; +%Y%m%d)</span><br><span class="line">$ username=$&#123;filename:-&quot;default_name&quot;&#125;</span><br><span class="line">$ file=$&#123;username&#125;$&#123;date&#125;</span><br></pre></td></tr></table></figure><h3 id="bc：计算器"><a href="#bc：计算器" class="headerlink" title="bc：计算器"></a><a href="https://www.llyltq.top/2018/08/28/bc%E8%AE%A1%E7%AE%97%E6%8C%87%E4%BB%A4/">bc：计算器</a></h3><p>在bash中不能进行小数点的运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;13.333%2&quot; | bc</span><br><span class="line">1.333</span><br></pre></td></tr></table></figure></p><h3 id="test：测试功能"><a href="#test：测试功能" class="headerlink" title="test：测试功能"></a><a href="https://www.llyltq.top/2018/08/28/test%E6%8C%87%E4%BB%A4/">test：测试功能</a></h3><p>测试输入的变量是否为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ test -z $&#123;filename&#125; &amp;&amp; echo &quot;你必须输入一个文件名！&quot;</span><br></pre></td></tr></table></figure></p><h3 id="：判断符号（其实就是test指令）"><a href="#：判断符号（其实就是test指令）" class="headerlink" title="[]：判断符号（其实就是test指令）"></a>[]：判断符号（其实就是test指令）</h3><p>判断变量是否为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ [ -z &quot;$&#123;home&#125;&quot; ] &amp;&amp; echo &quot;变量是空的&quot; || echo &quot;变量非空&quot;</span><br></pre></td></tr></table></figure></p><p>判断变量是否为 “Y” 或者 “y”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ [ &quot;$&#123;val1&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;val1&#125;&quot; == &quot;y&quot; ]</span><br></pre></td></tr></table></figure></p><p>判断变量是否小于0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ [ &quot;$&#123;num&#125;&quot; -lt &quot;0&quot; ]</span><br></pre></td></tr></table></figure></p><h3 id="参数偏移功能"><a href="#参数偏移功能" class="headerlink" title="参数偏移功能"></a>参数偏移功能</h3><p>如果我们的参数是“one two three”，那么进行一次偏移后参数就是“two three”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift 1</span><br></pre></td></tr></table></figure></p><h3 id="条件判断式"><a href="#条件判断式" class="headerlink" title="条件判断式"></a>条件判断式</h3><p>如果变量等于“Y”或者“y”，<code>&amp;&amp;</code>：表示and<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$&#123;val&#125;&quot; == &quot;Y&quot; ] || [ &quot;$&#123;val&#125;&quot; == &quot;y&quot; ];then</span><br><span class="line">...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>多重条件判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断1 ];then</span><br><span class="line">当条件判断1成立时执行</span><br><span class="line">elif [ 条件判断2 ];then</span><br><span class="line">当条件判断2成立时执行</span><br><span class="line">else</span><br><span class="line">当条件判断1和2都不满足时执行</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h3 id="使用-case"><a href="#使用-case" class="headerlink" title="使用 case"></a>使用 case</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case $&#123;val&#125; in</span><br><span class="line">&quot;a&quot;)</span><br><span class="line">echo &quot;变量为a&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;b&quot;)</span><br><span class="line">echo &quot;变量为b&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;变量未知，不是a和b&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h3 id="使用-function"><a href="#使用-function" class="headerlink" title="使用 function"></a>使用 function</h3><p>使用函数来减少重复的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function func1()&#123;</span><br><span class="line">echo -n &quot;这是函数，随时可以调用哟！&quot;</span><br><span class="line">&#125;</span><br><span class="line">case $&#123;1&#125; in</span><br><span class="line">&quot;a&quot;)</span><br><span class="line">func1;echo &quot;第一个参数是a&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;b&quot;)</span><br><span class="line">func1;echo &quot;第一个参数是b&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">func1;echo &quot;第一个参数未知&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>函数也有<code>${0}</code>和<code>${1}</code>，表示函数名，函数的第一个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func1 one two three</span><br><span class="line">//函数名是$&#123;0&#125;，one表示$&#123;1&#125;，two表示$&#123;2&#125;</span><br></pre></td></tr></table></figure></p><h3 id="loop：循环"><a href="#loop：循环" class="headerlink" title="loop：循环"></a>loop：循环</h3><p>当条件成立时，循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件 ]</span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>当条件不成立时，停止循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ 条件 ]</span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h3 id="for：固定循环"><a href="#for：固定循环" class="headerlink" title="for：固定循环"></a>for：固定循环</h3><p>执行3次循环，变量的值遍历 a b c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for val in a b c</span><br><span class="line">do </span><br><span class="line">...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p><code>$(seq 1 100)</code>表示1到100连续的数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for num in $(seq 1 100)</span><br><span class="line">do </span><br><span class="line">echo &quot;the number is:$&#123;num&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h3 id="for：数值处理"><a href="#for：数值处理" class="headerlink" title="for：数值处理"></a>for：数值处理</h3><p>这不就是编程中的for嘛，嗯~ o(<em>￣▽￣</em>)o<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ((i=1;i&lt;=10;i=i+1))</span><br><span class="line">do</span><br><span class="line">echo &quot;the number is:$&#123;i&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h3 id="阵列与乱数的搭配"><a href="#阵列与乱数的搭配" class="headerlink" title="阵列与乱数的搭配"></a>阵列与乱数的搭配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val[1]=&quot;A&quot;</span><br><span class="line">val[2]=&quot;B&quot;</span><br><span class="line">...</span><br><span class="line">val[9]=&quot;Z&quot;</span><br><span class="line">index=$(($&#123;RANDOM&#125;*9/32768 + 1))</span><br><span class="line">echo &quot;$&#123;val[$&#123;index&#125;]&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="执行脚本的方式"><a href="#执行脚本的方式" class="headerlink" title="执行脚本的方式"></a>执行脚本的方式</h3><p>如果使用<code>sh script</code>，那么就重新创建一个子bash来执行脚本，也就是说脚本产生的变量不会传到父进程中。<br>如果使用<code>source script</code>执行脚本，那么就等于在父进程中执行。</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 变量 </tag>
            
            <tag> bash </tag>
            
            <tag> script </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux文件与目录</title>
      <link href="/2018/08/26/linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
      <url>/2018/08/26/linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h1><h3 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27832 Jun 10  2018 /usr/bin/passwd</span><br></pre></td></tr></table></figure><ul><li>SUID权限仅对二进制程序有效</li><li>执行者需要具有对于该文件的<code>x</code>属性</li><li>SUID权限仅在执行该程序过程中有效</li><li>执行者具有该程序拥有者的权限支持</li></ul><h3 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /usr/bin/locate</span><br><span class="line">-rwx--s--x. 1 root slocate 40496 Jun 10  2018 /usr/bin/locate</span><br></pre></td></tr></table></figure><p>当SGID权限作用于二进制程序时：</p><ul><li>执行者需要具备<code>x</code>权限</li><li>执行者在执行过程中具有了该程序群组的权限支持</li></ul><p>当SGID权限作用于目录时：</p><ul><li>当使用者对于目录具有<code>r</code>和<code>x</code>权限时，可以进入该目录</li><li>当使用者对于目录具有<code>w</code>权限时，创建的新文件或者新目录的群组就是具有SGID权限的群组</li></ul><h3 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ll -d /tmp</span><br><span class="line">drwxrwxrwt. 10 root root 4096 Aug 26 01:23 /tmp</span><br></pre></td></tr></table></figure><ul><li>SBIT权限仅对目录有效</li><li>当使用者具有<code>w</code>和<code>x</code>权限时，创建新文件或新目录时，只有自己和root才能删除</li></ul>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 文件 </tag>
            
            <tag> 目录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux指令</title>
      <link href="/2018/08/25/Linux%E6%8C%87%E4%BB%A4%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
      <url>/2018/08/25/Linux%E6%8C%87%E4%BB%A4%E5%A4%A7%E7%A4%BC%E5%8C%85/</url>
      <content type="html"><![CDATA[<hr><h3 id="撷取命令"><a href="#撷取命令" class="headerlink" title="撷取命令"></a>撷取命令</h3><ul><li>cut：以特定的符号分割数据，并取出需要的区块</li><li>grep：根据正则表达式显示符合要求的数据</li><li>sed：可以分析标准输入，将数据取代、删除、新增等操作</li><li>awk：对处理进行处理</li></ul><h3 id="格式化命令"><a href="#格式化命令" class="headerlink" title="格式化命令"></a>格式化命令</h3><ul><li>printf：格式化输出数据</li></ul><h3 id="分区命令"><a href="#分区命令" class="headerlink" title="分区命令"></a>分区命令</h3><ul><li>split：可以将一个大文件分为多个小文件</li></ul><h3 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h3><ul><li>sort：对数据进行排序</li><li>uniq：可以消除重复的数据</li><li>wc：计算文件的行、字数、字符数</li></ul><h3 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h3><ul><li>tr：删除数据中的文字或者进行替换</li><li>col：将数据中的tab键特殊字符转换为空格</li><li>join：将存在相同数据那一行整合在一起</li><li>paste：仅仅将两个数据贴在一起</li></ul><h3 id="参数代换"><a href="#参数代换" class="headerlink" title="参数代换"></a>参数代换</h3><ul><li>xargs：使得一些指令能引用标准输入</li></ul><h3 id="双重导向"><a href="#双重导向" class="headerlink" title="双重导向"></a>双重导向</h3><ul><li>tee：可以将标准输入既输入到文件中又到标准输入中</li></ul><h3 id="文件比对工具"><a href="#文件比对工具" class="headerlink" title="文件比对工具"></a>文件比对工具</h3><ul><li>diff：比较文件或目录的差异</li><li>patch：依据补丁文件进行还原或更新数据</li></ul><h3 id="时间指令"><a href="#时间指令" class="headerlink" title="时间指令"></a>时间指令</h3><ul><li>date：显示时间</li></ul><h3 id="数据测试指令"><a href="#数据测试指令" class="headerlink" title="数据测试指令"></a>数据测试指令</h3><ul><li>test：用来判断文件的类型，权限，比较整数，判断是否为0等</li></ul><hr><h3 id="变量的操作"><a href="#变量的操作" class="headerlink" title="变量的操作"></a>变量的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var[1]#定义阵列变量</span><br><span class="line">$&#123;#string&#125;#求变量string长度</span><br><span class="line">$&#123;string/a/b&#125;#a替换b，一次</span><br><span class="line">$&#123;string//a/b&#125;#a替换b，全部</span><br><span class="line">$&#123;string#/*bin:&#125;#将左边匹配到“/*bin:”的最短字符删除</span><br><span class="line">$&#123;string##/*bin:&#125;#将左边匹配到“/*bin:”的最长字符删除</span><br><span class="line">$&#123;string%/*bin:&#125;#将右边匹配到“/*bin:”的最短字符删除</span><br><span class="line">$&#123;string%%/*bin:&#125;#将右边匹配到“/*bin:”的最长字符删除</span><br><span class="line">$&#123;string-string2&#125;#变量未设定就输出string2</span><br><span class="line">$&#123;string:-sring2&#125;#变量为空或未设定输出string2</span><br></pre></td></tr></table></figure><h3 id="关于变量的指令"><a href="#关于变量的指令" class="headerlink" title="关于变量的指令"></a>关于变量的指令</h3><ul><li><code>env</code>：显示环境变量</li><li><code>unset</code>：取消变量</li><li><code>export</code>：设置环境变量</li><li><code>declare +x</code>：环境变量转换为自定义变量</li><li><code>locale</code>：显示所有语言变量</li></ul><hr><p>创建一个全0的110M的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/zero of=file bs=1M count=110</span><br></pre></td></tr></table></figure></p><hr><p>创建账户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ useradd -u UID -g 初始群组 -G 次要群组 -d 主文件夹 -s Shell 账号名</span><br></pre></td></tr></table></figure></p><p>查询用户的群组和查看有效群组（输出的第一个群组）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ groups</span><br><span class="line">group1 group2 group3</span><br></pre></td></tr></table></figure></p><p>创建密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;密码&quot; | passwd --stdin 账号名</span><br><span class="line">$ echo &quot;用户名:密码&quot; | chpasswd</span><br></pre></td></tr></table></figure></p><p>显示密码相关参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chage -l 账号名</span><br></pre></td></tr></table></figure></p><p>修改账号参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ usermod -u UID -aG 次要群组</span><br></pre></td></tr></table></figure></p><p>切换有效群组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ newgrp</span><br><span class="line">$ exit</span><br></pre></td></tr></table></figure></p><p>改变文件的使用者和群组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chown -R 账号名:群组名 目录</span><br></pre></td></tr></table></figure></p><p>查询<code>/etc/shadow</code>中密码是用什么加密的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ authconfig --test | grep hashing</span><br></pre></td></tr></table></figure></p><p>设置文件或目录的ACL权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setfacl -m u:使用者:权限 文件或目录名</span><br></pre></td></tr></table></figure></p><p>切换身份运行指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u ssh touch 文件</span><br><span class="line">$ sudo -u ssh sh -c &quot;mkdir ~gongshen/www;cd ~gongshen/www;\</span><br><span class="line">&gt; echo &apos;This is index file!&apos; &gt; index.html&quot;</span><br></pre></td></tr></table></figure></p><p>设置<code>/etc/sudoers</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%群组名 ALL= (ALL)   ALL</span><br></pre></td></tr></table></figure></p><hr><ul><li>expr：进行简单的数学运算</li><li>bc：计算器</li></ul>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 指令 </tag>
            
            <tag> 账号 </tag>
            
            <tag> 群组 </tag>
            
            <tag> 数据处理 </tag>
            
            <tag> 变量 </tag>
            
            <tag> 文件 </tag>
            
            <tag> 目录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux账号管理与ACL设置</title>
      <link href="/2018/08/25/linux%E8%B4%A6%E5%8F%B7%E5%92%8C%E7%BE%A4%E7%BB%84/"/>
      <url>/2018/08/25/linux%E8%B4%A6%E5%8F%B7%E5%92%8C%E7%BE%A4%E7%BB%84/</url>
      <content type="html"><![CDATA[<h1 id="账号与群组"><a href="#账号与群组" class="headerlink" title="账号与群组"></a>账号与群组</h1><p>在Linux中，每个使用者至少会有两个ID：（1）使用者ID，（2）群组ID<br>要显示文件属性时，会从<code>/etc/passwd</code>和<code>/etc/group</code>中找到记录的UID和GID对应的账号名和群组名。</p><p>用户从tty1~tty6的终端机提供的login接口登陆系统：</p><ol><li>查看<code>/etc/passwd</code>中是否存在你输入的账号</li><li>读出<code>/etc/passwd</code>中账号对应的UID和GID，和主文件夹记录的UID比较</li><li>查看你输入的密码与<code>/etc/shadow</code>中对应的是否相符</li><li>进入Shell控管</li></ol><h3 id="etc-shadow文件"><a href="#etc-shadow文件" class="headerlink" title="/etc/shadow文件"></a>/etc/shadow文件</h3><p>第二个字段是经过加密的密码，在字段前加上<code>!</code>或者<code>*</code>，可以让密码暂时失效。<br>第三个字段是密码最近被更动的日期，日期从<code>1970年1月1日</code>算起。<br>第四个字段是密码不可被更动日期，就是更改密码后几天之内不能再次更改。<br>第五个字段是密码需要重新变更的天数，就是说密码有个期限，显示99999表示没有期限。<br>第六个字段是密码需要变更到期前的警告天数，就是密码到期前几天警告用户改密码。<br>第七个字段是密码过期后宽限日，就是密码到期后，还能用多少天，然后再不改密码，就失效了，再也不能用这个密码登陆了。<br>第八个字段是密码失效日，就是在这个时间后，密码不能再使用。</p><hr><p>查询<code>/etc/shadow</code>中密码是用什么加密的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ authconfig --test | grep hashing</span><br></pre></td></tr></table></figure></p><h3 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a>/etc/group文件</h3><p>第二个字段是群组的密码，密码也被放到了<code>/etc/gshadow</code>中密码<br>第四个字段是加入群组的账号名称，<code>root:x:0:account1,account2</code></p><h3 id="etc-gshadow文件"><a href="#etc-gshadow文件" class="headerlink" title="/etc/gshadow文件"></a>/etc/gshadow文件</h3><p>第二个字段是加密过的群组密码，如果为<code>空</code>或者<code>!</code>，说明该群组没有设置群组管理员。群组管理员可以代替root让用户加入自己的群组。</p><h3 id="初始群组："><a href="#初始群组：" class="headerlink" title="初始群组："></a>初始群组：</h3><p>就是<code>passwd</code>中的第四个字段，用户一登陆就拥有群组相关权限</p><h3 id="次要群组："><a href="#次要群组：" class="headerlink" title="次要群组："></a>次要群组：</h3><p>比如使用<code>usermod -aG users gongshen</code>或者修改<code>group</code>中users群组的第四个字段。那么用户的次要群组就有：<strong>users</strong>和<strong>gongshen</strong></p><h3 id="有效群组："><a href="#有效群组：" class="headerlink" title="有效群组："></a>有效群组：</h3><p>当你去创建一个新的文件或者目录时，新文件的群组是有效群组。<br>使用<code>groups</code>命令输出群组，并且第一个是<code>有效群组</code>。</p><h3 id="newgrp：切换有效群组"><a href="#newgrp：切换有效群组" class="headerlink" title="newgrp：切换有效群组"></a>newgrp：切换有效群组</h3><p><code>newgrp</code>指令是让使用者以另一个shell登陆的，最后不需要时，使用<code>exit</code>退出。<br><img src="\images\newgrp.png" alt="newgrp"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ newgrp users</span><br><span class="line">$ exit</span><br></pre></td></tr></table></figure></p><h3 id="gpasswd：群组管理员功能"><a href="#gpasswd：群组管理员功能" class="headerlink" title="gpasswd：群组管理员功能"></a>gpasswd：群组管理员功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># gpassword 群组名   &lt;=root设置群组密码</span><br><span class="line"># gpassword -A 账号名 群组名&lt;=root设置该群组的群组管理员</span><br><span class="line">$ gpassword -a 账号名 群组名 &lt;=群组管理员将账户加入该群组</span><br></pre></td></tr></table></figure><h3 id="groupadd、groupmod、groupdel"><a href="#groupadd、groupmod、groupdel" class="headerlink" title="groupadd、groupmod、groupdel"></a>groupadd、groupmod、groupdel</h3><h3 id="useradd：添加用户"><a href="#useradd：添加用户" class="headerlink" title="useradd：添加用户"></a>useradd：添加用户</h3><p>使用<code>useradd</code>时，默认配置是参考<code>/etc/default/useradd</code>和<code>/etc/login.defs</code>文件的。<br>创建系统账号时默认不创建主文件夹，而且UID和GID都在1000之下。</p><h3 id="chage：直观的密码参数显示指令"><a href="#chage：直观的密码参数显示指令" class="headerlink" title="chage：直观的密码参数显示指令"></a>chage：直观的密码参数显示指令</h3><p><code>chage</code>指令会以日期显示出<code>shadow</code>文件中那些字段。</p><h1 id="ACL：访问控制列表"><a href="#ACL：访问控制列表" class="headerlink" title="ACL：访问控制列表"></a>ACL：访问控制列表</h1><blockquote><p>ACL可以针对单一的使用者，单一的文件和单一的目录进行权限设置。</p></blockquote><p>针对使用者user1，对文件具有rx权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setfacl -m u:user1:rx 文件名或目录名</span><br></pre></td></tr></table></figure></p><p>针对群组group1，对文件具有rx权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setfacl -m g:group1:rx 文件名或目录名</span><br></pre></td></tr></table></figure></p><p>对文件设置mask权限（有效权限）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setfacl -m m:rx 文件名或目录名</span><br></pre></td></tr></table></figure></p><p>设置目录未来文件的ACL继承权限（默认权限）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setfacl -m d:u:user1:rx 目录名</span><br></pre></td></tr></table></figure></p><p>设置使用者权限为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setfacl -m u:user1:- 文件名或目录名</span><br></pre></td></tr></table></figure></p><p>设置文件拥有着权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setfacl -m u::rwx 文件名或目录名</span><br></pre></td></tr></table></figure></p><p>删除ACL权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setfacl -x u:user1 file1&lt;=删除特定的权限</span><br><span class="line">$ setfacl -b file1&lt;=删除全部ACL设置</span><br></pre></td></tr></table></figure></p><p>查看文件权限信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ getfacl 文件名或目录名</span><br></pre></td></tr></table></figure></p><h1 id="使用者身份切换"><a href="#使用者身份切换" class="headerlink" title="使用者身份切换"></a>使用者身份切换</h1><p>因为<code>sshd</code>的shell是<code>/sbin/nologin</code>，所以我们无法登陆。<br>使用<code>sudo</code>以其他使用者身份执行一串指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -u ssh touch 文件</span><br><span class="line">$ sudo -u ssh sh -c &quot;mkdir ~gongshen/www;cd ~gongshen/www;\</span><br><span class="line">&gt; echo &apos;This is index file&apos; &gt; index.html&quot;</span><br></pre></td></tr></table></figure></p><h3 id="配置-etc-sudoers"><a href="#配置-etc-sudoers" class="headerlink" title="配置/etc/sudoers"></a>配置<code>/etc/sudoers</code></h3><blockquote><p>使用者必须具有<code>sudo</code>使用权限，在<code>/etc/sudoers</code>文件中配置。</p></blockquote><p>单一使用者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用者帐号  登陆者的来源主机名称=（可切换的身份）  可下达的指令</span><br><span class="line">root                         ALL=（ALL）           ALL</span><br></pre></td></tr></table></figure></p><p>群组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%群组名 ALL= (ALL)   ALL</span><br></pre></td></tr></table></figure></p><p>使用者使用sudo时免密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%群组名 ALL= (ALL)  NOPASSWD: ALL</span><br></pre></td></tr></table></figure></p><p>限制用户只能以root身份修改其他用户密码，不能修改root密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudovi</span><br><span class="line">用户名ALL=(root) !/user/bin/passwd,/usr/bin/passwd [a-zA-Z]*,!/usr/bin/passwd root</span><br></pre></td></tr></table></figure></p><p>别名设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User_Alias ADMUSER = gongshen</span><br><span class="line">Cmnd_Alias ADMUSERCMD = ALL </span><br><span class="line">ADMUSER   ALL=(ALL)  ADMUSERCMD</span><br></pre></td></tr></table></figure></p><h1 id="nologin"><a href="#nologin" class="headerlink" title="nologin"></a>nologin</h1><p>对于有些账号我们是不能登陆取得互动式的shell，可以修改<code>/etc/nologin.txt</code>来显示登陆失败的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/nologin.txt</span><br><span class="line">这个账号是系统账号，请不要使用这个账号登陆系统！</span><br></pre></td></tr></table></figure></p><h1 id="PAM（嵌入式认证模块）"><a href="#PAM（嵌入式认证模块）" class="headerlink" title="PAM（嵌入式认证模块）"></a>PAM（嵌入式认证模块）</h1><p>PAM就是一个API，程序可以调用它，将验证需求告诉它，它返回验证结果。<br><img src="\images\pam.png" alt="pam"></p><h3 id="PAM模块设置"><a href="#PAM模块设置" class="headerlink" title="PAM模块设置"></a>PAM模块设置</h3><p>程序的PAM配置文件都在<code>/etc/pam.d/</code>中。</p><hr><p>如果存在<code>/etc/nologin</code>文件，那么一般使用者是无法登陆的。因为在<code>/etc/pam.d/login</code>登陆PAM配置文件中有一条：account  required  pam_nologin.so<br>对应的模块<code>pam_nologin.so</code>用法可以查阅<code>/usr/share/doc/pam-*/README.pam_nologin</code></p><hr><p>telnet为什么不能以root登陆系统呢？telnet会引用<code>login</code>这个PAM配置文件，其中有<code>pam_securetty.so</code>模块验证，只有写在<code>/etc/securetty</code>中的终端才能以root身份登陆。telnet使用的是远端连线pts/n。<br>ssh为什么能root登陆呢？因为ssh登陆的时候引用的是<code>/etc/pam.d/sshd</code>这个PAM配置文件，这个文件没有加入<code>securetty</code>验证。</p><h1 id="limits-conf：对用户和群组做其他限制"><a href="#limits-conf：对用户和群组做其他限制" class="headerlink" title="limits.conf：对用户和群组做其他限制"></a>limits.conf：对用户和群组做其他限制</h1><p>限制用户gongshen，创建的文件大小最大为100000K<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/security/limits.conf</span><br><span class="line">gongshen  hard  fsize  100000</span><br></pre></td></tr></table></figure></p><p>限制群组的最大连接数为1（只对初始群组有效）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/security/limits.conf</span><br><span class="line">@group1   hrad   maxlogins   1</span><br></pre></td></tr></table></figure></p><p>显示当前用户的限制情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ulimit -a</span><br></pre></td></tr></table></figure></p><h1 id="主机使用者传递讯息"><a href="#主机使用者传递讯息" class="headerlink" title="主机使用者传递讯息"></a>主机使用者传递讯息</h1><h3 id="查询使用者"><a href="#查询使用者" class="headerlink" title="查询使用者"></a>查询使用者</h3><p>查询当前使用者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ w</span><br></pre></td></tr></table></figure></p><p>查看用户的最后登陆时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lastlog</span><br></pre></td></tr></table></figure></p><h3 id="同步的发送讯息"><a href="#同步的发送讯息" class="headerlink" title="同步的发送讯息"></a>同步的发送讯息</h3><p>user1可以给user2使用的终端pts/2发送讯息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ write user2 pts/2</span><br></pre></td></tr></table></figure></p><p>root可以不接收任何同步讯息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mesg n</span><br></pre></td></tr></table></figure></p><p>广播发送讯息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wall &quot;I will shutdown the server...&quot;</span><br></pre></td></tr></table></figure></p><h3 id="异步的发送讯息"><a href="#异步的发送讯息" class="headerlink" title="异步的发送讯息"></a>异步的发送讯息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mail -s &quot;this is title&quot; user1</span><br><span class="line">This is the body of mail!</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 账号 </tag>
            
            <tag> 群组 </tag>
            
            <tag> ACL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker</title>
      <link href="/2018/08/25/docker/"/>
      <url>/2018/08/25/docker/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式</title>
      <link href="/2018/08/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/08/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="grep指令中使用基本正则表达式"><a href="#grep指令中使用基本正则表达式" class="headerlink" title="grep指令中使用基本正则表达式"></a>grep指令中使用基本正则表达式</h1><ul><li>^：行首</li><li>$：行尾</li><li>^$：空行</li><li>\&lt;：词首</li><li>>：词尾</li><li>\B：非单词边界</li><li>(hello)：表示hello这整个单词</li><li>m{n}：m连续出现n次</li><li>n*：n连续出现（包括0次）</li><li>.：单个字符</li><li>.*：任意字符</li><li>n\?：n出现0次或1次</li><li>n\ +：n至少出现1次</li><li>[abc]：abc中任意的单个字符</li><li>[^abc]：除了abc外的任意的单个字符</li><li>[[:alpha:]]：任意英文字母中的任意的单个字符</li><li>\1：表示整个正则中第1个分组的匹配结果，<code>分组的顺序取决于分组符号左侧部分的顺序</code></li><li>(?=)：表示后面匹配的字符串要符合这里的匹配</li></ul><hr><p>a连续出现2次，但是a连续出现2次以上也会被匹配到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n &quot;a\&#123;2\&#125;&quot; regex</span><br></pre></td></tr></table></figure></p><p>使用这种写法，精确匹配2次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n &quot;\&lt;a\&#123;2\&#125;\&gt;&quot; regex</span><br></pre></td></tr></table></figure></p><p>a连续出现2到3次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n &quot;\&lt;a\&#123;2,3\&#125;\&gt;&quot; regex</span><br></pre></td></tr></table></figure></p><p>a连续出现至多2次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n &quot;\&lt;a\&#123;,2\&#125;\&gt;&quot; regex</span><br></pre></td></tr></table></figure></p><p><code>*</code>跟通配符不同，表示*之前的字符连续出现（包括0次）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n &quot;e*f&quot; regex</span><br></pre></td></tr></table></figure></p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>符号    意义</p><ul><li>[:alnum:]    ：任何英文字母和数字</li><li>[:upper:]    ：大写字母</li><li>[:alpha:]    ：字母</li><li>[:lower:]    ：小写字母</li><li>[:cntrl:]    ：键盘上的控制按键</li><li>[:digit:]    ：0-9数字</li><li>[:graph:]    ：除了空白键和Tab外其他所有控制按键</li><li>[:blank:]    ：空白键或Tab</li><li>[:print:]    ：任何可以被打印出来的字符</li><li>[:punct:]    ：标点符号</li><li>[:space:]    ：任何产生空白的键</li><li>[:xdigit:]：代表16进制的数字类型</li></ul><p>简短格式：</p><ul><li>\d：0-9的数字</li><li>\D：非数字字符</li><li>\t：字表符，相当于tab</li><li>\s：空白字符（空格，tab）</li><li>\S：非空白字符</li><li>\w：单词字符（A-Za-z0-9）</li><li>\W：非单词字符</li></ul><hr><p>a后面跟连续的3个小写字母<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n &quot;a[[:lower:]]\&#123;3\&#125;&quot; regex</span><br></pre></td></tr></table></figure></p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>在world前后要相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//匹配 hello world hello</span><br><span class="line">grep -n &quot;\(hello\) world \1&quot; regex</span><br></pre></td></tr></table></figure></p><h1 id="grep指令中的扩展正则表达式"><a href="#grep指令中的扩展正则表达式" class="headerlink" title="grep指令中的扩展正则表达式"></a>grep指令中的扩展正则表达式</h1><ul><li>(ab)：表示ab是一个整体</li><li>n{2,3}：表示匹配2到3个连续的n</li><li>a|b：匹配a或者b</li><li>n?：n出现0次或者1次</li><li>n+：n至少出现1次</li><li>其他规则和基本正则一样</li></ul><hr><p>举例：<br>匹配合法邮箱地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E &quot;[a-z0-9]&#123;4,16&#125;@[a-z0-9]&#123;2,12&#125;\.(\&lt;(com|net|org|edu))$&quot;</span><br></pre></td></tr></table></figure></p><h1 id="正则表达式例子"><a href="#正则表达式例子" class="headerlink" title="正则表达式例子"></a>正则表达式例子</h1><p>匹配密码<br>至少8位，至少出现一个小写字母，一个大写字母，一个数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?=.*[0-9])(?=.*[A-Z])(?=.*[a-z])[\S\s]&#123;8,&#125;$</span><br></pre></td></tr></table></figure></p><p>\s\S：表示空字符和非空字符</p><p><img src="\images\正则图.png" alt="正则图"></p><h1 id="sed：对流中的文字进行撷取、替换等操作"><a href="#sed：对流中的文字进行撷取、替换等操作" class="headerlink" title="sed：对流中的文字进行撷取、替换等操作"></a>sed：对流中的文字进行撷取、替换等操作</h1><p>删除2到5行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat -n /etc/passwd | sed -e &apos;2,5d&apos;</span><br></pre></td></tr></table></figure></p><p>在第二行后新增数据drink tea，在第二行前新增数据就是<code>2i</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat -n /etc/passwd | sed &apos;2d drink tea&apos;</span><br></pre></td></tr></table></figure></p><p>在第二行后新增2行数据，需要使用<code>\</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat -n /etc/passwd | sed &apos;2d drink tea \</span><br><span class="line">&gt; the second line&apos;</span><br></pre></td></tr></table></figure></p><p>将2-5行内容取代为“the 2-5 data”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat -n /etc/passwd | sed &apos;2,5c the 2-5 data&apos;</span><br></pre></td></tr></table></figure></p><p>仅列出2-5行，需要与<code>n</code>一起用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat -n /etc/passwd | sed -n &apos;2,5p&apos;</span><br></pre></td></tr></table></figure></p><p><span style="border-bottom:2px solid blue">—搜索部分数据并取代—</span><br>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &apos;s/被取代的字串/新的字串/g&apos;</span><br></pre></td></tr></table></figure></p><p>仅显示 1.2.3.4 这个ip地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0 | grep &apos;inet&apos;</span><br><span class="line">        inet 1.2.3.4  netmask 255.255.192.0  broadcast 10.214.63.255</span><br><span class="line">$ ifconfig eth0 | grep &apos;inet&apos; | sed &apos;s/^ *inet //g&apos; | sed &apos;s/ *netmask.*$&apos; </span><br><span class="line">1.2.3.4</span><br></pre></td></tr></table></figure></p><p>将所有注释行删除，注意！使用<code>//d</code>代表对每行的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/man_db.conf | sed &apos;/#.*$/d&apos;</span><br></pre></td></tr></table></figure></p><p>将文件末尾如果是 “.” 就改为 “!”，<code>-i</code>表示直接修改文件内容，不是屏幕输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i &apos;s/\.$/\!/g&apos; 文件名</span><br></pre></td></tr></table></figure></p><p>当存在多个动作时，需要使用<code>-e</code>选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e &apos;3d&apos; -e &apos;s/\!$/\./g&apos; regular.txt</span><br></pre></td></tr></table></figure></p><p><span style="border-bottom:2px solid red"><code>a</code>和<code>//a</code>的区别</span><br><code>$a</code>表示对整个文件的末尾进行新增操作<br><code>/$/a</code>表示对每一行的末尾进行新增操作</p><h1 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h1><p><code>%10s</code>输出长度为10的字符型，<code>%5i</code>输出长度为5的整数型，<code>%8.2f</code>输出8个字符，小数点为2位的浮点型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat mark.txt</span><br><span class="line">Name     Chinese   English   Math    Average</span><br><span class="line">DmTsai        80        60     92      77.33</span><br><span class="line">GS           75        55     80      70.00</span><br><span class="line">Ken           60        90     70      73.33</span><br><span class="line"></span><br><span class="line">$ printf &apos;%10s %5i %5i %5i %8.2f \n&apos; $(cat mark.txt | grep -v &apos;Name&apos;)</span><br></pre></td></tr></table></figure></p><h1 id="awk：数据处理工具"><a href="#awk：数据处理工具" class="headerlink" title="awk：数据处理工具"></a>awk：数据处理工具</h1><h3 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h3><ul><li>$0：第一行的数据</li><li>$1：第一栏的数据（默认以空格或tab分割）</li><li>NR：目前处理的是第几行</li><li>NF：改行的字段数</li><li>FS：当前的分割符（默认以空格或tab）</li></ul><h3 id="awk使用"><a href="#awk使用" class="headerlink" title="awk使用"></a>awk使用</h3><p>取出登陆者和ip地址，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ last -n 5 | awk &apos;&#123;print $1 &quot;\t lines:&quot; NR &quot;\t numbers:&quot; NF &quot;\t IP:&quot; $3&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>预先设定以<code>:</code>分割数据，显示<code>UID&lt;10</code>的账户和UID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | awk &apos;BEGIN &#123;FS=&quot;:&quot;&#125; $3&lt;10 &#123;print &quot;user:&quot; $1 &quot;\t UID:&quot; $3&#125;&apos;</span><br></pre></td></tr></table></figure></p><hr><p>计算总额并且格式化输出，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat mark.txt</span><br><span class="line">Name    1st     2nd     3th</span><br><span class="line">GS      23000   24000   25000</span><br><span class="line">DMTsai  21000   20000   23000</span><br><span class="line">Bird2   43000   42000   41000</span><br><span class="line"></span><br><span class="line">$ cat mark.txt |\</span><br><span class="line">&gt; awk &apos;NR==1&#123;printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot;&#125;</span><br><span class="line">&gt; NR&gt;=2&#123;total=$2+$3+$4</span><br><span class="line">&gt; printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>上面的指令也可以变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat mark.txt | \</span><br><span class="line">&gt; awk &apos;&#123;if (NR==1) printf &quot;%10s %10s %10s %10s %10s\n&quot;,$1,$2,$3,$4,&quot;Total&quot;&#125; </span><br><span class="line">&gt; NR&gt;=2&#123;total=$2+$3+$4;printf &quot;%10s %10d %10d %10d %10.2f\n&quot;,$1,$2,$3,$4,total&#125;&apos;</span><br></pre></td></tr></table></figure></p><h1 id="文件比对工具"><a href="#文件比对工具" class="headerlink" title="文件比对工具"></a>文件比对工具</h1><h3 id="diff：比对文件差异"><a href="#diff：比对文件差异" class="headerlink" title="diff：比对文件差异"></a>diff：比对文件差异</h3><ul><li>-b：忽略一行中，仅有多个空白的差异（a b和a    b的差异）</li><li>-B：忽略空白行的差异</li><li>-i：忽略大小写的不同</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diff file.old file.new</span><br></pre></td></tr></table></figure><h3 id="patch：打补丁"><a href="#patch：打补丁" class="headerlink" title="patch：打补丁"></a>patch：打补丁</h3><p>使用<code>diff</code>比较并生成补丁文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diff -Nuar passwd.old passwd.new &gt; passwd.patch</span><br></pre></td></tr></table></figure></p><p>使用补丁文件更新旧的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ patch -p0 &lt; passwd.patch</span><br></pre></td></tr></table></figure></p><p>使用补丁文件还原旧的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ patch -R -p0 &lt; passwd.patch</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> grep </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git</title>
      <link href="/2018/08/24/Git/"/>
      <url>/2018/08/24/Git/</url>
      <content type="html"><![CDATA[<h1 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h1><h3 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h3><p><img src="\images\git工作流.png" alt="git工作流"><br>当新建一个仓库后，当前目录就是<code>工作区</code>，隐藏文件<code>.git</code>就是版本库<br>版本库有一个<code>stage</code>的暂存区，自动创建的<code>master分支</code>和指向当前分支的指针<code>HEAD</code></p><p><img src="\images\git指令操作1.png" alt="git指令"></p><ul><li><code>git add files</code>：将文件添加到暂存区</li><li><code>git commit</code>：将暂存区的修改提交到当前分支</li><li><code>git reset -- files</code>：用当前分支的修改覆盖暂存区，用来撤销最后一次<strong>git add</strong></li><li><code>git checkout -- files</code>：用暂存区的修改覆盖工作目录，来撤销本地修改</li></ul><p><img src="\images\git指令操作2.png" alt="git指令2"></p><ul><li><code>git commit -a</code>：直接将所有修改添加到暂存区并提交到当前分支</li><li><code>git checkout HEAD -- files</code>：取出最后一次修改，来覆盖工作目录，进行回滚操作</li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p><img src="\images\分支新建.png" alt="分支新建"><br>分支的新建很快，就是新建一个<code>dev</code>指针，将<code>HEAD</code>指针指向它，就是当前指针了。<br><img src="\images\分支提交.jpg" alt="分支提交"><br>分支的每次提交是当前分支向前移动。<br><img src="\images\分支合并.jpg" alt="分支合并"><br>分支的合并就是修改指针。<br><img src="\images\分支合并2.jpg" alt=""><br>“快进式合并”(fast-forward merge)会直接将master分支指向合并的分支，会丢失分支信息，所以禁用<code>Fast forward</code>模式，加上<code>-m</code>让合并时产生一次提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure></p><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>如果两个分支对同一行进行了修改，分支合并时就会冲突。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p><p>解决方法：</p><ol><li>将冲突部分修改的一样</li><li></li></ol><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p><img src="\images\分支管理策略.png" alt=""><br><code>master</code>：用来发布新版本<br><code>dev</code>：用来日常开发</p><h3 id="储藏（stashing）"><a href="#储藏（stashing）" class="headerlink" title="储藏（stashing）"></a>储藏（stashing）</h3><p>在一个分支上操作后，如果还没有将修改提交，那么切换分支后，另一支分支也能看到该修改。所以使用<code>git stash</code>将当前分支修改储藏在栈上，那么就不会显示任何修改，能安全切换分支。<br>该功能可以用于<strong>bug</strong>分支的实现。如果当前正在<strong>dev</strong> 分支上进行开发，但是此时<strong>master</strong>上有个bug需要修复，但是 <strong>dev</strong>分支上的开发还未完成，不想立即提交。在新建<strong>bug</strong>分支并切换到<strong>bug</strong>分支之前就需要将<strong>dev</strong>分支的未提交修改储藏起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git stash//存储当前dev工作现场</span><br><span class="line">$ git checkout master//回到master分支</span><br><span class="line">$ git checkout -b issue-101//创建issue-101分支</span><br><span class="line">$ git commit -m &quot;resolve the bug&quot;//修复bug</span><br><span class="line">$ git checkout master//回到master分支</span><br><span class="line">$ git branch -d issue-101//删除issue-101分支</span><br><span class="line">$ git checkout dev//回到dev分支</span><br><span class="line">$ git stash apply//从栈中恢复dev分支的修改</span><br></pre></td></tr></table></figure></p><h3 id="分支间追踪关系"><a href="#分支间追踪关系" class="headerlink" title="分支间追踪关系"></a>分支间追踪关系</h3><p>默认情况下，本地分支与远程分支会建立一种<code>追踪关系</code>。<br>比如在<strong>git clone</strong>时，本地分支与远程分支同名，本地的master分支默认追踪远程的master分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//手动建立分支追踪关系</span><br><span class="line">$ git branch --set-upstream master origin/next</span><br></pre></td></tr></table></figure></p><h1 id="2、常用指令"><a href="#2、常用指令" class="headerlink" title="2、常用指令"></a>2、常用指令</h1><p><span style="border-bottom:2px solid red">1. 查看分支历史信息</span><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev=commit</span><br></pre></td></tr></table></figure></p><h3 id="当远程主机更新，本地没有更新，那么会拒绝本地的提交，怎么办？"><a href="#当远程主机更新，本地没有更新，那么会拒绝本地的提交，怎么办？" class="headerlink" title="当远程主机更新，本地没有更新，那么会拒绝本地的提交，怎么办？"></a>当远程主机更新，本地没有更新，那么会拒绝本地的提交，怎么办？</h3><ul><li><p>取回远程主机的分支，与本地分支合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master:master</span><br></pre></td></tr></table></figure></li><li><p>上面的代码也就是下面两步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br><span class="line">$ git merge origin/master master</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>参考<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md" target="_blank" rel="noopener">Git</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内存泄露以及分析</title>
      <link href="/2018/08/23/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BB%A5%E5%8F%8A%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/23/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%BB%A5%E5%8F%8A%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h1><h3 id="Web程序"><a href="#Web程序" class="headerlink" title="Web程序"></a>Web程序</h3><p>如果本身是Web程序，那么本来就开启了端口，那么只要导入该工具就行了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"net/http/pprof</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure></p><p>然后通过<code>http://localhost:port/debug/pprof</code>访问</p><h3 id="服务进程"><a href="#服务进程" class="headerlink" title="服务进程"></a>服务进程</h3><p>如果是一个服务进程，那么我们还需要监听端口。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//goroutine处于发送和接受阻塞状态，但垃圾回收不会收集此资源。</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">_ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(http.ListenAndServe(<span class="string">"localhost:6060"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;()</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="comment">//runtime.GC()//强制垃圾回收</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go build -o test</span></span><br></pre></td></tr></table></figure></p><h3 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h3><p>这个时候需要用到<code>runtime/pprof</code>包，来生成<strong>pprof</strong>文件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"runtime/pprof"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">"cpuprofile"</span>,<span class="string">""</span>,<span class="string">"write cpu profile to file"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="keyword">if</span> *cpuprofile != <span class="string">""</span> &#123;</span><br><span class="line">        f, err := os.Create(*cpuprofile)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        pprof.StartCPUProfile(f)</span><br><span class="line">        <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>当消费者意外退出时，生产者阻塞在<code>ch&lt;-T{}</code>上，内存就会泄露。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> T)</span><br><span class="line"><span class="keyword">go</span> produce(ch) &#123;</span><br><span class="line">  <span class="comment">// 生产者往ch里写数据</span></span><br><span class="line">  ch &lt;- T&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> consume(ch) &#123;</span><br><span class="line">  <span class="comment">// 消费者从ch里读出数据</span></span><br><span class="line">  &lt;-ch</span><br><span class="line">  err := doSomeThing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解决方法：</p><ol><li>在发送端发送完关闭通道</li><li>使用一个关闭的channel来广播取消动作</li></ol><blockquote><p>转载于<a href="https://my.oschina.net/solate/blog/755094" target="_blank" rel="noopener">go pprof</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pprof </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读取文件的方式</title>
      <link href="/2018/08/23/%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/08/23/%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read1</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">fi, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> fi.Close()</span><br><span class="line"></span><br><span class="line">chunks := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>, <span class="number">1024</span>)</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := fi.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> == n &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">chunks = <span class="built_in">append</span>(chunks, buf[:n]...)</span><br><span class="line"><span class="comment">// fmt.Println(string(buf[:n]))</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(chunks)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read2</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">fi, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> fi.Close()</span><br><span class="line">r := bufio.NewReader(fi)</span><br><span class="line"></span><br><span class="line">chunks := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> == n &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">chunks = <span class="built_in">append</span>(chunks, buf[:n]...)</span><br><span class="line"><span class="comment">// fmt.Println(string(buf[:n]))</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(chunks)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read3</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">fi, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> fi.Close()</span><br><span class="line">fd, err := ioutil.ReadAll(fi)</span><br><span class="line"><span class="comment">// fmt.Println(string(fd))</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(fd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br><span class="line">file := flag.Arg(<span class="number">0</span>)</span><br><span class="line">f, err := ioutil.ReadFile(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, err)</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(f))</span><br><span class="line">start := time.Now()</span><br><span class="line">read1(file)</span><br><span class="line">t1 := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"Cost time %v\n"</span>, t1.Sub(start))</span><br><span class="line">read2(file)</span><br><span class="line">t2 := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"Cost time %v\n"</span>, t2.Sub(t1))</span><br><span class="line">read3(file)</span><br><span class="line">t3 := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">"Cost time %v\n"</span>, t3.Sub(t2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>map的妙用</title>
      <link href="/2018/08/20/map%E7%9A%84%E5%A6%99%E7%94%A8/"/>
      <url>/2018/08/20/map%E7%9A%84%E5%A6%99%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>使用<code>map</code>来避免生成<code>p</code>的重复<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; number; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">p, _ = newPair(randString(), randElement())</span><br><span class="line"><span class="keyword">if</span> _, ok := m[p.Key()]; !ok &#123;</span><br><span class="line">testCases[i] = p</span><br><span class="line">m[p.Key()] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单元测试</title>
      <link href="/2018/08/18/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/08/18/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="1-Test"><a href="#1-Test" class="headerlink" title="1.Test"></a>1.Test</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestA</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line">t.Parallel()</span><br><span class="line">time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestB</span><span class="params">(t *testing.T)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> os.Args[<span class="built_in">len</span>(os.Args)<span class="number">-1</span>]==<span class="string">"b"</span>&#123;</span><br><span class="line">t.Parallel()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通单元测试：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -v</span><br><span class="line">=== RUN   TestA</span><br><span class="line">=== RUN   TestB</span><br><span class="line">--- PASS: TestB (<span class="number">1.00s</span>)</span><br><span class="line">--- PASS: TestA (<span class="number">1.00s</span>)</span><br><span class="line">PASS</span><br><span class="line">ok      test1     <span class="number">2.083s</span></span><br></pre></td></tr></table></figure></p><p>并行单元测试：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -v -args <span class="string">"b"</span></span><br><span class="line">=== RUN   TestA</span><br><span class="line">=== RUN   TestB</span><br><span class="line">--- PASS: TestB (<span class="number">1.00s</span>)</span><br><span class="line">--- PASS: TestA (<span class="number">1.00s</span>)</span><br><span class="line">PASS</span><br><span class="line">ok      test1     <span class="number">1.077s</span></span><br></pre></td></tr></table></figure></p><p>subtest:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFoo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Run(<span class="string">"group"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Run(<span class="string">"A=1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; time.Sleep(<span class="number">1e9</span>)&#125;)</span><br><span class="line">t.Run(<span class="string">"A=2"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; time.Sleep(<span class="number">3e9</span>) &#125;)</span><br><span class="line">t.Run(<span class="string">"B=1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; time.Sleep(<span class="number">1e9</span>) &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-Example"><a href="#2-Example" class="headerlink" title="2.Example"></a>2.Example</h2><p>比对输出结果和注释是否一致来判断的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">fmt.Println(add(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>性能测试</title>
      <link href="/2018/08/18/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/08/18/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="1-测试反射赋值和直接赋值的性能差距"><a href="#1-测试反射赋值和直接赋值的性能差距" class="headerlink" title="1. 测试反射赋值和直接赋值的性能差距"></a>1. 测试反射赋值和直接赋值的性能差距</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d=<span class="built_in">new</span>(Data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">(x <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">v:=reflect.ValueOf(d).Elem()</span><br><span class="line">f:=v.FieldByName(<span class="string">"Name"</span>)</span><br><span class="line">f.Set(reflect.ValueOf(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(x <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">d.Name=x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSet</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">set(<span class="string">"gongshen"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkReset</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">reset(<span class="string">"gongshen"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> go test -bench .</span><br><span class="line">BenchmarkSet-4          1000000000               1.98 ns/op</span><br><span class="line">BenchmarkReset-4         5000000               313 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok     test 4.168s</span><br><span class="line">// 循环次数是 1000000000 次，每次执行时间为1.98ns</span><br></pre></td></tr></table></figure></p><p>显然差距非常大</p><h2 id="2-优化反射赋值，将反射数据“缓存起来”。"><a href="#2-优化反射赋值，将反射数据“缓存起来”。" class="headerlink" title="2. 优化反射赋值，将反射数据“缓存起来”。"></a>2. 优化反射赋值，将反射数据“缓存起来”。</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v=reflect.ValueOf(d).Elem()</span><br><span class="line"><span class="keyword">var</span> f=v.FieldByName(<span class="string">"Name"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reset</span><span class="params">(x <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">f.Set(reflect.ValueOf(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化测试：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> go test -bench .</span><br><span class="line">BenchmarkSet-4          1000000000               1.99 ns/op</span><br><span class="line">BenchmarkReset-4        10000000               122 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      test  3.651s</span><br></pre></td></tr></table></figure></p><p>显然性能有所提升，但还是不够。</p><h2 id="3-测试方法反射调用和方法直接调用的性能差距"><a href="#3-测试方法反射调用和方法直接调用的性能差距" class="headerlink" title="3. 测试方法反射调用和方法直接调用的性能差距"></a>3. 测试方法<code>反射调用</code>和方法<code>直接调用</code>的性能差距</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Data)</span><span class="title">PrintData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d=<span class="built_in">new</span>(Data)</span><br><span class="line"><span class="keyword">var</span> v=reflect.ValueOf(d)</span><br><span class="line"><span class="keyword">var</span> m=v.MethodByName(<span class="string">"PrintData"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkCall</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">d.PrintData()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkRcall</span><span class="params">(b *testing.B)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++ &#123;</span><br><span class="line">m.Call(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> go test -bench .</span><br><span class="line">BenchmarkCall-4         2000000000               0.96 ns/op</span><br><span class="line">BenchmarkRcall-4         5000000               366 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok   test  4.307s</span><br></pre></td></tr></table></figure></p><h2 id="4-当benchmark还需要其他设置时，应该重置定时器"><a href="#4-当benchmark还需要其他设置时，应该重置定时器" class="headerlink" title="4. 当benchmark还需要其他设置时，应该重置定时器"></a>4. 当benchmark还需要其他设置时，应该重置定时器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">b.ResetTimer() <span class="comment">//重置</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">b.StopTimer() <span class="comment">//暂停</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">b.StartTimer() <span class="comment">//恢复</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>test_Readme</title>
      <link href="/2018/08/18/test_Readme/"/>
      <url>/2018/08/18/test_Readme/</url>
      <content type="html"><![CDATA[<a id="more"></a><h1 id="Test：矫正行为"><a href="#Test：矫正行为" class="headerlink" title="Test：矫正行为"></a>Test：矫正行为</h1><h3 id="包内测试"><a href="#包内测试" class="headerlink" title="包内测试"></a>包内测试</h3><ul><li>文件名以<code>Test</code>开头</li><li>指定运行匹配的测试函数：<code>-run=&quot;A|B&quot;</code></li><li><code>t.Error</code>或者<code>t.Errorf</code>并不会因为测试失败而停止下面的测试</li><li><code>t.Fatal</code>和<code>t.Fatalf</code>会因为测试失败而终止当前gorouting</li></ul><h3 id="运行更comprehensive案列"><a href="#运行更comprehensive案列" class="headerlink" title="运行更comprehensive案列"></a>运行更comprehensive案列</h3><ul><li>table-driven 测试</li><li>randomized 测试</li></ul><h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><ul><li><code>go test -cover</code>：语句覆盖率测试</li><li><code>go test -cover -coverprofile c.out</code>：将结果输出到文件（默认set模式，记录语句是否覆盖）</li><li><code>go test -cover -coverprofile c.out -covermode count</code>：更改为count模式，记录语句覆盖次数</li><li><code>go tool cover -html=c.out</code>：以c.out文件在浏览器显示</li><li><code>go tool cover -func=c.out</code>：显示函数细节</li></ul><h3 id="外部测试"><a href="#外部测试" class="headerlink" title="外部测试"></a>外部测试</h3><p>我们知道两个package不能存在于同一个文件中，但是有一种特殊的外部测试包。如果文件中的包名<code>b</code>，那么可以创建外部测试包<code>b_test</code>。</p><p><span style="border-bottom:2px solid red;">创建一个内部测试文件（export_test.go）</span>：将需要的内部暴露给外部测试包;测试文件中的函数和变量只能是当前package下的测试文件能访问</p><p><span style="border-bottom:2px solid red;">仅显示开发代码文件</span>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list -f=&#123;&#123;.GoFiles&#125;&#125; fmt</span><br></pre></td></tr></table></figure></p><p><span style="border-bottom:2px solid red;">仅显示包内测试代码</span>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list -f=&#123;&#123;.TestGoFiles&#125;&#125; fmt</span><br></pre></td></tr></table></figure></p><p><span style="border-bottom:2px solid red;">仅显示外部测试代码</span>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list -f=&#123;&#123;.XTestGoFiles&#125;&#125; fmt</span><br></pre></td></tr></table></figure></p><h1 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h1><p><code>go test</code>会把可执行文件删除在完成测试之后，加上<code>-cpuprofile</code>标志可以保留其可执行文件<br>使用<code>go tool pprof</code>再加上<code>可执行文件</code>就可以解析profile文件</p><ul><li><code>go test -run=none -bench=ClientServerParallelTLS64 -cpuprofile=cpu.log net/http</code>：会生成<em>cpu.log</em>和<em>http.test.exe</em></li><li><code>go tool pprof -text -nodecount=10 ./http.test.exe cpu.log</code>：使用<em>pprof</em>工具分析cpu使用文件</li><li>-cpuprofile：列出使用最多CPU的函数</li><li>-memprofile：列出分配最多内存的语句</li><li>-blockprofile：列出最长阻塞gorouting的运算</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flat  flat%   sum%        cum   cum%</span><br><span class="line">1.10s 20.07% 59.85%      1.10s 20.07%  unicode.IsLetter</span><br><span class="line">0.75s 13.69% 73.54%      0.75s 13.69%  unicode.ToLower</span><br><span class="line">0.39s  7.12% 80.66%      0.44s  8.03%  runtime.mallocgc</span><br></pre></td></tr></table></figure><p>Go运行时会100Hz对CPU进行抽样，也就是10毫秒一次</p><ol><li>第一列表示直接调用该函数总执行了<code>1.10s</code>，也就是抽样110次，占总数的20.07%（总数548次）</li><li>第三列表示前几列加起来占总时间的百分之几</li><li>第四列表示直接调用该函数加上间接调用函数用掉的时间</li><li>第五列表示第四列占的百分比</li></ol><h3 id="graphviz工具的配合使用"><a href="#graphviz工具的配合使用" class="headerlink" title="graphviz工具的配合使用"></a>graphviz工具的配合使用</h3><ol><li><code>go tool pprof ./word.test.exe cpu.log</code>：进入pprof模式</li><li><code>web</code>：浏览器查看整个函数调用的过程</li><li><code>web IsPalindrome</code>：浏览器查看IsPalindrome函数的调用过程</li><li><code>list IsPalindrome</code>：查看IsPalindrome函数每一行的执行时间</li></ol><h1 id="Benchmark：测量操作"><a href="#Benchmark：测量操作" class="headerlink" title="Benchmark：测量操作"></a>Benchmark：测量操作</h1><ul><li>使用<code>ResetTimer,StopTimer,StartTimer</code>等重置计时器，排除一些设定代码的时间</li><li>抵制使用<code>b.N</code>作为参数的诱惑，使用多个固定参数进行测试比较</li><li>性能测试过滤单元测试的输出，所以使用<code>-run=none</code></li></ul><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>在<code>Example</code>函数中添加预期的答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Output: one</span><br><span class="line">//two</span><br></pre></td></tr></table></figure></p><p>如果输出时随机的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Unordered Output:two</span><br><span class="line">//one</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关系数据库原理</title>
      <link href="/2018/08/18/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
      <url>/2018/08/18/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<a id="more"></a><h1 id="一、数据库基本知识"><a href="#一、数据库基本知识" class="headerlink" title="一、数据库基本知识"></a>一、数据库基本知识</h1><p>一个好的哈希表：$O(1)$<br>一个均衡的树：$O(log(n))$<br>一个好的排序算法：$O(n*log(n))$<br>一个差的排序算法：$O(n^2)$</p><h3 id="1、排序"><a href="#1、排序" class="headerlink" title="1、排序"></a>1、排序</h3><p>合并排序：时间复杂度$O(n*log(n))$</p><h3 id="2、存储"><a href="#2、存储" class="headerlink" title="2、存储"></a>2、存储</h3><p>数据库的表使用的是<code>二维阵列</code>存储：必须一下子全部加载到内存中。<br>数据库使用<code>哈希表</code>来存储<code>锁表</code>和<code>缓冲池</code>：可以先加载一半到内存中。</p><h3 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h3><p>一张表设置了主键，就等于建立了树状索引，就是<code>聚集索引</code>。</p><h4 id="查找特定的值：二叉查找树"><a href="#查找特定的值：二叉查找树" class="headerlink" title="查找特定的值：二叉查找树"></a>查找特定的值：二叉查找树</h4><p>比如说你要查找40，时间复杂度O(log(N))</p><p><img src="\images\binary_search_tree.png" alt="二叉查找树"></p><h4 id="范围查找：B-树"><a href="#范围查找：B-树" class="headerlink" title="范围查找：B+树"></a>范围查找：B+树</h4><p>比如你要查找40~100之间的值，只需要找到40，通过后续节点找到100，时间复杂度O(M+log(N))</p><p><img src="\images\b+_tree.png" alt="B+树"></p><ul><li>只有最底层的叶子才保存行信息</li><li>底层节点是连续的</li><li>尽量降低B+树的层数（表的索引），不然时间复杂度会变成$O(n)$</li><li>当数据库进行删除插入操作时，需要自动更新B+索引树，所以创建太多索引影响性能</li></ul><h1 id="二、数据库全局概览"><a href="#二、数据库全局概览" class="headerlink" title="二、数据库全局概览"></a>二、数据库全局概览</h1><p><img src="\images\数据库全局概览.png" alt="数据库全局概览"><br><span style="border-bottom:2px solid red;">核心组件</span></p><ul><li>Process Manager：</li><li>Network Manager：</li><li>Memory Manager：</li><li>Client Manager：</li><li>File system Manager：</li><li>Security Manager：对用户的验证和授权</li></ul><p><span style="border-bottom:2px solid red;">工具</span></p><ul><li>Backup Manager：</li><li>Recovery Manager：崩溃后重启数据库到一致状态</li><li>Monitor Manager：记录数据库活动信息</li><li>Administration Manager：管理数据库、模式、表空间</li></ul><p><span style="border-bottom:2px solid red;">查询管理器</span></p><ul><li>Query executor：编译和执行查询</li><li>Query parser：检查查询是否合法</li><li>Query rewriter：预优化查询</li><li>Query optimizer：优化查询</li></ul><p><span style="border-bottom:2px solid red;">数据管理器</span></p><ul><li>Transaction Manager：处理事务</li><li>Cache Manager：</li><li>Data access Manager：访问磁盘中的数据</li></ul><h1 id="三、查询过程"><a href="#三、查询过程" class="headerlink" title="三、查询过程"></a>三、查询过程</h1><p><img src="\images\数据库查询过程.png" alt="查询过程"></p><h2 id="1、客户端管理器："><a href="#1、客户端管理器：" class="headerlink" title="1、客户端管理器："></a>1、客户端管理器：</h2><p>当你连接数据库时：</p><ol><li>客户端管理器检查你的<strong>验证信息</strong>，检查你是否具有<strong>访问权限</strong>。</li><li>客户端管理器检查是否有空闲的进程或线程处理你的查询。</li><li>客户端管理器检查数据库是否负载很重。</li><li>如果客户端管理器等待超时还获取不到资源，会关闭连接。</li><li>客户端管理器会把查询给查询管理器处理。</li><li>查询处理进程从查询管理器获取数据后，会将部分结果保存至缓存并且给你发送</li></ol><h2 id="2、查询管理器："><a href="#2、查询管理器：" class="headerlink" title="2、查询管理器："></a>2、查询管理器：</h2><ol><li>查询被解析并判断是否合法</li><li>重写——去除无用的操作加入预优化部分</li><li>优化提升性能，转换为可执行代码和数据查询计划</li><li>计划被编译</li><li>执行</li></ol><h3 id="第一步：查询解析器"><a href="#第一步：查询解析器" class="headerlink" title="第一步：查询解析器"></a>第一步：查询解析器</h3><ol><li>语法是否有误</li><li>关键字使用的顺序</li><li>根据数据库的元数据检查<strong>表是否存在</strong>,表的<strong>字段是否存在</strong></li><li>对类型的使用是否可行</li><li>是否具有<strong>权限</strong>来读写表</li></ol><h3 id="第二步：查询重写器"><a href="#第二步：查询重写器" class="headerlink" title="第二步：查询重写器"></a>第二步：查询重写器</h3><ol><li>预优化查询,避免不必要的运算</li><li>根据一些规则寻找优化解决方案   <ul><li><strong>视图合并</strong>:把查询中的试图转换为SQL代码</li><li><strong>子查询扁平化</strong>:尝试移除子查询(因为子查询难以优化)</li><li><strong>去除不必要的运算符</strong>:比如你用了<code>DISTINCT</code>和<code>UNIQUE</code>,那么<code>DISTINCT</code>就会被去掉.</li><li>消除冗余的连接</li><li><strong>常数计算赋值</strong>:比如 WHERE age &gt; 10 + 2 ,会转换为 WHERE age &lt; 12</li><li><strong>分区裁剪</strong>:如果你用了分区表,重写器能够找到需要使用的分区</li><li><strong>物化试图重写</strong>:如果有物化试图正好匹配查询谓词的一个子集,那么修改查询使用物化试图而不是原始表.</li><li><strong>自定义规则</strong>:如果你有自定义规则和修改查询,重写器就会执行这些规则</li><li><strong>OLAP转换</strong></li></ul></li></ol><p>例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PERSON.*</span><br><span class="line"><span class="keyword">FROM</span> PERSON</span><br><span class="line"><span class="keyword">WHERE</span> PERSON.person_key <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> MAILS.person_key</span><br><span class="line"><span class="keyword">FROM</span> MAILS</span><br><span class="line"><span class="keyword">WHERE</span> MAILS.mail <span class="keyword">LIKE</span> <span class="string">'christophe%'</span>);</span><br></pre></td></tr></table></figure><p>会转换为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PERSON.*</span><br><span class="line"><span class="keyword">FROM</span> PERSON, MAILS</span><br><span class="line"><span class="keyword">WHERE</span> PERSON.person_key = MAILS.person_key</span><br><span class="line"><span class="keyword">and</span> MAILS.mail <span class="keyword">LIKE</span> <span class="string">'christophe%'</span>;</span><br></pre></td></tr></table></figure><h3 id="第三步：统计"><a href="#第三步：统计" class="headerlink" title="第三步：统计"></a>第三步：统计</h3><p>当你统计信息时,数据库会计算:</p><ul><li>表中行和列的数量</li><li>表中列的唯一值,数据长度,数据范围</li><li>表的索引</li></ul><p>统计的信息对于查询优化器做优化特别重要,所以统计必须要及时更新.</p><h3 id="第四步：查询优化器"><a href="#第四步：查询优化器" class="headerlink" title="第四步：查询优化器"></a>第四步：查询优化器</h3><h4 id="获取数据的方法："><a href="#获取数据的方法：" class="headerlink" title="获取数据的方法："></a>获取数据的方法：</h4><ul><li>全扫描：完整的读取一个表或索引</li><li>范围扫描：使用B+树只是读取索引的一部分</li><li>唯一扫描：二叉查找树就是查找唯一值的</li></ul><h4 id="联接运算符（获取数据后那么就要连接了）"><a href="#联接运算符（获取数据后那么就要连接了）" class="headerlink" title="联接运算符（获取数据后那么就要连接了）"></a>联接运算符（获取数据后那么就要连接了）</h4><p>大多数情况下，“A Join B” 和 “B Join A”的成本是不同的</p><hr><p><span style="border-bottom:2px solid red;">合并联接</span>：（a、b中挑选相同的元素）<br><img src="\images\数据库合并联接.png" alt="合并联接"><br>如果两个关系都已经排序，时间复杂度：$O(N+M)$<br>如果两个关系都未排序，时间复杂度：$O(N<em>log(N)+M</em>log(M))$</p><hr><p><span style="border-bottom:2px solid red;">哈希联接</span>：<br><img src="\images\数据库哈希联接.png" alt="哈希联接"><br>如果是个好的哈希函数，时间复杂度：$O(N+M)$</p><hr><p><span style="border-bottom:2px solid red;">嵌套循环联接</span>：<br><img src="\images\数据库循环嵌套联接.png" alt="循环嵌套"></p><ul><li>针对外关系的每一行，查看内关系里所有的行来寻找匹配的行。时间复杂度为$O(N^2)$。</li><li>将两个关系<code>成簇的读取</code>对磁盘I/O有利，但时间复杂度没变。</li><li>如果内关系足够小，那么时间复杂度最好能到：$O(N)$</li></ul><hr><h4 id="执行联接的顺序的算法"><a href="#执行联接的顺序的算法" class="headerlink" title="执行联接的顺序的算法"></a>执行联接的顺序的算法</h4><p><img src="\images\数据库联接顺序.png" alt="执行联接顺序"><br><span style="border-bottom:2px solid red;">动态规划</span>：</p><ul><li>省掉一些相似的做法，比如（A Join B）是重复的。</li></ul><p><span style="border-bottom:2px solid red;">启发式</span>：</p><ul><li>如果一个表有针对指定谓词的索引，那么就不要对表进行合并联接，对索引</li><li>增加一些规则，比如<code>联接运算要先于其他关系运算</code></li></ul><p><span style="border-bottom:2px solid red;">贪婪法</span>：</p><ul><li>先从要联接的表中选出一张表（A）</li><li>计算每一个与（A）的联接，如果（A Join B）成本最低</li><li>计算每一个与（A Join B）的结果成本最低的表</li><li>…</li><li>可以结合多个贪婪选项得出比较满意的答案</li></ul><h4 id="真实的优化器"><a href="#真实的优化器" class="headerlink" title="真实的优化器"></a>真实的优化器</h4><p><span style="border-bottom:2px solid red;">SQLite</span></p><ul><li>在有 CROSS JOIN（两个表的笛卡尔乘积）时从不给表重新排序</li><li>使用嵌套联接</li><li>3.8.0版本使用<code>最近邻居</code>的贪婪算法作为最佳查询计划</li><li>…</li></ul><h3 id="第五步、查询执行器"><a href="#第五步、查询执行器" class="headerlink" title="第五步、查询执行器"></a>第五步、查询执行器</h3><blockquote><p>这时我们有了一个优化了的执行代码，编译为可执行代码，如果计算机的硬件符合要求，就会执行。但是查询执行器不会直接从文件系统拿数据，而是向<code>缓存管理器</code>要。</p></blockquote><h2 id="4、数据管理器"><a href="#4、数据管理器" class="headerlink" title="4、数据管理器"></a>4、数据管理器</h2><h3 id="缓存管理器：与查询执行器进行数据的交互"><a href="#缓存管理器：与查询执行器进行数据的交互" class="headerlink" title="缓存管理器：与查询执行器进行数据的交互"></a>缓存管理器：与查询执行器进行数据的交互</h3><p><img src="\images\数据库缓存管理器.png" alt="缓存管理器"></p><ul><li>因为磁盘I/O的瓶颈，缓存管理器有一个内存缓冲区（缓冲池）：从内存读取数据提供性能</li><li>缓存管理器需要在查询执行器使用数据之前<code>预读</code>数据</li><li>使用<code>缓冲区命中率</code>来度量预读的效率</li><li>缓冲容量有限，必须频繁加载移除，用<code>缓冲区置换策略</code>来解决</li></ul><p><span style="border-bottom:2px solid red;">预读</span></p><blockquote><p>当查询执行器处理它的第一批数据时，会告诉缓存管理器预先装载第二批数据，当开始处理第二批数据时，告诉缓存管理器预先装载第三批数据，并且告诉缓存管理器第一批可以从缓存里清掉。</p></blockquote><ul><li>推测预读法：查询执行器想要（1，3，5）数据，推测其也许需要（7，9，11）</li><li>顺序预读法：只是简单的加载下一批连续的数据</li></ul><p><span style="border-bottom:2px solid red;">缓冲/缓存命中率</span></p><blockquote><p>显示请求的数据在缓存中找到而不是从磁盘读取的频率</p></blockquote><p><span style="border-bottom:2px solid red;">缓冲区置换策略</span></p><blockquote><p>因为内存大小有限，必须移除旧的数据，一般使用LRU（最近最少使用）算法</p></blockquote><p><img src="\images\数据库缓存置换策略_LRU.png" alt="LRU算法"></p><h4 id="写缓冲区"><a href="#写缓冲区" class="headerlink" title="写缓冲区"></a>写缓冲区</h4><blockquote><p>预先加载数据、成批刷入磁盘都可以提升写缓冲区的速度。缓冲区最小的数据单位是<code>页</code>，不是行。如果缓冲区的页修改了但是没有写入磁盘，就是<code>脏页</code>。</p></blockquote><h2 id="5、事务管理器"><a href="#5、事务管理器" class="headerlink" title="5、事务管理器"></a>5、事务管理器</h2><p><span style="border-bottom:2px solid red;">一个事务就是一个工作单元</span></p><ul><li>原子性（Atomicity）：要么全完成，要么全部取消。</li><li>隔离性（Isolation）：如果A，B事务同时运行，最终结果都是相同的，不管谁先结束。</li><li>持久性（Durability）：一旦事务提交（成功运行），不管发生什么，数据要保存在数据库中。</li><li>一致性（Consistency）：只有合法的数据才能写入数据库。</li></ul><p><span style="border-bottom:2px solid red;">4个隔离级别</span></p><ul><li>串行化（Serializable，SQLite默认模式）：最高级别，两个事务100%隔离</li><li>可重复读（Repeatable read，MySQL默认模式）：每个事务都有自己的世界，只是在<code>新数据方面突破隔离，在旧数据仍然隔离</code>。比如事务A运行（select count(1) from table），事务B这时在table表中添加了一条新的数据，那么事务A再运行一次得到的结果是不一样的——幻读</li><li>读取已提交（Oracle，PostgreSQL，SQL Server默认模式）：如果事务A读取数据D，这时事务B删除或修改数据D并提交，那么事务A再次读数据D时数据的变化是可见的——不可重复读</li><li>读取未提交：最低级别，如果事务A读取数据D，事务B修改或删除数据D（并未提交，事务B还在运行），那么事务A读取数据D时数据的变化是可见的。如果事务B回滚，那么事务A中读取的数据D是无意义的——<code>脏读</code>。</li></ul><h1 id="四、数据库的并发控制"><a href="#四、数据库的并发控制" class="headerlink" title="四、数据库的并发控制"></a>四、数据库的并发控制</h1><h2 id="1、锁管理器"><a href="#1、锁管理器" class="headerlink" title="1、锁管理器"></a>1、锁管理器</h2><p><img src="\images\数据库锁管理器.png" alt="锁管理器"></p><blockquote><p>锁管理器是添加和释放锁的进程，用一个哈希表来保存锁信息（关键字是被锁的数据）</p></blockquote><p><span style="border-bottom:2px solid red;">排他锁原理</span></p><blockquote><p>如果事务A需要一条数据，就把他锁住，如果事务B也需要这个数据，必须等待事务A释放数据。</p></blockquote><p><span style="border-bottom:2px solid red;">共享锁原理</span></p><ol><li>事务A需要【读取】数据 X，它会给数据 X 加上【共享锁】并读取</li><li>事务B也需要【读取】数据 X，它会给数据 X 加上【共享锁】并读取</li><li>事务C要【修改】数据 X，它会给数据 X 加上【排他锁】，但是必须等待事务A，B释放【共享锁】</li></ol><p><span style="border-bottom:2px solid red;">两段锁原理</span></p><ul><li>将事务分为两个阶段：</li><li>成长阶段：事务可以获得锁，但不能释放锁</li><li>收缩阶段：事务可以释放锁（对于已经处理完而且不会再次处理的数据），但不能获得新锁</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><code>超时设定</code>，如果一个锁再该时间内没有加上，那么就判断事务产生死锁——简单</li><li>检查哈希表中是否有循环——代价很昂贵</li><li>在加锁之前检查该锁是否会死锁——代价也很昂贵</li></ul><h2 id="2、版本控制"><a href="#2、版本控制" class="headerlink" title="2、版本控制"></a>2、版本控制</h2><ul><li>每个事务可以同时修改【相同的】数据</li><li>每个事务有自己的数据拷贝（版本）</li><li>如果两个事务同时修改相同的数据，只接受一个修改，另一个将回滚或者重新运行</li><li>读写事务不会相互阻塞</li><li>没有锁管理器带来额外开销</li><li>但是磁盘空间的消耗会很大</li></ul><h1 id="五、数据库的日志管理"><a href="#五、数据库的日志管理" class="headerlink" title="五、数据库的日志管理"></a>五、数据库的日志管理</h1><p><img src="\images\数据库日志管理器.png" alt="日志管理器"></p><p>为了保证事务的持久性和原子性，有两个解决方法：</p><ol><li>副本：事务创建自己的副本，基于副本工作，如果失败，就删除副本；如果成功，就提交副本</li><li>事务日志：在每次写入磁盘之前，在事务日志中写入信息，这样崩溃了也能知道该怎么办</li></ol><h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>大多数数据库使用<code>预写日志协议</code>（Write-Ahead Logging protocol，WAL）来处理事务日志。</p><ol><li>每个对数据库的修改都产生一条<code>日志记录</code>，在数据写入磁盘前都必须把<code>日志记录</code>写入事务日志。</li><li>日志记录必须按顺序写入</li><li>事务提交成功之前，必须把事务的提交顺序写入事务日志</li></ol><h2 id="ARIES"><a href="#ARIES" class="headerlink" title="ARIES"></a>ARIES</h2><p>比WAL在写日志时能保持良好的性能，快速可靠的数据恢复。</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志的组成：磁盘上保存数据的每个页都记录着最后修改该数据的LSN</p><ul><li>LSN：日志序列号（Log Sequence Num），这是按时间顺序分配的</li><li>TransID：产生操作事务的ID</li><li>PagelD：被修改的数据在磁盘上页的位置</li><li>PrevLSN：同一个事务产生的上一条日志的链接</li><li>UNDO：取消本次操作的方法，回到原来状态的反向操作</li><li>REDO：重复本次操作</li></ul><h3 id="日志缓冲区"><a href="#日志缓冲区" class="headerlink" title="日志缓冲区"></a>日志缓冲区</h3><p><img src="\images\数据库日志缓冲区.png" alt="日志缓冲区"></p><p>当查询执行器要求做一次修改：</p><ol><li>缓存管理器将修改存入自己的缓存</li><li>日志管理器将相关日志存入自己的日志缓冲区</li><li>查询执行器认为操作已经完成</li><li>日志管理器将日志写入事务日志</li><li>缓存管理器将修改写入磁盘</li></ol><h3 id="STEAL-和-FORCE-策略"><a href="#STEAL-和-FORCE-策略" class="headerlink" title="STEAL 和 FORCE 策略"></a>STEAL 和 FORCE 策略</h3><ul><li>NO-FORCE策略——如果第5步在事务提交之后完成，一旦发生崩溃，可以使用<code>REDO</code>恢复事务</li><li>FORCE策略——第5步在事务提交之前必须完成。</li><li>STEAL策略——数据是一步步的写入磁盘</li><li>NO-STEAL策略——缓冲区管理器等待提交命令然后一次性写入磁盘</li></ul><p><span style="border-bottom:2px solid red;">大部分的数据库都选择<strong>No-Force/Steal</strong>策略，性能最好。</span></p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>如果事务被【手动】取消，或者被所管理器取消（取消死锁），或者因为网路故障取消，那么就不需要进行分析阶段，因为哪些需要Redo，哪些需要Undo的信息保存在2个内存表中：</p><ul><li>事务表：保存当前所有事务状态</li><li>脏页表：保存哪些数据需要写入磁盘</li></ul><h4 id="1、分析阶段"><a href="#1、分析阶段" class="headerlink" title="1、分析阶段"></a>1、分析阶段</h4><blockquote><p>恢复进程读取全部的事务日志，来重建崩溃中发生的时间线（生成2张表），决定哪些事务回滚（未提交的事务都需回滚）、崩溃时哪些数据需要写盘。</p></blockquote><p><span style="border-bottom:2px solid red;">检查点</span>：</p><blockquote><p>为了加快分析阶段，使用检查点技术，不时的把2张表的内容和最后一条LSN写入磁盘，那么在分析阶段中，只要分析这个LSN之后的日志就可以了。</p></blockquote><h4 id="2、Redo阶段"><a href="#2、Redo阶段" class="headerlink" title="2、Redo阶段"></a>2、Redo阶段</h4><ul><li>Redo按日志的时间顺序（LSN）进行处理</li><li>如果LSN（磁盘页）&gt;= LSN（日志记录），说明数据在崩溃前写入磁盘，所以不需要做什么</li><li>如果LSN（磁盘页）&lt; LSN（日志记录），磁盘上的页将要被更新</li></ul><h4 id="3、Undo阶段"><a href="#3、Undo阶段" class="headerlink" title="3、Undo阶段"></a>3、Undo阶段</h4><p>从每个事务的最后一条日志开始回滚所有崩溃时未完成的事务。</p><h1 id="六、数据库的数据存储"><a href="#六、数据库的数据存储" class="headerlink" title="六、数据库的数据存储"></a>六、数据库的数据存储</h1><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型分为：定长<code>char(20)</code>和变长<code>varchar(20)</code>，除非最长和最短相差太多，否则还是使用定长比较好。</p><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><blockquote><p>一个数据块中能存储的记录（行）分为：变长记录和定长记录。每个记录中都包含各自的<code>RID</code>。</p><blockquote><p>无序记录的文件被称为<code>堆文件</code>，有序的文件通常需要结合<code>聚簇索引</code>（将数据直接存储在数据库块的索引上）来排序。</p></blockquote></blockquote><h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>顺序文件组织：能根据索引来检索文件<br>散列文件组织：hash索引</p><h3 id="数据库存储的文件"><a href="#数据库存储的文件" class="headerlink" title="数据库存储的文件"></a>数据库存储的文件</h3><ul><li>数据文件</li><li>索引文件</li><li>日志文件</li></ul><h3 id="MySQL的数据字典"><a href="#MySQL的数据字典" class="headerlink" title="MySQL的数据字典"></a>MySQL的数据字典</h3><ul><li>mysql：保存数据库的元数据的</li><li>information_schema：统计数据</li><li>performance_schema：显示性能信息</li></ul><blockquote><p>本文转载于<a href="http://blog.jobbole.com/100349/" target="_blank" rel="noopener">数据库原理</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>dependency_injection</title>
      <link href="/2018/08/18/dependency-injection/"/>
      <url>/2018/08/18/dependency-injection/</url>
      <content type="html"><![CDATA[<a id="more"></a><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h3 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1. 依赖"></a>1. 依赖</h3><p>如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Father father;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        father = <span class="keyword">new</span> Father();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看这段代码我们会发现存在一些问题：<br>(1). 如果现在要改变 father 生成方式，如需要用<code>new Father(String name)</code>初始化 father，需要修改 Human 代码；<br>(2). 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；<br>(3). 如果<code>new Father()</code>过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。  </p><h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h3><p>上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Father father;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.father = father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。<strong>像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。</strong><br>现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：<br>(1). 解耦，将依赖之间解耦。<br>(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。</p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 依赖注入 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>旋转字符串</title>
      <link href="/2018/08/10/%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/08/10/%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给出字符串abcdefg，旋转2，变成cdefgab </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//法一：暴力移位法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftShiftOne</span><span class="params">(<span class="built_in">string</span> &amp;str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = str.length();</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> t = str[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">str[i<span class="number">-1</span>]=str[i];</span><br><span class="line">&#125;</span><br><span class="line">str[n<span class="number">-1</span>]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate_1</span><span class="params">(<span class="built_in">string</span> &amp;str,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">leftShiftOne(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法二：三步转换法 </span></span><br><span class="line"><span class="comment">//ab-&gt;ba</span></span><br><span class="line"><span class="comment">//cdefg-&gt;gfedc</span></span><br><span class="line"><span class="comment">//bagfedc-&gt;cdefgab </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserveString</span><span class="params">(<span class="built_in">string</span> &amp;str,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(from &lt; to)&#123;</span><br><span class="line"><span class="keyword">char</span> t = str[from];</span><br><span class="line">str[from]=str[to];</span><br><span class="line">str[to]=t;</span><br><span class="line">from++;</span><br><span class="line">to--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate_2</span><span class="params">(<span class="built_in">string</span> &amp;str,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">m %= n;</span><br><span class="line">reserveString(str,<span class="number">0</span>,m<span class="number">-1</span>);</span><br><span class="line">reserveString(str,m,n<span class="number">-1</span>);</span><br><span class="line">reserveString(str,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s =<span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">7</span>;</span><br><span class="line">rotate_2(s,num,s.size());</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>发送邮件</title>
      <link href="/2018/08/09/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>/2018/08/09/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      <content type="html"><![CDATA[<a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">auth:=smtp.PlainAuth(<span class="string">""</span>,<span class="string">"example1@qq.com"</span>,<span class="string">"密码"</span>,<span class="string">"smtp.qq.com"</span>)</span><br><span class="line">to:=[]<span class="keyword">string</span>&#123;<span class="string">"example2@qq.com"</span>&#125;</span><br><span class="line">nickname:=<span class="string">"test"</span></span><br><span class="line">subject:=<span class="string">"test mail"</span></span><br><span class="line">content_type:=<span class="string">"Content-type: text/plain;charset=UTF-8"</span></span><br><span class="line">body:=<span class="string">"This is email body!"</span></span><br><span class="line">from:=<span class="string">"example1@qq.com"</span></span><br><span class="line">msg:=[]<span class="keyword">byte</span>(<span class="string">"To:"</span>+strings.Join(to,<span class="string">","</span>)+<span class="string">"\r\nFrom"</span>+nickname+<span class="string">"&lt;"</span>+from+<span class="string">"&gt;\r\nSubject:"</span>+subject+<span class="string">"\r\n"</span>+content_type+<span class="string">"\r\n\r\n"</span>+body)</span><br><span class="line">err:=smtp.SendMail(<span class="string">"smtp.qq.com:25"</span>,auth,from,to,msg)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"send email error:%v"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>unsafe包</title>
      <link href="/2018/07/10/unsafe/"/>
      <url>/2018/07/10/unsafe/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h3><p><code>unsafe.Pointer</code>的4个规则：</p><ul><li>任何指针都可以转换为<code>unsafe.Pointer</code>类型</li><li><code>unsafe.Pointer</code>类型可以转换为任何指针</li><li><code>uintptr</code>类型可以转换为<code>unsafe.Pointer</code>类型</li><li><code>unsafe.Pointer</code>类型可以转换为<code>uintptr</code>类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i:= <span class="number">10</span></span><br><span class="line">    fi:=(*<span class="keyword">float64</span>)(unsafe.Pointer(&amp;i))</span><br><span class="line">    *fi = *fi * <span class="number">3</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>指针变量<code>*T</code>是不能计算偏移量的，但是<code>uintptr</code>可以，我们将指针转换为<code>uintptr</code>，进行偏移计算，这样就能访问特定内存了，达到对不同内存读写的目的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u:=<span class="built_in">new</span>(user)</span><br><span class="line">    pName := (*<span class="keyword">string</span>)(unsafe.Pointer(u))</span><br><span class="line">    *pName = <span class="string">"张三"</span></span><br><span class="line">    temp:=<span class="keyword">uintptr</span>(unsafe.Pointer(u))+unsafe.Offsetof(u.age)</span><br><span class="line">    pAge:=(*<span class="keyword">int</span>)(unsafe.Pointer(temp))</span><br><span class="line">    *pAge = <span class="number">20</span></span><br><span class="line">    fmt.Println(*u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>pName</code>因为是第一个字段，所以不需要偏移，<code>pAge</code>设置偏移后获取到该字段的内存地址。</p><hr><p>当一个变量被移动，所有的保存改变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾收集器的视角来看，一个unsafe.Pointer是一个指向变量的指针，因此当变量被移动是对应的指针也必须被更新；但是uintptr类型的临时变量只是一个普通的数字，所以其值不应该被改变。上面错误的代码因为引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针。当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的&amp;x.b地址。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp:=<span class="keyword">uintptr</span>(unsafe.Pointer(u))+unsafe.Offsetof(u.age)</span><br><span class="line">pAge:=(*<span class="keyword">int</span>)(unsafe.Pointer(temp))</span><br><span class="line">*pAge = <span class="number">20</span></span><br></pre></td></tr></table></figure></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">u:=<span class="built_in">new</span>(user)</span><br><span class="line">u.name = <span class="string">"张三"</span></span><br><span class="line">pAge:=(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(u))+unsafe.Offsetof(u.age)))</span><br><span class="line">*pAge = *pAge + <span class="number">20</span></span><br><span class="line">fmt.Println(*u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> package </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>温柔的人</title>
      <link href="/2018/05/27/%E6%B8%A9%E6%9F%94%E7%9A%84%E4%BA%BA/"/>
      <url>/2018/05/27/%E6%B8%A9%E6%9F%94%E7%9A%84%E4%BA%BA/</url>
      <content type="html"><![CDATA[<a id="more"></a><ul><li><a href="https://www.bilibili.com/bangumi/play/ss1699/?from=search&amp;seid=2826238494142229813" target="_blank" rel="noopener">四月是你的谎言</a></li><li><a href="https://www.bilibili.com/bangumi/play/ss173/?from=search&amp;seid=18135097600024502508" target="_blank" rel="noopener">一周的朋友</a></li><li><a href="https://www.bilibili.com/bangumi/play/ss857/?from=search&amp;seid=9659429609644661484" target="_blank" rel="noopener">好想告诉你</a></li><li><a href="https://www.bilibili.com/bangumi/play/ss687/?from=search&amp;seid=10532690056145324955" target="_blank" rel="noopener">樱花庄的宠物女孩</a></li><li><a href="https://www.bilibili.com/bangumi/play/ss441/?from=search&amp;seid=6970826844296742980" target="_blank" rel="noopener">来自风平浪静的明天</a></li><li><a href="https://www.bilibili.com/bangumi/play/ss4155/?from=search&amp;seid=14001513337380785036" target="_blank" rel="noopener">玉子爱情故事</a></li><li><a href="https://www.bilibili.com/bangumi/play/ss23850/?from=search&amp;seid=11911092656866222768" target="_blank" rel="noopener">超能力女儿</a></li><li>[散华礼弥]</li></ul>]]></content>
      
      <categories>
          
          <category> 网站资源 </category>
          
          <category> 动漫 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>链接</title>
      <link href="/2018/04/10/%E9%93%BE%E6%8E%A5/"/>
      <url>/2018/04/10/%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<a id="more"></a><ul><li><a href="https://www.zhihu.com/question/19942068/answer/269768796" target="_blank" rel="noopener">网上有哪些资源</a></li><li><a href="https://www.zhihu.com/question/50701819/answer/122610566" target="_blank" rel="noopener">新手程序员该做啥</a></li><li><a href="https://github.com/jobbole/awesome-programming-books" target="_blank" rel="noopener">经典编程书籍</a></li><li>go语言<ul><li><a href="https://tonybai.com/2015/04/30/go-and-https" target="_blank" rel="noopener">go和HTTPS</a></li><li><a href="http://www.oscarzhao.me/golang/2016/08/12/go-pipelines-cancellation.html" target="_blank" rel="noopener">Go的并发模型——流水线</a></li><li><a href="https://deepzz.com/post/golang-context-package-notes.html" target="_blank" rel="noopener">Go的并发模型——简单Context</a></li><li><a href="http://www.oscarzhao.me/golang/2016/08/26/go-context.html" target="_blank" rel="noopener">Go的并发模型——深入Context</a></li><li><a href="http://colobu.com/2017/05/12/call-private-functions-in-other-packages/" target="_blank" rel="noopener">访问私有函数和变量</a></li><li><a href="https://godoc.org" target="_blank" rel="noopener">go包搜索</a></li><li><a href="https://github.com/nange/datastructures-and-algorithms-using-four-language/tree/master/go" target="_blank" rel="noopener">各种数据结构实现</a></li></ul></li><li>开发工具<ul><li><a href="https://cse.google.com/cse/all" target="_blank" rel="noopener">gcse</a></li><li><a href="https://developers.google.com/custom-search/docs/overview" target="_blank" rel="noopener">gcse指南</a></li><li><a href="https://console.developers.google.com/apis" target="_blank" rel="noopener">google apis</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 网站资源 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>访问私有函数和变量</title>
      <link href="/2018/04/09/%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F/"/>
      <url>/2018/04/09/%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<a id="more"></a><p>如果一个函数只有函数声明，没有函数定义，那么它的函数定义肯定在其他地方，然后两者通过符号链接实现了，比如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> _<span class="string">"unsafe"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname hello b.Greet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello,World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _<span class="string">"a"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greet</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>b包中要添加一个空的汇编文件<code>empty.s</code>，不然不会通过编译</p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>http路由分发</title>
      <link href="/2018/03/30/http%E8%B7%AF%E7%94%B1%E5%88%86%E5%8F%91/"/>
      <url>/2018/03/30/http%E8%B7%AF%E7%94%B1%E5%88%86%E5%8F%91/</url>
      <content type="html"><![CDATA[<a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据func(f HandlerFunc)ServeHTTP(w http.ResponseWriter,r *http.Request)&#123;f(w,r)&#125;</span></span><br><span class="line"><span class="comment">//HandlerFunc类型可以实现路由转发功能，申明mux类型</span></span><br><span class="line"><span class="keyword">var</span> mux <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"><span class="function">// 定义自己的<span class="title">Handler</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">myHandler</span> <span class="title">struct</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//实现了ServeHTTP这个方法，实现了Handler接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*myHandler)</span><span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">fmt.Fprintf(w,<span class="string">"This is ServeHTTP!"</span>)</span><br><span class="line"><span class="keyword">if</span> f,ok:=mux[r.URL.String()];ok&#123;</span><br><span class="line">f(w,r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayBye2</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>  &#123;</span><br><span class="line">io.WriteString(w,<span class="string">"Bye!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello2</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">io.WriteString(w,<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter,*http.Request)</span>)</span></span><br><span class="line"><span class="function"><span class="title">mux</span>["/<span class="title">hello</span>"]=<span class="title">sayHello2</span></span></span><br><span class="line"><span class="function"><span class="title">mux</span>["/<span class="title">bye</span>"]=<span class="title">sayBye2</span></span></span><br><span class="line"><span class="function">//自己定义<span class="title">Server</span>结构体</span></span><br><span class="line"><span class="function"><span class="title">server</span>:=&amp;<span class="title">http</span>.<span class="title">Server</span></span>&#123;</span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">Addr:<span class="string">":1995"</span>,</span><br><span class="line"><span class="comment">//Handler函数</span></span><br><span class="line">Handler:&amp;myHandler&#123;&#125;,</span><br><span class="line">ReadTimeout:<span class="number">5</span>*time.Second,</span><br><span class="line">&#125;</span><br><span class="line">err:=server.ListenAndServe()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>http(1)</title>
      <link href="/2018/03/29/http-1/"/>
      <url>/2018/03/29/http-1/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="1、设置静态目录"><a href="#1、设置静态目录" class="headerlink" title="1、设置静态目录"></a>1、设置静态目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">http.ListenAndServe(&quot;:1995&quot;,http.FileServer(http.Dir(&quot;.&quot;)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、搭建简单HTTP服务器"><a href="#2、搭建简单HTTP服务器" class="headerlink" title="2、搭建简单HTTP服务器"></a>2、搭建简单HTTP服务器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">r.ParseForm()</span><br><span class="line"><span class="comment">// 向服务器端输出请求的url信息</span></span><br><span class="line">fmt.Println(r.Form)</span><br><span class="line">fmt.Println(<span class="string">"path:"</span>,r.URL.Path)</span><br><span class="line">fmt.Println(<span class="string">"scheme:"</span>,r.URL.Scheme)</span><br><span class="line">fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> r.Form&#123;</span><br><span class="line">fmt.Println(<span class="string">"key:"</span>,k)</span><br><span class="line">fmt.Println(<span class="string">"val:"</span>,strings.Join(v,<span class="string">" "</span>))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(w,<span class="string">"Hello gongshen!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>,sayHello)</span><br><span class="line">http.ListenAndServe(<span class="string">":1995"</span>,<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、底层实现路由分发策略"><a href="#3、底层实现路由分发策略" class="headerlink" title="3、底层实现路由分发策略"></a>3、底层实现路由分发策略</h3>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Readme</title>
      <link href="/2018/03/28/channel_readme/"/>
      <url>/2018/03/28/channel_readme/</url>
      <content type="html"><![CDATA[<h1 id="1、总结："><a href="#1、总结：" class="headerlink" title="1、总结："></a>1、总结：</h1><h3 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h3><ol><li><code>elem,ok:=&lt;-strCh</code>，没有元素时，当前gorouting进入<code>GWaiting</code>状态，当通道关闭时，<code>elem</code>会赋予相应的零值<code>ok</code>值为false</li><li>试图从一个未被初始化的通道值（值为<code>nil</code>的通道）接收元素值，会被永久阻塞</li><li>发送操作会使通道<code>复制</code>被发送的元素，如果<code>通道已空</code>且<code>有接收方在等待</code>，则直接把元素复制到最早等待的接收方中，否则复制到通道的缓存中</li><li>如果传递的值是<code>引用类型</code>，那么接收方的操作会影响发送方的<code>源值</code></li><li>可以使用<code>len</code>获取通道中的元素值数量，使用<code>cap</code>获取通道的容量。</li><li><code>Notify(c chan&lt;- os.Signal)</code>：约束的是方法的实现方（适用于接口）；<code>Notify()&lt;-chan os.Signal</code>：约束方法的调用方（适用于函数和结构体方法）</li><li>一般情况下不能转换通道类型，利用函数声明转换是Go的语法糖</li><li>可以使用<code>for</code>语句可以不断地从通道接收元素值，直到通道关闭，但是通道不能是一个<code>发送通道</code></li><li><code>select</code>后面直接加花括号，然后<code>case</code>后面只能是接收或者发送语句，<code>case</code>右边的表达式会先求值，相同条件时会随机选择一个</li><li><code>break</code>语句可以直接跳出<code>select</code>，和<code>for</code>一起用时，使用<code>break + 标签</code>来表示中断紧贴于标签下的语句。</li><li>单向通道可以对实现类型进行约束</li><li>向一个关闭的通道发送数据会阻塞，但是接收端可以在关闭的通道接收数据，所以建议在发送端关闭通道</li><li>建议用于传递<code>信号</code>的通道都以<code>struct{}</code>作为元素类型，因为空结构体类型是不占内存空间的，并且拥有相同的内存地址。<h3 id="非缓冲通道"><a href="#非缓冲通道" class="headerlink" title="非缓冲通道"></a>非缓冲通道</h3></li><li>非缓冲通道只能同步的传递元素值</li><li>向该通道<code>发送</code>元素值的操作会被阻塞，直到至少有一个针对该通道的接收操作，接收操作会先得到元素值的副本，然后唤醒发送方的gorouting，也就是说接收操作比发送操作先完成</li><li>从该通道<code>接收</code>元素值的操作会被阻塞，直到至少有一个针对该通道的发送操作，发送操作会直接把元素值复制给接收方，然后唤醒接收方的gorouting，所以发送操作比接收操作先完成<h3 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h3><span style="border-bottom:2px solid red">定时器</span>：</li><li>定时器<code>Timer</code>，我们不能使用复合字面量来初始化它，因为它含有包级私有字段，使用<code>time.NewTimer</code>和<code>time.AfterFunc</code>函数来构建</li><li>定时器<code>Timer</code>中有一个通道<code>C</code>的字段，当定时器到期时发送当前时间到通道<code>C</code></li><li><code>time.After</code>就是<code>time.NewTimer().C</code>的超时设定的一种快捷方式</li><li>每次循环都要新建定时器有先浪费，我们可以使用<code>timer.Reset</code>重置来复用</li><li>如果在<code>定时器</code>到期之前停止了它，再去接收<code>C</code>的元素值会一直阻塞</li><li>如果在<code>定时器</code>到期之后未能及时接收元素值，那么即使重置以后，<code>C</code>字段还是会一直缓存那个元素值，新的通知会被丢弃</li><li><code>time.AfterFunc</code>也会新建定时器，但是到期之后不会发送通知，而是新启用一个<code>gorouting</code>执行传入的函数</li></ol><p><span style="border-bottom:2px solid red">断续器</span>：</p><ol><li>断续器会间隔一段时间向通道<code>C</code>发送时间</li><li>使用<code>time.NewTicker</code>初始化断续器</li><li>使用<code>Stop</code>方法停止断续器，如果此时字段<code>C</code>存在元素值，那么会保存在那里，等待接收</li><li>断续器适用于定时任务的触发器</li></ol><h1 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h1><h3 id="单向通道与for语句连用"><a href="#单向通道与for语句连用" class="headerlink" title="单向通道与for语句连用"></a>单向通道与for语句连用</h3><p>单向通道的合理应用，对实现类型进行约束<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(strChan &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>, syncChan1 &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, syncChan2 <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">&lt;-syncChan1</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := &lt;-strChan; ok &#123; <span class="comment">//循环判断通道是否关闭，通道关闭后，ok是false的</span></span><br><span class="line">fmt.Println(elem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*遍历通道是第二种方法</span></span><br><span class="line"><span class="comment">for elem := range strChan &#123;</span></span><br><span class="line"><span class="comment">fmt.Println(elem)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">syncChan2 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h3><p>select只能用于通道的发送和接收操作</p><ol><li>在关键字case右边的发送语句或者接收语句中的表达式会先求值</li><li>这里的intChan1和intChan2未初始化，所以传送数据时会阻塞</li><li>如果有多个case满足条件，那么运行时系统会随机选择一个<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> intChan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intChan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> channels = []<span class="keyword">chan</span> <span class="keyword">int</span>&#123;intChan1, intChan2&#125;</span><br><span class="line"><span class="keyword">var</span> numbers = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> getChan(<span class="number">0</span>) &lt;- getNumber(<span class="number">2</span>):</span><br><span class="line">fmt.Println(<span class="string">"1th case is selected"</span>)</span><br><span class="line"><span class="keyword">case</span> getChan(<span class="number">1</span>) &lt;- getNumber(<span class="number">3</span>):</span><br><span class="line">fmt.Println(<span class="string">"2st case is selected"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"Default!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNumber</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"numbers[%d]\n"</span>, i)</span><br><span class="line"><span class="keyword">return</span> numbers[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChan</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"channels[%d]\n"</span>, i)</span><br><span class="line"><span class="keyword">return</span> channels[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果：</span></span><br><span class="line"><span class="comment">channels[0]</span></span><br><span class="line"><span class="comment">numbers[0]</span></span><br><span class="line"><span class="comment">channels[1]</span></span><br><span class="line"><span class="comment">numbers[1]</span></span><br><span class="line"><span class="comment">Default!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="对接收操作的超时限定"><a href="#对接收操作的超时限定" class="headerlink" title="对接收操作的超时限定"></a>对接收操作的超时限定</h3><p>这里使用了<code>Loop</code>标签，因为break语句只能跳出select语句。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">Loop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e, ok := &lt;-intChan:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Received:%d\n"</span>, e)</span><br><span class="line"><span class="comment">// 设置一个500ms到期的定时器</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.NewTimer(time.Millisecond * <span class="number">500</span>).C:</span><br><span class="line">fmt.Println(<span class="string">"Timeout!"</span>)</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line"><span class="comment">// 设置一个500ms到期的定时器，</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">500</span>):</span><br><span class="line">fmt.Println(<span class="string">"Timeout!"</span>)</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">syncChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><h3 id="对定时器的复用"><a href="#对定时器的复用" class="headerlink" title="对定时器的复用"></a>对定时器的复用</h3><p>每次执行都要新建一个timer，浪费资源，我们可以复用定时器。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> timer == <span class="literal">nil</span> &#123;</span><br><span class="line">timer = time.NewTimer(timeout)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 复用定时器</span></span><br><span class="line">timer.Reset(timeout)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><h3 id="断续器"><a href="#断续器" class="headerlink" title="断续器"></a>断续器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"><span class="comment">//两种使用断续器用于定时任务的触发器</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := &lt;-ticker.C; ok &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> intChan &lt;- <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> intChan &lt;- <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> intChan &lt;- <span class="number">3</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="通道类型的转换"><a href="#通道类型的转换" class="headerlink" title="通道类型的转换"></a>通道类型的转换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Golang利用函数声明将双向通道转化为单向通道是GO的语法糖</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">_, ok := <span class="keyword">interface</span>&#123;&#125;(ch1).(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">fmt.Println(<span class="string">"chan int =&gt; &lt;-chan int:"</span>, ok)<span class="comment">//false</span></span><br><span class="line">_, ok = <span class="keyword">interface</span>&#123;&#125;(ch1).(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line">fmt.Println(<span class="string">"chan int =&gt; chan&lt;- int:"</span>, ok)<span class="comment">//false</span></span><br><span class="line">sch := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">_, ok = <span class="keyword">interface</span>&#123;&#125;(sch).(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">fmt.Println(<span class="string">"&lt;-chan int =&gt; chan int:"</span>, ok)<span class="comment">//false</span></span><br><span class="line">rch := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">_, ok = <span class="keyword">interface</span>&#123;&#125;(rch).(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">fmt.Println(<span class="string">"chan&lt;- int =&gt; chan int:"</span>, ok)<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流水线操作"><a href="#流水线操作" class="headerlink" title="流水线操作"></a>流水线操作</h3><p>Go的流水线操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于显示的释放上游通道</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//设置上游通道的缓存，保证下游通到失败时，上游通道也能返回</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">out &lt;- n</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out &lt;- n * n:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(in ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="built_in">len</span>(in))</span><br><span class="line"><span class="comment">// 存储未读的数据</span></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out &lt;- n:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> in &#123;</span><br><span class="line"><span class="comment">// 每个channel分配一个gorouting</span></span><br><span class="line"><span class="keyword">go</span> output(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := gen(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">c1 := sq(in)</span><br><span class="line">c2 := sq(in)</span><br><span class="line">c3 := sq(in)</span><br><span class="line"><span class="comment">//当main的操作完成时，关闭通道</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">out := merge(c1, c2, c3)</span><br><span class="line">fmt.Println(&lt;-out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> channel </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Context</title>
      <link href="/2018/03/28/context/"/>
      <url>/2018/03/28/context/</url>
      <content type="html"><![CDATA[<h1 id="1、Context"><a href="#1、Context" class="headerlink" title="1、Context"></a>1、Context</h1><p>Context变量保存着每个Gorouting的执行状态。在网络编程下，当接收到一个Request请求并处理时，可能会在多个Gorouting中处理，那么这些Gorouting需要共享Request的一些信息；当Request被取消或者超时时，一并将Gorouting也清除。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Deadline：会返回一个超时时间，用来确定是否有时间足够开始工作</li><li>Done：返回一个channel，当Context被取消或者超时时，通道会关闭</li><li>Err：Done通道被关闭后，Err方法表明Context被撤销的原因</li><li>Value：可以让Goruting之间共享数据，参数是key，返回相应的value</li></ul><p>Gorouting和Context都是层层调用的，所以上层的Gorouting有办法关闭下层的Gorouting。<br>context.Background函数能返回Context的根节点——这个Context由接收请求的第一个Gorouting创建。</p><h1 id="2、Context的衍生"><a href="#2、Context的衍生" class="headerlink" title="2、Context的衍生"></a>2、Context的衍生</h1><p>下面这些函数都是接收父节点，并且设置一些状态值，生成子节点并传给下层Gorouting。</p><ul><li>WithCancel：还返回一个Cancel函数，用来控制该节点</li><li>WithDeadline：还返回一个带过期时间的Cancel函数，但是过期时间由<code>parent</code>和<code>deadline</code>决定</li><li>WithTimeout：还返回以一个带超时时间的Cancel函数，表示从现在开始剩余多少时间</li><li>WithValue：返回一个带有数据的子节点，使用<code>Value</code>方法可以返回其值</li></ul><h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gen := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">n++</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():<span class="comment">//判断该节点的Context是否结束</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()<span class="comment">//关闭该节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(<span class="number">50</span>*time.Millisecond))</span><br><span class="line"><span class="comment">//尽管context会过期，但是还是要调用cancel方法，为了避免父context存在太长的时间</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">"sleptout!"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(ctx.Err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> favContextKey <span class="keyword">string</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, k favContextKey)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := ctx.Value(k); v != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Found value:"</span>, v)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Key not found:"</span>, k)</span><br><span class="line">&#125;</span><br><span class="line">k := favContextKey(<span class="string">"language"</span>)</span><br><span class="line">ctx := context.WithValue(context.Background(), k, <span class="string">"Go"</span>)</span><br><span class="line">f(ctx, k)</span><br><span class="line">f(ctx, favContextKey(<span class="string">"color"</span>))</span><br></pre></td></tr></table></figure><h1 id="3、CSE的例子"><a href="#3、CSE的例子" class="headerlink" title="3、CSE的例子"></a>3、CSE的例子</h1><h3 id="userip-go"><a href="#userip-go" class="headerlink" title="userip.go"></a>userip.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从用户请求中解析出其IP地址，并将IP地址绑定在Context上</span></span><br><span class="line"><span class="keyword">package</span> userip</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromRequest</span><span class="params">(req *http.Request)</span><span class="params">(net.IP,error)</span></span>&#123;</span><br><span class="line">ip,_,err:=net.SplitHostPort(req.RemoteAddr)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,fmt.Errorf(<span class="string">"userip:%q is not IP:Port"</span>,req.RemoteAddr)</span><br><span class="line">&#125;</span><br><span class="line">userIP:=net.ParseIP(ip)</span><br><span class="line"><span class="keyword">if</span> userIP==<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,fmt.Errorf(<span class="string">"userip:%q is not IP:Port"</span>,req.RemoteAddr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> userIP,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> key <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userIPKey key = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContext</span><span class="params">(ctx context.Context,userIP net.IP)</span><span class="title">context</span>.<span class="title">Context</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.WithValue(ctx,userIPKey,userIP)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromContext</span><span class="params">(ctx context.Context)</span><span class="params">(net.IP,<span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">userIP,ok:=ctx.Value(userIPKey).(net.IP)</span><br><span class="line"><span class="keyword">return</span> userIP,ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="google-go"><a href="#google-go" class="headerlink" title="google.go"></a>google.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向Google发送请求</span></span><br><span class="line"><span class="keyword">package</span> google</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"book/pkg/context/Google_Web_Search/userip"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Results []Result</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">Title, URL <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>)</span> <span class="params">(Results, error)</span></span> &#123;</span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"https://www.googleapis.com/customsearch/v1?key=XXXX&amp;cx=XXXXXX"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">q := req.URL.Query()</span><br><span class="line">q.Set(<span class="string">"q"</span>, query)</span><br><span class="line"><span class="keyword">if</span> userIP, ok := userip.FromContext(ctx); ok &#123;</span><br><span class="line">q.Set(<span class="string">"userip"</span>, userIP.String())</span><br><span class="line">&#125;</span><br><span class="line">req.URL.RawQuery = q.Encode()</span><br><span class="line"><span class="keyword">var</span> results Results</span><br><span class="line">err = httpDo(ctx, req, <span class="function"><span class="keyword">func</span><span class="params">(resp *http.Response, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">ResponseData <span class="keyword">struct</span> &#123;</span><br><span class="line">Results []<span class="keyword">struct</span> &#123;</span><br><span class="line">TitleNoFormatting <span class="keyword">string</span></span><br><span class="line">URL               <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, res := <span class="keyword">range</span> data.ResponseData.Results &#123;</span><br><span class="line">results = <span class="built_in">append</span>(results, Result&#123;Title: res.TitleNoFormatting, URL: res.URL&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> results, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpDo</span><span class="params">(ctx context.Context, req *http.Request, f <span class="keyword">func</span>(*http.Response, error)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">tr := &amp;http.Transport&#123;&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//HTTP请求的响应调用 f() 函数</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- f(client.Do(req)) &#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line"><span class="keyword">case</span> err := &lt;-c:</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="server-go"><a href="#server-go" class="headerlink" title="server.go"></a>server.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理http请求</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"book/pkg/context/Google_Web_Search/google"</span></span><br><span class="line"><span class="string">"book/pkg/context/Google_Web_Search/userip"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"html/template"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/search"</span>, handleSearch)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSearch</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ctx    context.Context</span><br><span class="line">cancel context.CancelFunc</span><br><span class="line">)</span><br><span class="line">timeout, err := time.ParseDuration(req.FormValue(<span class="string">"timeout"</span>))</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">ctx, cancel = context.WithTimeout(context.Background(), timeout)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctx, cancel = context.WithCancel(context.Background())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">query := req.FormValue(<span class="string">"q"</span>)</span><br><span class="line"><span class="keyword">if</span> query == <span class="string">""</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">"no query"</span>, http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">userIP, err := userip.FromRequest(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, err.Error(), http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ctx = userip.NewContext(ctx, userIP)</span><br><span class="line"></span><br><span class="line">start := time.Now()</span><br><span class="line">results, err := google.Search(ctx, query)</span><br><span class="line">elapsed := time.Since(start)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := resultsTemplate.Execute(w, <span class="keyword">struct</span> &#123;</span><br><span class="line">Results          google.Results</span><br><span class="line">Timeout, Elapsed time.Duration</span><br><span class="line">&#125;&#123;</span><br><span class="line">Results: results,</span><br><span class="line">Timeout: timeout,</span><br><span class="line">Elapsed: elapsed,</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resultsTemplate = template.Must(template.New(<span class="string">"results"</span>).Parse(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head/&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;ol&gt;</span></span><br><span class="line"><span class="string">  &#123;&#123;range .Results&#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;li&gt;&#123;&#123;.Title&#125;&#125; - &lt;a href="&#123;&#123;.URL&#125;&#125;"&gt;&#123;&#123;.URL&#125;&#125;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/ol&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;&#123;&#123;len .Results&#125;&#125; results in &#123;&#123;.Elapsed&#125;&#125;; timeout &#123;&#123;.Timeout&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> package </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>模拟pipe</title>
      <link href="/2018/03/27/pipe/"/>
      <url>/2018/03/27/pipe/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="1、匿名管道"><a href="#1、匿名管道" class="headerlink" title="1、匿名管道"></a>1、匿名管道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os/exec"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCmd</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> useBufIO=<span class="literal">false</span></span><br><span class="line">cmd0 := exec.Command(<span class="string">"echo"</span>, <span class="string">"-n"</span>, <span class="string">"My first command comes from golang."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个输出通道</span></span><br><span class="line">stdout0, err := cmd0.StdoutPipe()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:Counld't obtain the stdout pipe from command NO.0:%s\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Start</span></span><br><span class="line"><span class="keyword">if</span> err := cmd0.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:The command NO.0 can not be startup:%s\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用read方法获取命令</span></span><br><span class="line"><span class="keyword">var</span> output0 = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !useBufIO &#123;</span><br><span class="line"><span class="keyword">var</span> outputBuf0 bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">tempOutput0 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">n, err := stdout0.Read(tempOutput0)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:Couldn't read data from the pipe:%s\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">outputBuf0.Write(tempOutput0[:n])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, outputBuf0.String())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 缓存读取器</span></span><br><span class="line"><span class="keyword">var</span> isPrefix <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">outputBuf0 := bufio.NewReaderSize(stdout0, <span class="number">5</span>)</span><br><span class="line">output0, isPrefix, err = outputBuf0.ReadLine()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:Couldn't read data from the pipe:%s\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, <span class="keyword">string</span>(output0))</span><br><span class="line"><span class="keyword">if</span> isPrefix == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过管道将输出值作为另一个命令的输入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCmdPipe</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> outputBuf1 bytes.Buffer</span><br><span class="line"><span class="keyword">var</span> outputBuf2 bytes.Buffer</span><br><span class="line">cmd1:=exec.Command(<span class="string">"ps"</span>,<span class="string">"aux"</span>)</span><br><span class="line">cmd2:=exec.Command(<span class="string">"grep"</span>,<span class="string">"apipe"</span>)</span><br><span class="line"><span class="comment">//将所有的输出内容都记录到这里</span></span><br><span class="line">cmd1.Stdout=&amp;outputBuf1</span><br><span class="line"><span class="keyword">if</span> err:=cmd1.Start();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:The frist command can not be startup:%s\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cmd1结束运行之前，wait()调用会一直阻塞</span></span><br><span class="line"><span class="keyword">if</span> err:=cmd1.Wait();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:Can't wait for the first command:%s\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd2.Stdin=&amp;outputBuf1</span><br><span class="line">cmd2.Stdout=&amp;outputBuf2</span><br><span class="line"><span class="keyword">if</span> err:=cmd2.Start();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:The second command can not be startup:%s\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err:=cmd2.Wait();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:Cant't wait for the second command:%s\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>,outputBuf2.String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">runCmd()</span><br><span class="line">fmt.Println()</span><br><span class="line">runCmdPipe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、命名管道（文件管道）和内存管道"><a href="#2、命名管道（文件管道）和内存管道" class="headerlink" title="2、命名管道（文件管道）和内存管道"></a>2、命名管道（文件管道）和内存管道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于文件的管道，其中一端未绪前阻塞另一端的进程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileBasePipe</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader,writer,err:=os.Pipe()</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:Create named pipe failed:%s\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">outPut:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">100</span>)</span><br><span class="line">n,err:=reader.Read(outPut)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:Could't read data from the named pipe: %s\n"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Readed %d byte(s)[based pipe]\n"</span>,n)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(outPut))</span><br><span class="line">&#125;()</span><br><span class="line">inPut:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">26</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">65</span>;i&lt;<span class="number">90</span>;i++&#123;</span><br><span class="line">inPut[i<span class="number">-65</span>]=<span class="keyword">byte</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">n,err:=writer.Write(inPut)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error: Couldn't write data to the named pipe: %s\n"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Written %d byte(s).[based pipe]\n"</span>,n)</span><br><span class="line">time.Sleep(<span class="number">200</span>*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于内存的有原子性操作的管道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memoryBasePipe</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader, writer := io.Pipe()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">outPut := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">n,err := reader.Read(outPut)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:Read fatal: %s\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Readed %d byte(s)[based pipe]\n"</span>, n)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(outPut))</span><br><span class="line">&#125;()</span><br><span class="line">inPut:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">26</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">65</span>;i&lt;<span class="number">90</span>;i++&#123;</span><br><span class="line">inPut[i<span class="number">-65</span>]=<span class="keyword">byte</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">n, err := writer.Write(inPut)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error:Write fatal: %s\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Written %d byte(s).[based pipe]\n"</span>, n)</span><br><span class="line">time.Sleep(<span class="number">200</span>*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileBasePipe()</span><br><span class="line">fmt.Println()</span><br><span class="line">memoryBasePipe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 管道 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>panic和recover</title>
      <link href="/2018/03/27/panic%E5%92%8Crecover/"/>
      <url>/2018/03/27/panic%E5%92%8Crecover/</url>
      <content type="html"><![CDATA[<a id="more"></a><ul><li>panic用于停止当前的控制流程并引发一个恐慌</li><li>recover用于使当前程序从恐慌中恢复并重新获得流程控制权</li><li>recover函数的结果是一个interface{}类型，如果结果不是nil，那么就有问题啦！</li><li>recover和defer应该配合使用</li></ul><p>我们看下标准库fmt中的Token是怎么处理的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ss)</span> <span class="title">Token</span><span class="params">(skipSpace <span class="keyword">bool</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="params">(tok []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;<span class="comment">//判断recover函数的结果是否为nil</span></span><br><span class="line"><span class="keyword">if</span> se, ok := e.(scanError); ok &#123;<span class="comment">//判断panic的类型</span></span><br><span class="line">err = se.err</span><br><span class="line"><span class="comment">//如果panic是这个类型，那么这个值就会赋值给结果值变量err，</span></span><br><span class="line"><span class="comment">//这样做到了精确控制panic，将已经recover的恐慌当作常规结果返回</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(e)</span><br><span class="line"><span class="comment">//否则恐慌会再次引发</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>恐慌被传递到调用栈的最顶层的结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: An intended fatal error! [recovered]</span><br><span class="line"><span class="built_in">panic</span>: An intended fatal error!</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>defer和闭包</title>
      <link href="/2018/03/27/defer/"/>
      <url>/2018/03/27/defer/</url>
      <content type="html"><![CDATA[<ul><li>只有当defer语句执行完，外围函数才会返回</li><li>外围函数如果引发了<code>panic</code>，<code>defer</code>语句也会执行完panic才会扩散</li><li>在defer执行的时候，针对defer语句的表达式会被压栈，等到外围函数结束时，才依次从栈中取出</li><li>defer语句要放在panic之前才有效果</li></ul><h1 id="1、闭包的概念"><a href="#1、闭包的概念" class="headerlink" title="1、闭包的概念"></a>1、闭包的概念</h1><h3 id="1-传值："><a href="#1-传值：" class="headerlink" title="1.传值："></a>1.传值：</h3><p>因为闭包其实就一个自治的生态系统，如果你将m的值先传进去，那么闭包外的改变不和闭包有关。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line">m=<span class="number">10</span></span><br><span class="line">fmt.Println(m)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;(m)</span><br><span class="line">m=<span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><h3 id="2-不传值："><a href="#2-不传值：" class="headerlink" title="2.不传值："></a>2.不传值：</h3><p>如果不传值的话，那么defer先把闭包压栈中，然后将m的值传入闭包中，那么因为是最后传值，所以传入的是对m修改后的值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line">m=<span class="number">10</span></span><br><span class="line">fmt.Println(m)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;()</span><br><span class="line">m=<span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></p><h1 id="2、defer的值传递"><a href="#2、defer的值传递" class="headerlink" title="2、defer的值传递"></a>2、defer的值传递</h1><h3 id="1-函数参数是值传递："><a href="#1-函数参数是值传递：" class="headerlink" title="1.函数参数是值传递："></a>1.函数参数是值传递：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">int</span></span><br><span class="line">m=<span class="number">10</span></span><br><span class="line">fmt.Println(m)</span><br><span class="line"><span class="keyword">defer</span> Print(m)</span><br><span class="line">m=<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(m <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">fmt.Println(m.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><h3 id="2-如果用指针作为函数参数："><a href="#2-如果用指针作为函数参数：" class="headerlink" title="2.如果用指针作为函数参数："></a>2.如果用指针作为函数参数：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> m *<span class="keyword">int</span></span><br><span class="line">m=<span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*m=<span class="number">10</span></span><br><span class="line">fmt.Println(*m)</span><br><span class="line"><span class="keyword">defer</span> Print(m)</span><br><span class="line">*m=<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(m <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">fmt.Println(*m.(*<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="3、有名和匿名"><a href="#3、有名和匿名" class="headerlink" title="3、有名和匿名"></a>3、有名和匿名</h1><h3 id="匿名返回值"><a href="#匿名返回值" class="headerlink" title="匿名返回值"></a>匿名返回值</h3><p>这时的返回值是在return执行时声明的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"b return:"</span>, b()) <span class="comment">// 打印结果为 b return: 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Println(<span class="string">"b defer2:"</span>, i) <span class="comment">// 打印结果为 b defer2: 2</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Println(<span class="string">"b defer1:"</span>, i) <span class="comment">// 打印结果为 b defer1: 1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> i </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="有名返回值"><a href="#有名返回值" class="headerlink" title="有名返回值"></a>有名返回值</h3><p>返回值在函数被声明时就声明了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a return:"</span>, a()) <span class="comment">// 打印结果为 a return: 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Println(<span class="string">"a defer2:"</span>, i) <span class="comment">// 打印结果为 a defer2: 2</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Println(<span class="string">"a defer1:"</span>, i) <span class="comment">// 打印结果为 a defer1: 1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4、容易入的”坑”"><a href="#4、容易入的”坑”" class="headerlink" title="4、容易入的”坑”"></a>4、容易入的”坑”</h1><h3 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span><span class="params">(result <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">result++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解：<br><code>return 0</code>并不是原子操作,应该写成<code>result=0</code>,<code>return</code>;所以结果是<code>1</code>。</p></blockquote><h3 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span><span class="params">(r <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">r=r+<span class="number">5</span></span><br><span class="line">&#125;(r)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解：<br>先<code>r=1</code>,再<code>return</code>,但是闭包中是值传递,不会影响r的值,所以结果是<code>1</code>。</p></blockquote>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> defer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>职责链</title>
      <link href="/2018/03/27/%E8%81%8C%E8%B4%A3%E9%93%BE/"/>
      <url>/2018/03/27/%E8%81%8C%E8%B4%A3%E9%93%BE/</url>
      <content type="html"><![CDATA[<a id="more"></a><h1>  </h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。<br>将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</p><ul><li>链对象包含当前职责对象以及下一个职责链</li><li>职责对象提供接口表示能否处理对应请求</li><li>职责对象提供处理函数处理相关</li></ul><p><img src="/images/responsibity.PNG" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求接口</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">interface</span> &#123;</span><br><span class="line">SetSuccessor(Manager)</span><br><span class="line">HandleRequest(<span class="keyword">string</span>,<span class="keyword">int</span>)<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求链</span></span><br><span class="line"><span class="keyword">type</span> RequestChain <span class="keyword">struct</span> &#123;</span><br><span class="line">successor Manager <span class="comment">// 继承者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RequestChain)</span> <span class="title">SetSuccessor</span><span class="params">(i Manager)</span></span> &#123;</span><br><span class="line">r.successor = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经理</span></span><br><span class="line"><span class="keyword">type</span> jingli <span class="keyword">struct</span> &#123;</span><br><span class="line">RequestChain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Newjingli</span><span class="params">()</span>*<span class="title">jingli</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;jingli&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *jingli)</span> <span class="title">HandleRequest</span><span class="params">(name <span class="keyword">string</span>,num <span class="keyword">int</span>)</span><span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"请假"</span> &amp;&amp; num &lt;= <span class="number">2</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"经理允许%s%d\n"</span>,name,num)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> j.successor!=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"经理不允许%s%d\n"</span>, name, num)</span><br><span class="line"><span class="keyword">return</span> j.successor.HandleRequest(name,num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">type</span> zongjingli <span class="keyword">struct</span> &#123;</span><br><span class="line">RequestChain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Newzongjingli</span><span class="params">()</span>*<span class="title">zongjingli</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;zongjingli&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *zongjingli)</span> <span class="title">HandleRequest</span><span class="params">(name <span class="keyword">string</span>,num <span class="keyword">int</span>)</span><span class="title">bool</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> name == <span class="string">"请假"</span> &amp;&amp; num &lt;= <span class="number">5</span>&#123;</span><br><span class="line"> fmt.Printf(<span class="string">"总经理允许%s%d\n"</span>, name, num)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> z.successor != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"总经理不允许%s%d\n"</span>, name, num)</span><br><span class="line"><span class="keyword">return</span> z.successor.HandleRequest(name, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总监</span></span><br><span class="line"><span class="keyword">type</span> zongjian <span class="keyword">struct</span> &#123;</span><br><span class="line">RequestChain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Newzongjian</span><span class="params">()</span>*<span class="title">zongjian</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;zongjian&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *zongjian)</span> <span class="title">HandleRequest</span><span class="params">(name <span class="keyword">string</span>,num <span class="keyword">int</span>)</span><span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"请假"</span> &amp;&amp; num &lt;= <span class="number">5</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"总监允许%s%d\n"</span>, name, num)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> z.successor != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"总监不允许%s%d\n"</span>, name, num)</span><br><span class="line"><span class="keyword">return</span> z.successor.HandleRequest(name, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"加薪"</span> &amp;&amp; num &lt;= <span class="number">500</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"总监允许%s%d\n"</span>, name, num)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> z.successor != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"总监不允许%s%d\n"</span>, name, num)</span><br><span class="line"><span class="keyword">return</span> z.successor.HandleRequest(name, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">c1:=Newjingli()</span><br><span class="line">c2:=Newzongjingli()</span><br><span class="line">c3:=Newzongjian()</span><br><span class="line">c1.SetSuccessor(c2)</span><br><span class="line">c2.SetSuccessor(c3)</span><br><span class="line">c1.HandleRequest(<span class="string">"请假"</span>,<span class="number">2</span>)</span><br><span class="line">c1.HandleRequest(<span class="string">"请假"</span>,<span class="number">4</span>)</span><br><span class="line">c1.HandleRequest(<span class="string">"加薪"</span>,<span class="number">400</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>笔记</title>
      <link href="/2018/03/27/%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/03/27/%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><ol><li>golang中值类型的零值为空或者是0，指针类型的零值为nil。</li><li>switch的类型断言必须遵守类型断言的规则</li><li>switch的类型断言中不能出现<code>fallthrough</code></li><li>当使用<code>for range</code>迭代一个通道值为<code>nil</code>时，会永远阻塞在<code>for</code>语句上</li></ol>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>方法</title>
      <link href="/2018/03/27/method/"/>
      <url>/2018/03/27/method/</url>
      <content type="html"><![CDATA[<a id="more"></a><h1 id="可寻址值和不可寻址值调用方法"><a href="#可寻址值和不可寻址值调用方法" class="headerlink" title="可寻址值和不可寻址值调用方法"></a>可寻址值和不可寻址值调用方法</h1><h3 id="示例一："><a href="#示例一：" class="headerlink" title="示例一："></a>示例一：</h3><p>对于一个非指针类型，它关联的方法集中只包含它的值方法。对于一个指针类型，它关联的方法集中既包含值方法和指针方法。</p><h2 id="但是非指针类型也是可以调到指针方法的，因为Go进行了自动转换"><a href="#但是非指针类型也是可以调到指针方法的，因为Go进行了自动转换" class="headerlink" title="但是非指针类型也是可以调到指针方法的，因为Go进行了自动转换"></a>但是非指针类型也是可以调到指针方法的，因为Go进行了自动转换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指针类型的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *data)</span><span class="title">Print</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"name:"</span>,d.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 值类型的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span><span class="title">Print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"name2:"</span>,d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Printer <span class="keyword">interface</span> &#123;</span><br><span class="line">Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p Printer = &amp;data&#123;<span class="string">"one"</span>&#125;</span><br><span class="line">p.Print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// p是一个指针类型</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]data&#123;<span class="string">"x"</span>:&#123;<span class="string">"two"</span>&#125;&#125;</span><br><span class="line">n:=m1[<span class="string">"x"</span>]</span><br><span class="line">n.Print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要！</span></span><br><span class="line"><span class="comment">// n是值类型，但是可以调用指针类型的方法，Go进行了自动转换</span></span><br><span class="line"><span class="comment">// n.Print()  ==  (&amp;n).Print()</span></span><br><span class="line"></span><br><span class="line">m2:=<span class="keyword">map</span>[<span class="keyword">string</span>]*data&#123;<span class="string">"x"</span>:&#123;<span class="string">"three"</span>&#125;&#125;</span><br><span class="line">n2:=m2[<span class="string">"x"</span>]</span><br><span class="line">n2.Print2()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要！</span></span><br><span class="line"><span class="comment">// n2是指针类型，但是可以调用值类型的方法，Go进行了自动转换</span></span><br><span class="line"><span class="comment">// n2.Print2()  ==  (*n2).Print2()</span></span><br><span class="line"></span><br><span class="line">s:=[]data&#123;</span><br><span class="line">&#123;<span class="string">"four"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">s[<span class="number">0</span>].Print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于结构体类型的`slice`是指针类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例二："><a href="#示例二：" class="headerlink" title="示例二："></a>示例二：</h3><h2 id="receiver变量其实就是源值的一个复制品。如果receiver是值类型，那么自然没有办法修改源值；如果receiver是指针类型，那么指针值指向的就是源值的地址，就能够修改源值。"><a href="#receiver变量其实就是源值的一个复制品。如果receiver是值类型，那么自然没有办法修改源值；如果receiver是指针类型，那么指针值指向的就是源值的地址，就能够修改源值。" class="headerlink" title="receiver变量其实就是源值的一个复制品。如果receiver是值类型，那么自然没有办法修改源值；如果receiver是指针类型，那么指针值指向的就是源值的地址，就能够修改源值。"></a>receiver变量其实就是源值的一个复制品。如果receiver是值类型，那么自然没有办法修改源值；如果receiver是指针类型，那么指针值指向的就是源值的地址，就能够修改源值。</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *myInt)</span><span class="title">add2</span><span class="params">(another <span class="keyword">int</span>)</span><span class="title">myInt</span></span>&#123;</span><br><span class="line">*i=*i+myInt(another)</span><br><span class="line"><span class="keyword">return</span> *i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 值类型方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i myInt)</span><span class="title">add</span><span class="params">(another <span class="keyword">int</span>)</span><span class="title">myInt</span></span>&#123;</span><br><span class="line">i=i+myInt(another)</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">i1:=myInt(<span class="number">1</span>)</span><br><span class="line">i2:=i1.add(<span class="number">2</span>)</span><br><span class="line">fmt.Println(i1,i2)</span><br><span class="line"><span class="comment">// 结果是：1,3</span></span><br><span class="line">i2=i1.add2(<span class="number">2</span>)</span><br><span class="line">fmt.Println(i1,i2)</span><br><span class="line"><span class="comment">// 结果是：3,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>函数</title>
      <link href="/2018/03/26/%E5%87%BD%E6%95%B0/"/>
      <url>/2018/03/26/%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<a id="more"></a><h1 id="将函数当作参数，进行二元操作"><a href="#将函数当作参数，进行二元操作" class="headerlink" title="将函数当作参数，进行二元操作"></a>将函数当作参数，进行二元操作</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> binaryOperation <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><span class="params">(<span class="keyword">int</span>,error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">operate</span><span class="params">(op1 <span class="keyword">int</span>,op2 <span class="keyword">int</span>,op binaryOperation)</span><span class="params">(result <span class="keyword">int</span>,err error)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> op==<span class="literal">nil</span>&#123;</span><br><span class="line">err=errors.New(<span class="string">"invaild functions!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> op(op1,op2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户可以自己实现除法操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(op1 <span class="keyword">int</span>,op2 <span class="keyword">int</span>)</span><span class="params">(result <span class="keyword">int</span>,err error)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> op2==<span class="number">0</span>&#123;</span><br><span class="line">err=errors.New(<span class="string">"divide by zero!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">result=op1/op2</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">result,err=operate(<span class="number">0</span>,<span class="number">2</span>,divide)</span><br><span class="line">fmt.Printf(<span class="string">"result：%v，err：%v\n"</span>,result,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Readme</title>
      <link href="/2018/03/26/gorouting_thread/"/>
      <url>/2018/03/26/gorouting_thread/</url>
      <content type="html"><![CDATA[<p><a href="https://www.processon.com/mindmap/5aa9071ee4b0262b8b37e102" target="_blank" rel="noopener">go并发思维导图</a></p><h1 id="Go的线程模型"><a href="#Go的线程模型" class="headerlink" title="Go的线程模型"></a>Go的线程模型</h1><p>Go不推荐使用共享内存的方式传递数据，而推荐使用channel（或称“通道”）在多个goroutine之间传递数据，同时保证整个过程的并发安全性。不过，作为可选方法，Go依然提供了一些传统的同步方法（比如互斥量、条件变量等）。</p><p>在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。我们可以将goroutine看作是Go特有的应用程序线程。但是，goroutine背后的支撑体系远没有这么简单。</p><p>说起Go的线程实现模型，有三个必知的核心元素，它们支撑起了这个模型的主框架。</p><ul><li><p>M：machine的缩写。一个M代表一个内核线程，或者“工作线程”。</p></li><li><p>P：processor的缩写。一个P代表执行一个Go代码片段所必需的资源（或称“上下文环境”）。</p></li><li><p>G：goroutine的缩写。一个G代表一个Go代码片段。前者是对后者的一种封装。</p></li></ul><p>简单来说，一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境）。每个P都会包含一个可运行的G的队列（runq）。该队列中的G会被依次传递给与本地P关联的M，并获得运行时机。在这里，我把运行当前G的那个M称为“当前M”，并把与当前M关联的那个P称为“本地P”。后面我会以此为术语进行描述。</p><p>从宏观上看，M、P和G之间的联系如图2-1所示，但是实际关系要比这幅图所展示的关系复杂很多。不过，请先不用理会这里所说的复杂关系，让我们把焦点扩大一些，看看它们与内核调度实体（KSE）之间的关系是怎样的，如图2-2所示。</p><p><img src="\images\2-1.png" alt="图2-1"></p><h5 id="图2-1"><a href="#图2-1" class="headerlink" title="图2-1"></a>图2-1</h5><p><img src="\images\2-2.png" alt="图2-2"></p><h5 id="图2-2"><a href="#图2-2" class="headerlink" title="图2-2"></a>图2-2</h5><p>可以看到，M与KSE之间总是一对一的关系，一个M能且仅能代表一个内核线程。Go的运行时系统（runtime system）用M代表一个内核调度实体。M与KSE之间的关联非常稳固，一个M在其生命周期内，会且仅会与一个KSE产生关联。相比之下，M与P、P与G之间的关联都是易变的，它们之间的关系会在实际调度的过程中改变。此外，M与G之间也会建立关联，因为一个G终归会由一个M来负责运行；它们之间的关联会由P来牵线。注意，由于M、P和G之间的关系在实际调度过程中多变，图2-2中的可能关联仅能作为一般性的示意。</p><p>至此，你已经知道了这些核心实体之间可能存在的关系。Go的运行时系统会对这些实体的实例进行实时管理和调度。接下来，我会专门对此进行介绍。现在，让我们再次聚焦，看一看在这些实体内部都有哪些值得关注的细节。</p><h3 id="M（内核线程）"><a href="#M（内核线程）" class="headerlink" title="M（内核线程）"></a>M（内核线程）</h3><p>一个M代表了一个内核线程。在大多数情况下，创建一个新M的原因是没有足够的M来关联P并运行其中可运行的G。不过，在运行时系统执行系统监控或垃圾回收等任务的时候，也会导致新M的创建。M的部分结构如图2-3所示。</p><p><img src="\images\2-3.png" alt="图2-3"></p><h5 id="图2-3-M的结构（部分）"><a href="#图2-3-M的结构（部分）" class="headerlink" title="图2-3　M的结构（部分）"></a>图2-3　M的结构（部分）</h5><p>M结构中的字段众多，这里只挑选了几个最重要的字段。列表中，每一行都展示了一个字段，左边是字段名，右边是字段类型。其中，字段<code>g0</code>表示一个特殊的goroutine。这个goroutine是Go运行时系统在启动之初创建的，用于执行一些运行时任务。字段<code>mstartfn</code>表示M的起始函数，这个函数其实就是我们在编写go语句时携带的那个函数。字段<code>curg</code>会存放当前M正在运行的那个G的指针，而字段<code>p</code>的值则会指向与当前M相关联的那个P。<code>mstartfn</code>、<code>curg</code>和<code>p</code>最能体现当前M的即时情况。此外，字段<code>nextp</code>用于暂存与当前M有潜在关联的P。让调度器将某个P赋给某个M的操作由<code>nextp</code>字段控制，称为对M和P的预联。运行时系统有时候会把刚刚重新启用的M和已与它预联的那个P关联在一起，这也是nextp字段的主要作用。字段<code>spinning</code>是<code>bool</code>类型的，它用于表示这个M是否正在寻找可运行的G。在寻找过程中，M会处于自旋状态。这也是该字段名的由来。Go运行时系统可以把一个M和一个G锁定在一起。一旦锁定，这个M就只能运行这个G，这个G也只能由该M运行。标准库代码包runtime中的函数<code>LockOSThread</code>和<code>UnlockOSThread</code>，也为我们提供了锁定和解锁的具体方法。M的字段<code>lockedg</code>表示的就是与当前M锁定的那个G（如果有的话）。</p><p>M在创建之初，会被加入全局的M列表（<code>runtime.allm</code>）中。这时，它的起始函数和预联的P也会被设置。最后，运行时系统会为这个M专门创建一个新的内核线程并与之相关联。如此一来，这个M就为执行G做好了准备。其中，起始函数仅当运行时系统要用此M执行系统监控或垃圾回收等任务的时候才会被设置。而这里的全局M列表其实并没有什么特殊的意义。运行时系统在需要的时候，会通过它获取到所有M的信息。同时，它也可以防止M被当作垃圾回收掉。</p><p>在新M被创建之后，Go运行时系统会先对它进行一番初始化，其中包括对自身所持的栈空间以及信号处理方面的初始化。在这些初始化工作都完成之后，该M的起始函数会被执行（如果存在的话）。注意，如果这个起始函数代表的是系统监控任务的话，那么该M会一直执行它，而不会继续后面的流程。否则，在起始函数执行完毕之后，当前M将会与那个预联的P完成关联，并准备执行其他任务。M会依次在多处寻找可运行的G并运行它。这一过程也是调度的一部分。有了M，Go程序的并发运行基础才得以形成。</p><p>运行时系统管辖的M（或者说<code>runtime.allm</code>中的M）有时候也会被停止，比如在运行时系统执行垃圾回收任务的过程中。运行时系统在停止M的时候，会把它放入调度器的空闲M列表（<code>runtime.sched.midle</code>）。这很重要，因为在需要一个未被使用的M时，运行时系统会先尝试从该列表中获取。M是否空闲，仅以它是否存在于调度器的空闲M列表中为依据。</p><p>单个Go程序所使用的M的最大数量是可以设置的。Go程序运行的时候会先启动一个引导程序，这个引导程序会为其运行建立必要的环境。在初始化调度器的时候，它会对M的最大数量进行初始设置，这个初始值是10 000。也就是说，一个Go程序最多可以使用10 000个M。这就意味着，最多可以有10 000个内核线程服务于当前的Go程序。请注意，这里说的是最理想的情况；由于操作系统内核对进程的虚拟内存的布局控制以及大小限制，如此量级的线程可能很难共存。从这个角度看，Go本身对于线程数量的限制几乎可以忽略。</p><p>除了上述初始设置之外，我们也可以在Go程序中对该限制进行设置。为了达到此目的，你需要调用标准库代码包runtime/debug中的<code>SetMaxThreads</code>函数，并提供新的M最大数量。<code>runtime/debug.SetMaxThreads</code>函数在执行完成后，会把旧的M最大数量作为结果值返回。非常重要的一点是，如果你在调用<code>runtime/debug.SetMaxThreads</code>函数时给定的新值比当时M的实际数量还要小，运行时系统就会立即引发一个运行时恐慌。所以，你要非常谨慎地使用这个函数。请记住，如果真的需要设置M的最大数量，那么越早调用<code>runtime/debug.SetMaxThreads</code>函数越好。对于它的设定值，你也要仔细斟酌。</p><h3 id="P（执行一个Go代码片段所必需的资源）"><a href="#P（执行一个Go代码片段所必需的资源）" class="headerlink" title="P（执行一个Go代码片段所必需的资源）"></a>P（执行一个Go代码片段所必需的资源）</h3><p>P是G能够在M中运行的关键。Go的运行时系统会适时地让P与不同的M建立或断开关联，以使P中的那些可运行的G能够及时获得运行时机，这与操作系统内核在CPU之上实时地切换不同的进程或线程的情形类似。</p><p>改变单个Go程序间接拥有的P的最大数量有两种方法。第一种方法，调用函数<code>runtime.GOMAXPROCS</code>并把想要设定的数量作为参数传入。第二种方法，在Go程序运行前设置环境变量<code>GOMAXPROCS</code>的值。P的最大数量实际上是对程序中并发运行的G的规模的一种限制。P的数量即为可运行G的队列的数量。一个G在被启用后，会先被追加到某个P的可运行G队列中，以等待运行时机。一个P只有与一个M关联在一起时，才会使其可运行G队列中的G有机会运行。不过，设置P的最大数量只能限制住P的数量，而对G和M的数量没有任何约束。当M因系统调用而阻塞（更确切地说，是它运行的G进入了系统调用）的时候，运行时系统会把该M和与之关联的P分离开来。这时，如果这个P的可运行G队列中还有未被运行的G，那么运行时系统就会找到一个空闲M，或创建一个新的M，并与该P关联以满足这些G的运行需要。因此，M的数量在很多时候也都会比P多。而G的数量，一般取决于Go程序本身。</p><p>在Go程序启动之初，引导程序会在初始化调度器时，对P的最大数量进行设置。这里的默认值会与当前CPU的总核心数相同。一旦发现环境变量<code>GOMAXPROCS</code>的值大于0，引导程序就会认为我们想要对P的最大数量进行设置。它会先检查一下此值的有效性：</p><p>如果不大于预设的硬性上限值（256），就认为是有效的，否则就会被这个硬性上限值取代。也就是说，最终的P的最大数量值绝不会比硬性上限值大。硬性上限值是256的原因是，Go目前还不能保证在256多个P同时存在的情形下仍然保持高效。不过，这个硬性上限值并不是永久的，它可能会在未来改变。</p><p>注意，虽然Go并未对何时调用<code>runtime.GOMAXPROCS</code>函数作限制，但是该函数调用的执行会暂时让所有的P都脱离运行状态，并试图阻止任何用户级别的G的运行。只有在新的P最大数量设定完成之后，运行时系统才开始陆续恢复它们。这对于程序的性能是非常大的损耗。所以，你最好只在Go程序的<code>main</code>函数的最前面调用<code>runtime.GOMAXPROCS</code>函数。当然，不在程序中改变P的最大数量最好不过，实际上在大多数情况下也无需改变。</p><p>确定P的最大数量之后，运行时系统会根据这个数值重整全局的P列表（<code>runtime. allp</code>）。与全局M列表类似，该列表中包含了当前运行时系统创建的所有P。运行时系统会把这些P中的可运行G全部取出，并放入调度器的可运行G队列中。这是调整全局P列表的一个重要前提。被转移的那些G，会在以后经由调度再次放入某个P的可运行G队列。</p><p>与空闲M列表类似，运行时系统中也存在一个调度器的空闲P列表（<code>runtime.sched.pidle</code>）。当一个P不再与任何M关联的时候，运行时系统就会把它放入该列表；而当运行时系统需要一个空闲的P关联某个M的话，会从此列表中取出一个。注意，P进入空闲P列表的一个前提条件是它的可运行G列表必须为空。例如，在重整全局P列表的时候，P在被清空可运行G队列之后，才会被放入空闲P列表。</p><p>与M不同，P本身是有状态的，可能具有的状态如下。</p><ul><li><p>Pidle 此状态表明当前P未与任何M存在关联。</p></li><li><p>Prunning 此状态表明当前P正在与某个M关联。</p></li><li><p>Psyscall 此状态表明当前P中的运行的那个G正在进行系统调用。</p></li><li><p>Pgcstop 此状态表明运行时系统需要停止调度。例如，运行时系统在开始垃圾回收的某些步骤前，就会试图把全局P列表中的所有P都置于此状态。</p></li><li><p>Pdead 此状态表明当前P已经不会再被使用。如果在Go程序运行的过程中，通过调用<code>runtime.GOMAXPROCS</code>函数减少了P的最大数量，那么多余的P就会被运行时系统置于此状态。</p></li></ul><p>P在创建之初的状态是<code>Pgcstop</code>，虽然这并不意味着运行时系统要在这时进行垃圾回收。不过，P处于这一初始状态的时间会非常短暂。在紧接着的初始化之后，运行时系统会将其状态设置为Pidle，并放入调度器的空闲P列表。图2-4描绘了P在各个状态之间进行流转的具体情况。</p><p><img src="\images\2-4.png" alt="图2-4"></p><h5 id="图2-4-P的状态转换"><a href="#图2-4-P的状态转换" class="headerlink" title="图2-4　P的状态转换"></a>图2-4　P的状态转换</h5><p>可以看到，非<code>Pdead</code>状态的P都会在运行时系统欲停止调度时被置于Pgcstop状态。不过，等到需要重启调度的时候（如垃圾回收结束后），它们并不会被恢复至原有状态，而会被统一地转换为<code>Pidle</code>状态。也就是说，它们会被放到同一起跑线上，并公平地接受再次调度。另一方面，非<code>Pgcstop</code>状态的P都可能因全局P列表的缩小而被认为是多余的，并被置于<code>Pdead</code>状态。不过，我们并不用担心其中的G会失去归宿。因为，在P被转换为<code>Pdead</code>状态之前，其可运行G队列中的G都会被转移到调度器的可运行G队列，而它的自由G列表中的G也都会被转移到调度器的自由G列表中。</p><p>正如前面所述，每个P中除了一个可运行G队列外，还都包含一个自由G列表。这个列表中包含了一些已经运行完成的G。随着运行完成的G的增多，该列表可能会很长。如果它增长到一定程度，运行时系统就会把其中的部分G转移到调度器的自由G列表中。另一方面，当使用<code>go</code>语句启用一个G的时候，运行时系统会先试图从相应P的自由G列表中获取一个现成的G，来封装这个<code>go</code>语句携带的函数（也称<code>go</code>函数），仅当获取不到这样一个G的时候才有可能创建一个新的G。考虑到相应P的自由G列表为空而获取不到自由G的情况，运行时系统会在发现其中的自由G太少时，预先尝试从调度器的自由G列表中转移过来一些G。如此一来，只有在调度器的自由G列表也弹尽粮绝的时候，才会有新的G被创建。这在很大程度上提高了G的复用率。</p><p>在P的结构中，可运行G队列和自由G列表是最重要的两个成员。至少对于Go语言的使用者来说是这样。它们间接地体现了运行时系统对G的调度情况。下面就对Go并发模型中的G进行介绍。</p><h3 id="G（Go代码片段）"><a href="#G（Go代码片段）" class="headerlink" title="G（Go代码片段）"></a>G（Go代码片段）</h3><p>一个G就代表一个<code>goroutine</code>（或称Go例程），也与go函数相对应。作为编程人员，我们只是使用go语句向Go的运行时系统提交了一个并发任务，而Go的运行时系统则会按照我们的要求并发地执行它。</p><p>Go的编译器会把go语句变成对内部函数<code>newproc</code>的调用，并把go函数及其参数都作为参数传递给这个函数。这也是你应该了解的第一件与go语句有关的事。其实它并不神秘，只是一种递送并发任务的方法而已。</p><p>运行时系统在接到这样一个调用之后，会先检查go函数及其参数的合法性，然后试图从本地P的自由G列表和调度器的自由G列表获取可用的G，如果没有获取到，就新建一个G。与M和P相同，运行时系统也持有一个G的全局列表（<code>runtime.allgs</code>）。新建的G会在第一时间被加入该列表。类似地，这个全局列表的主要作用是：集中存放当前运行时系统中的所有G的指针。无论用于封装当前这个go函数的G是否是新创建的，运行时系统都会对它进行一次初始化，包括关联go函数以及设置该G的状态和ID等步骤。在初始化完成后，这个G会立即被存储到本地P的<code>runnext</code>字段中；该字段用于存放新鲜出炉的G，以求更早地运行它。如果这时runnext字段已存有一个G，那么这个已有的G就会被“踢到”该P的可运行G队列的末尾。如果该队列已满，那么这个G就只能追加到调度器的可运行G队列中了。</p><p>在特定情况下，一旦新启用的G被存于某地，调度就会立即进行以使该G尽早被运行。不过，即使这里不立即调度，我们也无需担心，因为运行时系统总是在为及时运行每个G忙碌着。</p><p>每一个G都会由运行时系统根据其实际状况设置不同的状态，其主要状态如下。</p><ul><li><p>Gidle 表示当前G刚被新分配，但还未初始化。</p></li><li><p>Grunnable 表示当前G正在可运行队列中等待运行。</p></li><li><p>Grunning 表示当前G正在运行。</p></li><li><p>Gsyscall 表示当前G正在执行某个系统调用。</p></li><li><p>Gwaiting 表示当前G正在阻塞。</p></li><li><p>Gdead 表示当前G正在闲置。</p></li><li><p>Gcopystack 表示当前G的栈正被移动，移动的原因可能是栈的扩展或收缩。</p></li></ul><p>除了上述状态，还有一个称为<code>Gscan</code>的状态。不过这个状态并不能独立存在，而是组合状态的一部分。比如，<code>Gscan</code>与<code>Grunnable</code>组合成<code>Gscanrunnable</code>状态，代表当前G正等待运行，同时它的栈正被扫描，扫描的原因一般是GC（垃圾回收）任务的执行。又比如，<code>Gscan</code>与<code>Grunning</code>组合成<code>Gscanrunning</code>状态，表示正处于<code>Grunning</code>状态的当前G的栈要被GC扫描时的一个短暂时刻。简单起见，我不会在下面对这些组合状态进行说明。你只要知道这些组合状态会在<code>GC</code>扫描发生时出现就可以了。</p><p>之前讲过，在运行时系统想用一个G封装go函数的时候，会先对这个G进行初始化。一旦该G准备就绪，其状态就会被设置成<code>Grunnable</code>。也就是说，一个G真正开始被使用是在其状态设置为<code>Grunnable</code>之后。图2-5展示了G在其生命周期内的状态流转情况。</p><p><img src="\images\2-5.png" alt="图2-5"></p><h5 id="图2-5-G-的状态转换"><a href="#图2-5-G-的状态转换" class="headerlink" title="图2-5　G 的状态转换"></a>图2-5　G 的状态转换</h5><p>一个G在运行的过程中，是否会等待某个事件以及会等待什么样的事件，完全由其封装的go函数决定。例如，如果这个函数中包含对通道值的操作，那么在执行到对应代码的时候，这个G就有可能进入<code>Gwaiting</code>状态。这可能是在等待从通道类型值中接收值，也可能是在等待向通道类型值发送值。又例如，涉及网络I/O的时候也会导致相应的G进入Gwaiting状态。此外，操纵定时器（<code>time.Timer</code>）和调用<code>time.Sleep</code>函数同样会造成相应G的等待。在事件到来之后，G会被“唤醒”并被转换至<code>Grunnable</code>状态。待时机到来时，它会被再次运行。</p><p>G在退出系统调用时的状态转换要比上述情况复杂一些。运行时系统会先尝试直接运行这个G，仅当无法直接运行的时候，才会把它转换为<code>Grunnable</code>状态并放入调度器的自由G列表中。显然，对这样一个G来说，在其退出系统调用之时就立即被恢复运行再好不过了。运行时系统当然会为此做出一些努力，不过即使努力失败了，该G也还是会在实时的调度过程中被发现并运行。</p><p>最后，值得一提的是，进入死亡状态（<code>Gdead</code>）的G是可以重新初始化并使用的。相比之下，P在进入死亡状态（<code>Pdead</code>）之后，就只能面临销毁的结局。由此也可以说明<code>Gdead</code>状态与<code>Pdead</code>状态所表达的含义截然不同。处于<code>Gdead</code>状态的G会被放入本地P或调度器的自由G列表，这是它们被重用的前提条件。</p><blockquote><p>本文转载于<a href="http://www.ituring.com.cn/book/tupubarticle/16048" target="_blank" rel="noopener">郝林的文章</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>位运算</title>
      <link href="/2018/03/19/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2018/03/19/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<h1 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h1><p>两个数都为1时，才是1<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">5</span> &amp; <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h1 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h1><p>只有1个为1时，才是1<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">5</span> | <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h1 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h1><p>两个数不同时，才是1<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">5</span> ^ <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h1 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(^<span class="keyword">uint8</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h1 id="位清零"><a href="#位清零" class="headerlink" title="位清零"></a>位清零</h1><p>将后三位清零<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">5</span> &amp;^ <span class="number">3</span>)</span><br><span class="line"><span class="comment">//5：101</span></span><br><span class="line"><span class="comment">//3：011</span></span><br><span class="line"><span class="comment">// 100</span></span><br></pre></td></tr></table></figure></p><h1 id="与运算的妙用"><a href="#与运算的妙用" class="headerlink" title="与运算的妙用"></a>与运算的妙用</h1><hr><p>发现了一个有意思的表达式：x&amp;(x-1)，分享给大家！<br><a id="more"></a></p><h3 id="1、计算输入值转化为二进制后有多少个1"><a href="#1、计算输入值转化为二进制后有多少个1" class="headerlink" title="1、计算输入值转化为二进制后有多少个1"></a>1、计算输入值转化为二进制后有多少个1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count_one</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> count:=<span class="number">0</span>;;count++&#123;</span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x=x&amp;(x<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、判断输入的i是否是2的n次方"><a href="#2、判断输入的i是否是2的n次方" class="headerlink" title="2、判断输入的i是否是2的n次方"></a>2、判断输入的i是否是2的n次方</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> x&amp;(x<span class="number">-1</span>)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
