[{"title":"关系数据库原理","url":"/2018/08/18/关系数据库原理/","content":"\n# 数据库基本知识\n\n一个好的哈希表：$O(1)$\n一个均衡的树：$O(log(n))$\n一个好的排序算法：$O(n*log(n))$\n一个差的排序算法：$O(n^2)$\n\n### 1、排序\n\n合并排序：时间复杂度$O(n*log(n))$\n\n### 2、存储\n\n数据库的表使用的是`二维阵列`存储：必须一下子全部加载到内存中。\n数据库使用`哈希表`来存储`锁表`和`缓冲池`：可以先加载一半到内存中。\n\n### 3、查找\n\n<span style=\"border-bottom:2px solid red;\">查找特定的值：二叉查找树</span>\n    比如说你要查找40，时间复杂度O(log(N))\n\t\n【图片】\n\n<span style=\"border-bottom:2px solid red;\">范围查找：B+树</span>\n    比如你要查找40~100之间的值，只需要找到40，通过后续节点找到100，时间复杂度O(M+log(N))\n\n\n* 只有最底层的叶子才保存行信息\n* 底层节点是连续的\n* 尽量降低B+树的层数（表的索引），不然时间复杂度会变成$O(n)$\n* 当数据库进行删除插入操作时，需要自动更新B+索引树，所以创建太多索引影响性能\n\n# 二、数据库全局概览\n\n<span style=\"border-bottom:2px solid red;\">核心组件</span>\n\n* Process Manager：\n* Network Manager：\n* Memory Manager：\n* Client Manager：\n* File system Manager：\n* Security Manager：对用户的验证和授权\n\n<span style=\"border-bottom:2px solid red;\">工具</span>\n\n* Backup Manager：\n* Recovery Manager：崩溃后重启数据库到一致状态\n* Monitor Manager：记录数据库活动信息\n* Administration Manager：管理数据库、模式、表空间\n\n<span style=\"border-bottom:2px solid red;\">查询管理器</span>\n\n* Query executor：编译和执行查询\n* Query parser：检查查询是否合法\n* Query rewriter：预优化查询\n* Query optimizer：优化查询\n\n<span style=\"border-bottom:2px solid red;\">数据管理器</span>\n\n* Transaction Manager：处理事务\n* Cache Manager：\n* Data access Manager：访问磁盘中的数据\n\n# 三、查询过程\n\n## 1、客户端管理器：\n当你连接数据库时：\n\n1. 客户端管理器检查你的**验证信息**，检查你是否具有**访问权限**。\n2. 客户端管理器检查是否有空闲的进程或线程处理你的查询。\n3. 客户端管理器检查数据库是否负载很重。\n4. 如果客户端管理器等待超时还获取不到资源，会关闭连接。\n5. 客户端管理器会把查询给查询管理器处理。\n6. 查询处理进程从查询管理器获取数据后，会将部分结果保存至缓存并且给你发送\n\n## 2、查询管理器：\n\n1. 查询被解析并判断是否合法\n2. 重写——去除无用的操作加入预优化部分\n3. 优化提升性能，转换为可执行代码和数据查询计划\n4. 计划被编译\n5. 执行\n\n### 第一步：查询解析器\n\n1. 语法是否有误\n2. 关键字使用的顺序\n3. 根据数据库的元数据检查**表是否存在**,表的**字段是否存在**\n4. 对类型的使用是否可行\n5. 是否具有**权限**来读写表\n\n### 第二步：查询重写器\n\n1. 预优化查询,避免不必要的运算\n2. 根据一些规则寻找优化解决方案   \n    * **视图合并**:把查询中的试图转换为SQL代码\n    * **子查询扁平化**:尝试移除子查询(因为子查询难以优化)\n    * **去除不必要的运算符**:比如你用了`DISTINCT`和`UNIQUE`,那么`DISTINCT`就会被去掉.\n    * 消除冗余的连接\n    * **常数计算赋值**:比如 WHERE age > 10 + 2 ,会转换为 WHERE age < 12\n    * **分区裁剪**:如果你用了分区表,重写器能够找到需要使用的分区\n    * **物化试图重写**:如果有物化试图正好匹配查询谓词的一个子集,那么修改查询使用物化试图而不是原始表.\n    * **自定义规则**:如果你有自定义规则和修改查询,重写器就会执行这些规则\n    * **OLAP转换**\n\n例如:\n\n```sql\nSELECT PERSON.*\nFROM PERSON\nWHERE PERSON.person_key IN\n(SELECT MAILS.person_key\nFROM MAILS\nWHERE MAILS.mail LIKE 'christophe%');\n```\n会转换为:\n\n```sql\nSELECT PERSON.*\nFROM PERSON, MAILS\nWHERE PERSON.person_key = MAILS.person_key\nand MAILS.mail LIKE 'christophe%';\n```\n### 第三步：统计\n\n当你统计信息时,数据库会计算:\n* 表中行和列的数量\n* 表中列的唯一值,数据长度,数据范围\n* 表的索引\n\n统计的信息对于查询优化器做优化特别重要,所以统计必须要及时更新.\n\n### 第四步：查询优化器\n#### 获取数据的方法：\n\n* 全扫描：完整的读取一个表或索引\n* 范围扫描：使用B+树只是读取索引的一部分\n* 唯一扫描：二叉查找树就是查找唯一值的\n\n#### 联接运算符（获取数据后那么就要连接了）\n大多数情况下，“A Join B” 和 “B Join A”的成本是不同的\n\n---\n\n<span style=\"border-bottom:2px solid red;\">合并联接</span>：（a、b中挑选相同的元素）\n\n如果两个关系都已经排序，时间复杂度：$O(N+M)$\n如果两个关系都未排序，时间复杂度：$O(N*log(N)+M*log(M))$\n\n---\n\n<span style=\"border-bottom:2px solid red;\">哈希联接</span>：\n\n如果是个好的哈希函数，时间复杂度：$O(N+M)$\n\n---\n\n<span style=\"border-bottom:2px solid red;\">嵌套循环联接</span>：\n\n\n* 针对外关系的每一行，查看内关系里所有的行来寻找匹配的行。时间复杂度为$O(N^2)$。\n* 将两个关系`成簇的读取`对磁盘I/O有利，但时间复杂度没变。\n* 如果内关系足够小，那么时间复杂度最好能到：$O(N)$\n\n---\n\n#### 执行联接的顺序的算法\n<span style=\"border-bottom:2px solid red;\">动态规划</span>：\n\n* 省掉一些相似的做法，比如（A Join B）是重复的。\n\n<span style=\"border-bottom:2px solid red;\">启发式</span>：\n\n* 如果一个表有针对指定谓词的索引，那么就不要对表进行合并联接，对索引\n* 增加一些规则，比如`联接运算要先于其他关系运算`\n\n<span style=\"border-bottom:2px solid red;\">贪婪法</span>：\n\n* 先从要联接的表中选出一张表（A）\n* 计算每一个与（A）的联接，如果（A Join B）成本最低\n* 计算每一个与（A Join B）的结果成本最低的表\n* ...\n* 可以结合多个贪婪选项得出比较满意的答案\n\n#### 真实的优化器\n<span style=\"border-bottom:2px solid red;\">SQLite</span>\n\n* 在有 CROSS JOIN（两个表的笛卡尔乘积）时从不给表重新排序\n* 使用嵌套联接\n* 3.8.0版本使用`最近邻居`的贪婪算法作为最佳查询计划\n* ...\n\n### 第五步、查询执行器\n> 这时我们有了一个优化了的执行代码，编译为可执行代码，如果计算机的硬件符合要求，就会执行。但是查询执行器不会直接从文件系统拿数据，而是向`缓存管理器`要。\n\n\n## 4、数据管理器\n### 缓存管理器：与查询执行器进行数据的交互\n\n+ 因为磁盘I/O的瓶颈，缓存管理器有一个内存缓冲区（缓冲池）：从内存读取数据提供性能\n+ 缓存管理器需要在查询执行器使用数据之前`预读`数据\n+ 使用`缓冲区命中率`来度量预读的效率\n+ 缓冲容量有限，必须频繁加载移除，用`缓冲区置换策略`来解决\n\n<span style=\"border-bottom:2px solid red;\">预读</span>\n> 当查询执行器处理它的第一批数据时，会告诉缓存管理器预先装载第二批数据，当开始处理第二批数据时，告诉缓存管理器预先装载第三批数据，并且告诉缓存管理器第一批可以从缓存里清掉。\n\n* 推测预读法：查询执行器想要（1，3，5）数据，推测其也许需要（7，9，11）\n* 顺序预读法：只是简单的加载下一批连续的数据\n\n<span style=\"border-bottom:2px solid red;\">缓冲/缓存命中率</span>\n> 显示请求的数据在缓存中找到而不是从磁盘读取的频率\n\n<span style=\"border-bottom:2px solid red;\">缓冲区置换策略</span>\n> 因为内存大小有限，必须移除旧的数据，一般使用LRU（最近最少使用）算法\n\n\n#### 写缓冲区\n> 预先加载数据、成批刷入磁盘都可以提升写缓冲区的速度。缓冲区最小的数据单位是`页`，不是行。如果缓冲区的页修改了但是没有写入磁盘，就是`脏页`。\n\n## 5、事务管理器\n<span style=\"border-bottom:2px solid red;\">一个事务就是一个工作单元</span>\n\n- 原子性（Atomicity）：要么全完成，要么全部取消。\n- 隔离性（Isolation）：如果A，B事务同时运行，最终结果都是相同的，不管谁先结束。\n- 持久性（Durability）：一旦事务提交（成功运行），不管发生什么，数据要保存在数据库中。\n- 一致性（Consistency）：只有合法的数据才能写入数据库。\n\n<span style=\"border-bottom:2px solid red;\">4个隔离级别</span>\n\n+ 串行化（Serializable，SQLite默认模式）：最高级别，两个事务100%隔离\n+ 可重复读（Repeatable read，MySQL默认模式）：每个事务都有自己的世界，只是在`新数据方面突破隔离，在旧数据仍然隔离`。比如事务A运行（select count(1) from table），事务B这时在table表中添加了一条新的数据，那么事务A再运行一次得到的结果是不一样的——幻读\n+ 读取已提交（Oracle，PostgreSQL，SQL Server默认模式）：如果事务A读取数据D，这时事务B删除或修改数据D并提交，那么事务A再次读数据D时数据的变化是可见的——不可重复读\n+ 读取未提交：最低级别，如果事务A读取数据D，事务B修改或删除数据D（并未提交，事务B还在运行），那么事务A读取数据D时数据的变化是可见的。如果事务B回滚，那么事务A中读取的数据D是无意义的——`脏读`。\n\n# 四、数据库的并发控制\n## 1、锁管理器\n> 锁管理器是添加和释放锁的进程，用一个哈希表来保存锁信息（关键字是被锁的数据）\n\n\n<span style=\"border-bottom:2px solid red;\">排他锁原理</span>\n\n> 如果事务A需要一条数据，就把他锁住，如果事务B也需要这个数据，必须等待事务A释放数据。\n\n<span style=\"border-bottom:2px solid red;\">共享锁原理</span>\n\n1. 事务A需要【读取】数据 X，它会给数据 X 加上【共享锁】并读取\n2. 事务B也需要【读取】数据 X，它会给数据 X 加上【共享锁】并读取\n3. 事务C要【修改】数据 X，它会给数据 X 加上【排他锁】，但是必须等待事务A，B释放【共享锁】\n\n<span style=\"border-bottom:2px solid red;\">两段锁原理</span>\n\n+ 将事务分为两个阶段：\n+ 成长阶段：事务可以获得锁，但不能释放锁\n+ 收缩阶段：事务可以释放锁（对于已经处理完而且不会再次处理的数据），但不能获得新锁\n\n### 死锁\n\n+ `超时设定`，如果一个锁再该时间内没有加上，那么就判断事务产生死锁——简单\n+ 检查哈希表中是否有循环——代价很昂贵\n+ 在加锁之前检查该锁是否会死锁——代价也很昂贵\n\n## 2、版本控制\n\n+ 每个事务可以同时修改【相同的】数据\n+ 每个事务有自己的数据拷贝（版本）\n+ 如果两个事务同时修改相同的数据，只接受一个修改，另一个将回滚或者重新运行\n+ 读写事务不会相互阻塞\n+ 没有锁管理器带来额外开销\n+ 但是磁盘空间的消耗会很大\n\n# 五、数据库的日志管理\n为了保证事务的持久性和原子性，有两个解决方法：\n\n1. 副本：事务创建自己的副本，基于副本工作，如果失败，就删除副本；如果成功，就提交副本\n2. 事务日志：在每次写入磁盘之前，在事务日志中写入信息，这样崩溃了也能知道该怎么办\n\n## WAL\n大多数数据库使用`预写日志协议`（Write-Ahead Logging protocol，WAL）来处理事务日志。\n\n1. 每个对数据库的修改都产生一条`日志记录`，在数据写入磁盘前都必须把`日志记录`写入事务日志。\n2. 日志记录必须按顺序写入\n3. 事务提交成功之前，必须把事务的提交顺序写入事务日志\n\n## ARIES\n比WAL在写日志时能保持良好的性能，快速可靠的数据恢复。\n\n## 日志\n日志的组成：磁盘上保存数据的每个页都记录着最后修改该数据的LSN\n\n+ LSN：日志序列号（Log Sequence Num），这是按时间顺序分配的\n+ TransID：产生操作事务的ID\n+ PagelD：被修改的数据在磁盘上页的位置\n+ PrevLSN：同一个事务产生的上一条日志的链接\n+ UNDO：取消本次操作的方法，回到原来状态的反向操作\n+ REDO：重复本次操作\n\n### 日志缓冲区\n当查询执行器要求做一次修改：\n\n1. 缓存管理器将修改存入自己的缓存\n2. 日志管理器将相关日志存入自己的日志缓冲区\n3. 查询执行器认为操作已经完成\n4. 日志管理器将日志写入事务日志\n5. 缓存管理器将修改写入磁盘\n\n### STEAL 和 FORCE 策略\n\n+ NO-FORCE策略——如果第5步在事务提交之后完成，一旦发生崩溃，可以使用`REDO`恢复事务\n+ FORCE策略——第5步在事务提交之前必须完成。\n+ STEAL策略——数据是一步步的写入磁盘\n+ NO-STEAL策略——缓冲区管理器等待提交命令然后一次性写入磁盘\n\n<span style=\"border-bottom:2px solid red;\">大部分的数据库都选择**No-Force/Steal**策略，性能最好。</span>\n## 恢复\n如果事务被【手动】取消，或者被所管理器取消（取消死锁），或者因为网路故障取消，那么就不需要进行分析阶段，因为哪些需要Redo，哪些需要Undo的信息保存在2个内存表中：\n\n+ 事务表：保存当前所有事务状态\n+ 脏页表：保存哪些数据需要写入磁盘\n\n#### 1、分析阶段\n> 恢复进程读取全部的事务日志，来重建崩溃中发生的时间线（生成2张表），决定哪些事务回滚（未提交的事务都需回滚）、崩溃时哪些数据需要写盘。\n\n<span style=\"border-bottom:2px solid red;\">检查点</span>：\n\n> 为了加快分析阶段，使用检查点技术，不时的把2张表的内容和最后一条LSN写入磁盘，那么在分析阶段中，只要分析这个LSN之后的日志就可以了。\n\n#### 2、Redo阶段\n\n+ Redo按日志的时间顺序（LSN）进行处理\n+ 如果LSN（磁盘页）>= LSN（日志记录），说明数据在崩溃前写入磁盘，所以不需要做什么\n+ 如果LSN（磁盘页）< LSN（日志记录），磁盘上的页将要被更新\n\n#### 3、Undo阶段\n从每个事务的最后一条日志开始回滚所有崩溃时未完成的事务。\n\n# 六、数据库的数据存储\n### 数据类型\n数据类型分为：定长`char(20)`和变长`varchar(20)`，除非最长和最短相差太多，否则还是使用定长比较好。\n\n### 记录\n\n> 一个数据块中能存储的记录（行）分为：变长记录和定长记录。每个记录中都包含各自的`RID`。\n>> 无序记录的文件被称为`堆文件`，有序的文件通常需要结合`聚簇索引`（将数据直接存储在数据库块的索引上）来排序。\n\n### 文件组织\n顺序文件组织：能根据索引来检索文件\n散列文件组织：hash索引\n\n### 数据库存储的文件\n* 数据文件\n* 索引文件\n* 日志文件\n\n### MySQL的数据字典\n* mysql：保存数据库的元数据的\n* information_schema：统计数据\n* performance_schema：显示性能信息","categories":["数据库"]},{"title":"Hello World","url":"/2018/08/18/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"旋转字符串","url":"/2018/08/10/旋转字符串/","content":"```c++\n//给出字符串abcdefg，旋转2，变成cdefgab \n#include <iostream>\n\nusing namespace std;\n \n//法一：暴力移位法\nvoid leftShiftOne(string &str){\n\tint n = str.length();\n\tif(n<2){\n\t\treturn;\n\t}\n\tchar t = str[0];\n\tfor(int i=1;i<n;i++){\n\t\tstr[i-1]=str[i];\n\t}\n\tstr[n-1]=t;\n}\n\nvoid rotate_1(string &str,int m){\n\twhile(m--){\n\t\tleftShiftOne(str);\n\t}\n}\n\n//法二：三步转换法 \n//ab->ba\n//cdefg->gfedc\n//bagfedc->cdefgab \nvoid reserveString(string &str,int from,int to){\n\twhile(from < to){\n\t\tchar t = str[from];\n\t\tstr[from]=str[to];\n\t\tstr[to]=t;\n\t\tfrom++;\n\t\tto--;\n\t}\n}\n\nvoid rotate_2(string &str,int m,int n){\n\tm %= n;\n\treserveString(str,0,m-1);\n\treserveString(str,m,n-1);\n\treserveString(str,0,n-1);\n}\n\nint main(){\n\tstring s =\"abcdef\";\n\tint num = 7;\n\trotate_2(s,num,s.size());\n\tcout<<s<<endl;\n}\n```","categories":["c++ = 算法"]},{"title":"发送邮件","url":"/2018/08/09/发送邮件/","content":"```go\nfunc main() {\n\tauth:=smtp.PlainAuth(\"\",\"example1@qq.com\",\"密码\",\"smtp.qq.com\")\n\tto:=[]string{\"example2@qq.com\"}\n\tnickname:=\"test\"\n\tsubject:=\"test mail\"\n\tcontent_type:=\"Content-type: text/plain;charset=UTF-8\"\n\tbody:=\"This is email body!\"\n\tfrom:=\"example1@qq.com\"\n\tmsg:=[]byte(\"To:\"+strings.Join(to,\",\")+\"\\r\\nFrom\"+nickname+\"<\"+from+\">\\r\\nSubject:\"+subject+\"\\r\\n\"+content_type+\"\\r\\n\\r\\n\"+body)\n\terr:=smtp.SendMail(\"smtp.qq.com:25\",auth,from,to,msg)\n\tif err!=nil{\n\t\tfmt.Printf(\"send email error:%v\",err)\n\t}\n}\n```","categories":["golang"]},{"title":"unsafe","url":"/2018/07/10/unsafe/","content":"### Pointer\n`unsafe.Pointer`的4个规则：\n* 任何指针都可以转换为`unsafe.Pointer`类型\n* `unsafe.Pointer`类型可以转换为任何指针\n* `uintptr`类型可以转换为`unsafe.Pointer`类型\n* `unsafe.Pointer`类型可以转换为`uintptr`类型\n\n```go\nfunc main() {\n    i:= 10\n    fi:=(*float64)(unsafe.Pointer(&i))\n    *fi = *fi * 3\n    fmt.Println(i)\n}\n```\n----------\n\n指针变量`*T`是不能计算偏移量的，但是`uintptr`可以，我们将指针转换为`uintptr`，进行偏移计算，这样就能访问特定内存了，达到对不同内存读写的目的。\n```go\nfunc main() {\n    u:=new(user)\n    pName := (*string)(unsafe.Pointer(u))\n    *pName = \"张三\"\n    temp:=uintptr(unsafe.Pointer(u))+unsafe.Offsetof(u.age)\n    pAge:=(*int)(unsafe.Pointer(temp))\n    *pAge = 20\n    fmt.Println(*u)\n}\n```\n`pName`因为是第一个字段，所以不需要偏移，`pAge`设置偏移后获取到该字段的内存地址。\n\n------\n\n当一个变量被移动，所有的保存改变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾收集器的视角来看，一个unsafe.Pointer是一个指向变量的指针，因此当变量被移动是对应的指针也必须被更新；但是uintptr类型的临时变量只是一个普通的数字，所以其值不应该被改变。上面错误的代码因为引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针。当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的&x.b地址。\n```go\ntemp:=uintptr(unsafe.Pointer(u))+unsafe.Offsetof(u.age)\npAge:=(*int)(unsafe.Pointer(temp))\n*pAge = 20\n```","categories":["golang"]},{"title":"狄克斯特拉算法","url":"/2018/06/01/狄克斯特拉算法/","content":"```go\nvar processed []string\n\nfunc main()  {\n\tgraph:=map[string]map[string]int{\n\t\t\"start\":{\n\t\t\t\"a\":6,\n\t\t\t\"b\":2,\n\t\t},\n\t\t\"a\":{\n\t\t\t\"终点\":1,\n\t\t},\n\t\t\"b\":{\n\t\t\t\"a\":3,\n\t\t\t\"终点\":5,\n\t\t},\n\t}\n\tcosts:=map[string]int{\n\t\t\"a\":6,\n\t\t\"b\":2,\n\t\t\"终点\":1<<31-1,\n\t}\n\tparents:=map[string]string{\n\t\t\"a\":\"起点\",\n\t\t\"b\":\"起点\",\n\t\t\"终点\":\"\",\n\t}\n\tfor{\n\t\tnode:=find_lowest_cost_node(costs)\n\t\tif node==\"\"{\n\t\t\tbreak\n\t\t}\n\t\tcost:=costs[node]\n\t\tneighbors:=graph[node]\n\t\tfor n := range neighbors{\n\t\t\tnew_cost:=cost+neighbors[n]\n\t\t\tif costs[n]>new_cost{\n\t\t\t\tcosts[n]=new_cost\n\t\t\t\tparents[n]=node\n\t\t\t}\n\t\t}\n\t\tprocessed=append(processed,node)\n\t}\n\tfmt.Println(\"graph:\",graph)\n\tfmt.Println(\"costs:\",costs)\n\tfmt.Println(\"parents:\",parents)\n\tfmt.Println(\"processed:\",processed)\n}\n\n\nfunc find_lowest_cost_node(costs map[string]int)string {\n\tvar lowest_cost int=1<<31-1\n\tvar lowest_cost_node string\n\tfor node:=range costs{\n\t\tcost:=costs[node]\n\t\tif cost<lowest_cost && find_not_in_slice(node){\n\t\t\tlowest_cost = cost\n\t\t\tlowest_cost_node = node\n\t\t}\n\t}\n\treturn lowest_cost_node\n}\n\nfunc find_not_in_slice(node string)bool{\n\tfor _,v:=range processed{\n\t\tif v==node{\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```","categories":["golang"]},{"title":"温柔的人","url":"/2018/05/27/温柔的人/","content":"* [四月是你的谎言](https://www.bilibili.com/bangumi/play/ss1699/?from=search&seid=2826238494142229813)\n* [一周的朋友](https://www.bilibili.com/bangumi/play/ss173/?from=search&seid=18135097600024502508)\n* [好想告诉你](https://www.bilibili.com/bangumi/play/ss857/?from=search&seid=9659429609644661484)\n* [樱花庄的宠物女孩](https://www.bilibili.com/bangumi/play/ss687/?from=search&seid=10532690056145324955)\n* [来自风平浪静的明天](https://www.bilibili.com/bangumi/play/ss441/?from=search&seid=6970826844296742980)\n* [玉子爱情故事](https://www.bilibili.com/bangumi/play/ss4155/?from=search&seid=14001513337380785036)\n* [超能力女儿](https://www.bilibili.com/bangumi/play/ss23850/?from=search&seid=11911092656866222768)\n* [散华礼弥]\n","categories":["动漫"]},{"title":"链接","url":"/2018/04/10/链接/","content":"* [网上有哪些资源](https://www.zhihu.com/question/19942068/answer/269768796)\n* [新手程序员该做啥](https://www.zhihu.com/question/50701819/answer/122610566)\n* [经典编程书籍](https://github.com/jobbole/awesome-programming-books)\n* go语言\n\t- [go和HTTPS](https://tonybai.com/2015/04/30/go-and-https)\n\t- [Go的并发模型——流水线](http://www.oscarzhao.me/golang/2016/08/12/go-pipelines-cancellation.html)\n\t- [Go的并发模型——简单Context](https://deepzz.com/post/golang-context-package-notes.html)\n\t- [Go的并发模型——深入Context](http://www.oscarzhao.me/golang/2016/08/26/go-context.html)\n\t- [访问私有函数和变量](http://colobu.com/2017/05/12/call-private-functions-in-other-packages/)\n\t- [go包搜索](https://godoc.org)\n\t- [各种数据结构实现](https://github.com/nange/datastructures-and-algorithms-using-four-language/tree/master/go)\n* 开发工具\n\t- [gcse](https://cse.google.com/cse/all)\n\t- [gcse指南](https://developers.google.com/custom-search/docs/overview)\n\t- [google apis](https://console.developers.google.com/apis)\n","categories":["学习"]},{"title":"访问私有函数和变量","url":"/2018/04/09/访问私有函数和变量/","content":"如果一个函数只有函数声明，没有函数定义，那么它的函数定义肯定在其他地方，然后两者通过符号链接实现了，比如：\n```go\npackage a\n\nimport \"fmt\"\nimport _\"unsafe\"\n\n//go:linkname hello b.Greet\nfunc hello(){\n    fmt.Println(\"Hello,World!\")\n}\n```\n\n```go\npackage b\n\nimport _\"a\"\n\nfunc Greet()\n```\nb包中要添加一个空的汇编文件，不然不会通过编译","categories":["golang"]},{"title":"http路由分发","url":"/2018/03/30/http路由分发/","content":"```go\n//根据func(f HandlerFunc)ServeHTTP(w http.ResponseWriter,r *http.Request){f(w,r)}\n//HandlerFunc类型可以实现路由转发功能，申明mux类型\nvar mux map[string]func(http.ResponseWriter, *http.Request)\n// 定义自己的Handler\ntype myHandler struct {}\n//实现了ServeHTTP这个方法，实现了Handler接口\nfunc (*myHandler)ServeHTTP(w http.ResponseWriter,r *http.Request){\n\tfmt.Fprintf(w,\"This is ServeHTTP!\")\n\tif f,ok:=mux[r.URL.String()];ok{\n\t\tf(w,r)\n\t}\n}\n\nfunc sayBye2(w http.ResponseWriter,r *http.Request)  {\n\tio.WriteString(w,\"Bye!\")\n}\nfunc sayHello2(w http.ResponseWriter,r *http.Request){\n\tio.WriteString(w,\"Hello!\")\n}\n\nfunc main() {\n\tmux=make(map[string]func(http.ResponseWriter,*http.Request))\n\tmux[\"/hello\"]=sayHello2\n\tmux[\"/bye\"]=sayBye2\n//自己定义Server结构体\n\tserver:=&http.Server{\n\t//监听端口\n\t\tAddr:\":1995\",\n\t//Handler函数\n\t\tHandler:&myHandler{},\n\t\tReadTimeout:5*time.Second,\n\t}\n\terr:=server.ListenAndServe()\n\tif err!=nil{\n\t\tlog.Fatal(err)\n\t}\n}\n\n```","categories":["golang"]},{"title":"http(1)","url":"/2018/03/29/http-1/","content":"### 1、设置静态目录\n```\nfunc main() {\n\thttp.ListenAndServe(\":1995\",http.FileServer(http.Dir(\".\")))\n}\n```\n### 2、搭建简单HTTP服务器\n```go\nfunc sayHello(w http.ResponseWriter,r *http.Request){\n\tr.ParseForm()\n\t// 向服务器端输出请求的url信息\n\tfmt.Println(r.Form)\n\tfmt.Println(\"path:\",r.URL.Path)\n\tfmt.Println(\"scheme:\",r.URL.Scheme)\n\tfmt.Println(r.Form[\"url_long\"])\n\tfor k,v:=range r.Form{\n\t\tfmt.Println(\"key:\",k)\n\t\tfmt.Println(\"val:\",strings.Join(v,\" \"))\n\t}\n\tfmt.Fprintf(w,\"Hello gongshen!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\",sayHello)\n\thttp.ListenAndServe(\":1995\",nil)\n}\n```\n\n### 3、底层实现路由分发策略\n","categories":["golang"]},{"title":"channel","url":"/2018/03/28/channel/","content":"向发送通道发送值时，不会因为通道已满而产生阻塞，所以一个更好的办法是，创建一个长度1的接受通道，并时刻准备接收数据\nfor v:=range channel{\n}\n","categories":["golang"]},{"title":"pipe","url":"/2018/03/27/pipe/","content":"### 1、匿名管道\npackage main\n\nimport (\n\t\"os/exec\"\n\t\"fmt\"\n\t\"os\"\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n)\nfunc runCmd() {\n\tvar useBufIO=false\n\tcmd0 := exec.Command(\"echo\", \"-n\", \"My first command comes from golang.\")\n\n\t// 设置一个输出通道\n\tstdout0, err := cmd0.StdoutPipe()\n\n\tif err != nil {\n\t\tfmt.Printf(\"Error:Counld't obtain the stdout pipe from command NO.0:%s\\n\", err)\n\t\treturn\n\t}\n\t// Start\n\tif err := cmd0.Start(); err != nil {\n\t\tfmt.Printf(\"Error:The command NO.0 can not be startup:%s\\n\", err)\n\t\treturn\n\t}\n\n\t// 调用read方法获取命令\n\tvar output0 = make([]byte, 30)\n\n\tif !useBufIO {\n\t\tvar outputBuf0 bytes.Buffer\n\t\tfor {\n\t\t\ttempOutput0 := make([]byte, 5)\n\t\t\tn, err := stdout0.Read(tempOutput0)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"Error:Couldn't read data from the pipe:%s\\n\", err)\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif n > 0 {\n\t\t\t\toutputBuf0.Write(tempOutput0[:n])\n\t\t\t}\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", outputBuf0.String())\n\t} else {\n\t\t// 缓存读取器\n\t\tvar isPrefix bool\n\t\tfor {\n\t\t\toutputBuf0 := bufio.NewReaderSize(stdout0, 5)\n\t\t\toutput0, isPrefix, err = outputBuf0.ReadLine()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error:Couldn't read data from the pipe:%s\\n\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\tfmt.Printf(\"%s\", string(output0))\n\t\t\tif isPrefix == false {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 通过管道将输出值作为另一个命令的输入\nfunc runCmdPipe(){\n\tvar outputBuf1 bytes.Buffer\n\tvar outputBuf2 bytes.Buffer\n\tcmd1:=exec.Command(\"ps\",\"aux\")\n\tcmd2:=exec.Command(\"grep\",\"apipe\")\n\t//将所有的输出内容都记录到这里\n\tcmd1.Stdout=&outputBuf1\n\tif err:=cmd1.Start();err!=nil{\n\t\tfmt.Printf(\"Error:The frist command can not be startup:%s\\n\",err)\n\t\treturn\n\t}\n\t//cmd1结束运行之前，wait()调用会一直阻塞\n\tif err:=cmd1.Wait();err!=nil{\n\t\tfmt.Printf(\"Error:Can't wait for the first command:%s\\n\",err)\n\t\treturn\n\t}\n\n\tcmd2.Stdin=&outputBuf1\n\tcmd2.Stdout=&outputBuf2\n\tif err:=cmd2.Start();err!=nil{\n\t\tfmt.Printf(\"Error:The second command can not be startup:%s\\n\",err)\n\t\treturn\n\t}\n\tif err:=cmd2.Wait();err!=nil{\n\t\tfmt.Printf(\"Error:Cant't wait for the second command:%s\\n\",err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%s\\n\",outputBuf2.String())\n}\n\nfunc main(){\n\trunCmd()\n\tfmt.Println()\n\trunCmdPipe()\n}\n### 2、命名管道（文件管道）和内存管道\npackage main\n\nimport (\n\t\"os\"\n\t\"fmt\"\n\t\"time\"\n\t\"io\"\n)\n\n// 基于文件的管道，其中一端未绪前阻塞另一端的进程\nfunc fileBasePipe() {\n\treader,writer,err:=os.Pipe()\n\tif err!=nil{\n\t\tfmt.Printf(\"Error:Create named pipe failed:%s\\n\",err)\n\t\treturn\n\t}\n\tgo func() {\n\t\toutPut:=make([]byte,100)\n\t\tn,err:=reader.Read(outPut)\n\t\tif err!=nil{\n\t\t\tfmt.Printf(\"Error:Could't read data from the named pipe: %s\\n\",err)\n\t\t}\n\t\tfmt.Printf(\"Readed %d byte(s)[based pipe]\\n\",n)\n\t\tfmt.Println(string(outPut))\n\t}()\n\tinPut:=make([]byte,26)\n\tfor i:=65;i<90;i++{\n\t\tinPut[i-65]=byte(i)\n\t}\n\tn,err:=writer.Write(inPut)\n\tif err!=nil{\n\t\tfmt.Printf(\"Error: Couldn't write data to the named pipe: %s\\n\",err)\n\t}\n\tfmt.Printf(\"Written %d byte(s).[based pipe]\\n\",n)\n\ttime.Sleep(200*time.Millisecond)\n}\n\n// 基于内存的有原子性操作的管道\nfunc memoryBasePipe() {\n\treader, writer := io.Pipe()\n\tgo func() {\n\t\toutPut := make([]byte, 100)\n\t\tn,err := reader.Read(outPut)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error:Read fatal: %s\\n\", err)\n\t\t}\n\t\tfmt.Printf(\"Readed %d byte(s)[based pipe]\\n\", n)\n\t\tfmt.Println(string(outPut))\n\t}()\n\tinPut:=make([]byte,26)\n\tfor i:=65;i<90;i++{\n\t\tinPut[i-65]=byte(i)\n\t}\n\tn, err := writer.Write(inPut)\n\tif err != nil {\n\t\tfmt.Printf(\"Error:Write fatal: %s\\n\", err)\n\t}\n\tfmt.Printf(\"Written %d byte(s).[based pipe]\\n\", n)\n\ttime.Sleep(200*time.Millisecond)\n}\n\nfunc main() {\n\tfileBasePipe()\n\tfmt.Println()\n\tmemoryBasePipe()\n}","categories":["golang"]},{"title":"panic和recover","url":"/2018/03/27/panic和recover/","content":"* panic用于停止当前的控制流程并引发一个恐慌\n* recover用于使当前程序从恐慌中恢复并重新获得流程控制权\n* recover函数的结果是一个interface{}类型，如果结果不是nil，那么就有问题啦！\n* recover和defer应该配合使用\n\n我们看下标准库fmt中的Token是怎么处理的\n```go\nfunc (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\t\t//判断recover函数的结果是否为nil\n\t\t\tif se, ok := e.(scanError); ok {\t//判断panic的类型\n\t\t\t\terr = se.err\t\t\n//如果panic是这个类型，那么这个值就会赋值给结果值变量err，\n//这样做到了精确控制panic，将已经recover的恐慌当作常规结果返回\n\t\t\t} else {\n\t\t\t\tpanic(e)\n//否则恐慌会再次引发\n\t\t\t}\n\t\t}\n\t}()\n...\n}\n```\n恐慌被传递到调用栈的最顶层的结果：\n```go\npanic: An intended fatal error! [recovered]\n\tpanic: An intended fatal error!\n```\n","categories":["golang"]},{"title":"defer和闭包","url":"/2018/03/27/defer/","content":"* 只有当defer语句执行完，外围函数才会返回\n* 外围函数如果引发了`panic`，`defer`语句也会执行完panic才会扩散\n* 在defer执行的时候，针对defer语句的表达式会被压栈，等到外围函数结束时，才依次从栈中取出\n* defer是在函数退出前执行，并且是`值传递`\n\n# 1、闭包的值传递和指针传递\n### 1.闭包的值传递\n```go\nfunc main()  {\n\tvar m int\n\tm=10\n\tfmt.Println(m)\n\tdefer func(i int) {\n\t\tfmt.Println(i)\n\t}(m)\n\tm=20\n}\n```\n结果是：\n```go\n10\n10\n```\n### 2.闭包的指针传递:\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main()  {\n\tvar m int\n\tm=10\n\tfmt.Println(m)\n\tdefer func() {\n\t\tfmt.Println(m)\t\t\t\t//闭包的意思就是他已经把指针准备好了\n\t}()\n\tm=20\n}\n```\n结果是：\n```go\n10\n20\n```\n\n# 2、defer的值传递\n### 1.函数参数是值传递：\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main()  {\n\tvar m int\n\tm=10\n\tfmt.Println(m)\n\tdefer Print(m)\n\tm=20\n}\nfunc Print(m interface{})  {\n\tfmt.Println(m.(int))\n}\n```\n结果是：\n```go\n10\n10\n```\n### 2.如果用指针作为函数参数：\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main()  {\n\tvar m *int\n\tm=new(int)\n\t*m=10\n\tfmt.Println(*m)\n\tdefer Print(m)\n\t*m=20\n}\nfunc Print(m interface{})  {\n\tfmt.Println(*m.(*int))\n}\n```\n结果是：\n```go\n10\n20\n```\n-----\n# 3、容易入的\"坑\"\n### 例子1：\n```go\nfunc f()(result int){\n\tdefer func(){\n\t\tresult++\n\t}()\n\treturn 0\n}\n```\n> 解：\n`return 0`并不是原子操作,应该写成`result=0`,`return`;所以结果是`1`。\n\n### 例子2：\n```go\nfunc f()(r int){\n\tdefer func(r int){\n\t\tr=r+5\n\t}(r)\n\treturn 1\n}\n```\n> 解：\n先`r=1`,再`return`,但是闭包中是值传递,不会影响r的值,所以结果是`1`。","categories":["golang"]},{"title":"职责链","url":"/2018/03/27/职责链/","content":"<h1> {{ post.title }} </h1>\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。\n将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。\n\n- 链对象包含当前职责对象以及下一个职责链\n- 职责对象提供接口表示能否处理对应请求\n- 职责对象提供处理函数处理相关\n\n![](/images/responsibity.PNG)\n\n```go\npackage main\n\nimport \"fmt\"\n\n\n// 处理请求接口\ntype Manager interface {\n\tSetSuccessor(Manager)\n\tHandleRequest(string,int)bool\n}\n\n// 请求链\ntype RequestChain struct {\n\tsuccessor Manager // 继承者\n}\n\nfunc (r *RequestChain) SetSuccessor(i Manager) {\n\tr.successor = i\n}\n\n//经理\ntype jingli struct {\n\tRequestChain\n}\n\nfunc Newjingli()*jingli{\n\treturn &jingli{}\n}\n\nfunc (j *jingli) HandleRequest(name string,num int)bool {\n\tif name == \"请假\" && num <= 2{\n\t\t\tfmt.Printf(\"经理允许%s%d\\n\",name,num)\n\t\t\treturn true\n\t\t}else if j.successor!=nil{\n\t\t\tfmt.Printf(\"经理不允许%s%d\\n\", name, num)\n\t\t\treturn j.successor.HandleRequest(name,num)\n\t\t}\n\t\treturn false\n}\n\n//总经理\ntype zongjingli struct {\n\tRequestChain\n}\n\nfunc Newzongjingli()*zongjingli{\n\treturn &zongjingli{}\n}\n\nfunc (z *zongjingli) HandleRequest(name string,num int)bool {\n\t if name == \"请假\" && num <= 5{\n\t \tfmt.Printf(\"总经理允许%s%d\\n\", name, num)\n\t\t\treturn true\n\t\t} else if z.successor != nil {\n\t\t\tfmt.Printf(\"总经理不允许%s%d\\n\", name, num)\n\t\t\treturn z.successor.HandleRequest(name, num)\n\t\t}\n\t\treturn false\n}\n\n//总监\ntype zongjian struct {\n\tRequestChain\n}\n\nfunc Newzongjian()*zongjian{\n\treturn &zongjian{}\n}\n\nfunc (z *zongjian) HandleRequest(name string,num int)bool {\n\tif name == \"请假\" && num <= 5{\n\t\tfmt.Printf(\"总监允许%s%d\\n\", name, num)\n\t\treturn true\n\t} else if z.successor != nil {\n\t\tfmt.Printf(\"总监不允许%s%d\\n\", name, num)\n\t\treturn z.successor.HandleRequest(name, num)\n\t}\n\tif name == \"加薪\" && num <= 500{\n\t\tfmt.Printf(\"总监允许%s%d\\n\", name, num)\n\t\treturn true\n\t} else if z.successor != nil {\n\t\tfmt.Printf(\"总监不允许%s%d\\n\", name, num)\n\t\treturn z.successor.HandleRequest(name, num)\n\t}\n\treturn false\n}\n\nfunc main(){\n\tc1:=Newjingli()\n\tc2:=Newzongjingli()\n\tc3:=Newzongjian()\n\tc1.SetSuccessor(c2)\n\tc2.SetSuccessor(c3)\n\tc1.HandleRequest(\"请假\",2)\n\tc1.HandleRequest(\"请假\",4)\n\tc1.HandleRequest(\"加薪\",400)\n}\n```\n","categories":["设计模式"]},{"title":"note","url":"/2018/03/27/note/","content":"1. golang中值类型的零值为空或者是0，指针类型的零值为nil。\n2. switch的类型断言必须遵守类型断言的规则\n3. switch的类型断言中不能出现`fallthrough`\n4. 当使用`for range`迭代一个通道值为`nil`时，会永远阻塞在`for`语句上","categories":["note"]},{"title":"method","url":"/2018/03/27/method/","content":"# 可寻址值和不可寻址值调用方法\n### 示例一：\n对于一个非指针类型，它关联的方法集中只包含它的值方法。对于一个指针类型，它关联的方法集中既包含值方法和指针方法。\n但是非指针类型也是可以调到指针方法的，因为Go进行了自动转换\n---\n\n```go\ntype data struct {\n\tname string\n}\n// 指针类型的方法\nfunc (d *data)Print()  {\n\tfmt.Println(\"name:\",d.name)\n}\n// 值类型的方法\nfunc (d data)Print2(){\n\tfmt.Println(\"name2:\",d.name)\n}\n\ntype Printer interface {\n\tPrint()\n}\n\nfunc main() {\n\tvar p Printer = &data{\"one\"}\n\tp.Print()\n\n// p是一个指针类型\n\n\tm1 := map[string]data{\"x\":{\"two\"}}\n\tn:=m1[\"x\"]\n\tn.Print()\n\n// 重要！\n// n是值类型，但是可以调用指针类型的方法，Go进行了自动转换\n// n.Print()  ==  (&n).Print()\n\n\tm2:=map[string]*data{\"x\":{\"three\"}}\n\tn2:=m2[\"x\"]\n\tn2.Print2()\n\t\n// 重要！\n// n2是指针类型，但是可以调用值类型的方法，Go进行了自动转换\n// n2.Print2()  ==  (*n2).Print2()\n\n\ts:=[]data{\n\t\t{\"four\"},\n\t}\n\ts[0].Print()\n\t\n// 对于结构体类型的`slice`是指针类型\n}\n```\n### 示例二：\nreceiver变量其实就是源值的一个复制品。如果receiver是值类型，那么自然没有办法修改源值；如果receiver是指针类型，那么指针值指向的就是源值的地址，就能够修改源值。\n---\n\n```go\ntype myInt int\n\n// 指针类型方法\nfunc (i *myInt)add2(another int)myInt{\n\t*i=*i+myInt(another)\n\treturn *i\n}\n// 值类型方法\nfunc (i myInt)add(another int)myInt{\n\ti=i+myInt(another)\n\treturn i\n}\n\nfunc main(){\n\ti1:=myInt(1)\n\ti2:=i1.add(2)\n\tfmt.Println(i1,i2)\n// 结果是：1,3\n\ti2=i1.add2(2)\n\tfmt.Println(i1,i2)\n// 结果是：3,3\n}\n```\n\n\n\n\n","categories":["golang"]},{"title":"function","url":"/2018/03/26/function/","content":"# 将函数当作参数，进行二元操作\n```go\ntype binaryOperation func(int,int)(int,error)\n\nfunc operate(op1 int,op2 int,op binaryOperation)(result int,err error){\n\tif op==nil{\n\t\terr=errors.New(\"invaild functions!\")\n\t\treturn\n\t}\n\treturn op(op1,op2)\n}\n\n//用户可以自己实现除法操作\nfunc divide(op1 int,op2 int)(result int,err error){\n\tif op2==0{\n\t\terr=errors.New(\"divide by zero!\")\n\t\treturn\n\t}\n\tresult=op1/op2\n\treturn\n}\n\nfunc main()  {\n\tvar result int\n\tvar err error\n\tresult,err=operate(0,2,divide)\n\tfmt.Printf(\"result：%v，err：%v\\n\",result,err)\n}\n```","categories":["golang"]},{"title":"gorouting","url":"/2018/03/26/gorouting_thread/","content":"# Go的线程模型\nGo不推荐使用共享内存的方式传递数据，而推荐使用channel（或称“通道”）在多个goroutine之间传递数据，同时保证整个过程的并发安全性。不过，作为可选方法，Go依然提供了一些传统的同步方法（比如互斥量、条件变量等）。\n\n在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。我们可以将goroutine看作是Go特有的应用程序线程。但是，goroutine背后的支撑体系远没有这么简单。\n\n说起Go的线程实现模型，有三个必知的核心元素，它们支撑起了这个模型的主框架。\n\n- M：machine的缩写。一个M代表一个内核线程，或者“工作线程”。\n\n- P：processor的缩写。一个P代表执行一个Go代码片段所必需的资源（或称“上下文环境”）。\n\n- G：goroutine的缩写。一个G代表一个Go代码片段。前者是对后者的一种封装。\n\n简单来说，一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境）。每个P都会包含一个可运行的G的队列（runq）。该队列中的G会被依次传递给与本地P关联的M，并获得运行时机。在这里，我把运行当前G的那个M称为“当前M”，并把与当前M关联的那个P称为“本地P”。后面我会以此为术语进行描述。\n\n从宏观上看，M、P和G之间的联系如图2-1所示，但是实际关系要比这幅图所展示的关系复杂很多。不过，请先不用理会这里所说的复杂关系，让我们把焦点扩大一些，看看它们与内核调度实体（KSE）之间的关系是怎样的，如图2-2所示。\n\n\n![图2-1](\\images\\2-1.png)\n\n##### 图2-1\n\n![图2-2](\\images\\2-2.png)\n\n##### 图2-2\n\n可以看到，M与KSE之间总是一对一的关系，一个M能且仅能代表一个内核线程。Go的运行时系统（runtime system）用M代表一个内核调度实体。M与KSE之间的关联非常稳固，一个M在其生命周期内，会且仅会与一个KSE产生关联。相比之下，M与P、P与G之间的关联都是易变的，它们之间的关系会在实际调度的过程中改变。此外，M与G之间也会建立关联，因为一个G终归会由一个M来负责运行；它们之间的关联会由P来牵线。注意，由于M、P和G之间的关系在实际调度过程中多变，图2-2中的可能关联仅能作为一般性的示意。\n\n至此，你已经知道了这些核心实体之间可能存在的关系。Go的运行时系统会对这些实体的实例进行实时管理和调度。接下来，我会专门对此进行介绍。现在，让我们再次聚焦，看一看在这些实体内部都有哪些值得关注的细节。\n\n### M（内核线程）\n一个M代表了一个内核线程。在大多数情况下，创建一个新M的原因是没有足够的M来关联P并运行其中可运行的G。不过，在运行时系统执行系统监控或垃圾回收等任务的时候，也会导致新M的创建。M的部分结构如图2-3所示。\n\n![图2-3](\\images\\2-3.png)\n##### 图2-3　M的结构（部分）\n\nM结构中的字段众多，这里只挑选了几个最重要的字段。列表中，每一行都展示了一个字段，左边是字段名，右边是字段类型。其中，字段`g0`表示一个特殊的goroutine。这个goroutine是Go运行时系统在启动之初创建的，用于执行一些运行时任务。字段`mstartfn`表示M的起始函数，这个函数其实就是我们在编写go语句时携带的那个函数。字段`curg`会存放当前M正在运行的那个G的指针，而字段`p`的值则会指向与当前M相关联的那个P。`mstartfn`、`curg`和`p`最能体现当前M的即时情况。此外，字段`nextp`用于暂存与当前M有潜在关联的P。让调度器将某个P赋给某个M的操作由`nextp`字段控制，称为对M和P的预联。运行时系统有时候会把刚刚重新启用的M和已与它预联的那个P关联在一起，这也是nextp字段的主要作用。字段`spinning`是`bool`类型的，它用于表示这个M是否正在寻找可运行的G。在寻找过程中，M会处于自旋状态。这也是该字段名的由来。Go运行时系统可以把一个M和一个G锁定在一起。一旦锁定，这个M就只能运行这个G，这个G也只能由该M运行。标准库代码包runtime中的函数`LockOSThread`和`UnlockOSThread`，也为我们提供了锁定和解锁的具体方法。M的字段`lockedg`表示的就是与当前M锁定的那个G（如果有的话）。\n\nM在创建之初，会被加入全局的M列表（`runtime.allm`）中。这时，它的起始函数和预联的P也会被设置。最后，运行时系统会为这个M专门创建一个新的内核线程并与之相关联。如此一来，这个M就为执行G做好了准备。其中，起始函数仅当运行时系统要用此M执行系统监控或垃圾回收等任务的时候才会被设置。而这里的全局M列表其实并没有什么特殊的意义。运行时系统在需要的时候，会通过它获取到所有M的信息。同时，它也可以防止M被当作垃圾回收掉。\n\n在新M被创建之后，Go运行时系统会先对它进行一番初始化，其中包括对自身所持的栈空间以及信号处理方面的初始化。在这些初始化工作都完成之后，该M的起始函数会被执行（如果存在的话）。注意，如果这个起始函数代表的是系统监控任务的话，那么该M会一直执行它，而不会继续后面的流程。否则，在起始函数执行完毕之后，当前M将会与那个预联的P完成关联，并准备执行其他任务。M会依次在多处寻找可运行的G并运行它。这一过程也是调度的一部分。有了M，Go程序的并发运行基础才得以形成。\n\n运行时系统管辖的M（或者说`runtime.allm`中的M）有时候也会被停止，比如在运行时系统执行垃圾回收任务的过程中。运行时系统在停止M的时候，会把它放入调度器的空闲M列表（`runtime.sched.midle`）。这很重要，因为在需要一个未被使用的M时，运行时系统会先尝试从该列表中获取。M是否空闲，仅以它是否存在于调度器的空闲M列表中为依据。\n\n单个Go程序所使用的M的最大数量是可以设置的。Go程序运行的时候会先启动一个引导程序，这个引导程序会为其运行建立必要的环境。在初始化调度器的时候，它会对M的最大数量进行初始设置，这个初始值是10 000。也就是说，一个Go程序最多可以使用10 000个M。这就意味着，最多可以有10 000个内核线程服务于当前的Go程序。请注意，这里说的是最理想的情况；由于操作系统内核对进程的虚拟内存的布局控制以及大小限制，如此量级的线程可能很难共存。从这个角度看，Go本身对于线程数量的限制几乎可以忽略。\n\n除了上述初始设置之外，我们也可以在Go程序中对该限制进行设置。为了达到此目的，你需要调用标准库代码包runtime/debug中的`SetMaxThreads`函数，并提供新的M最大数量。`runtime/debug.SetMaxThreads`函数在执行完成后，会把旧的M最大数量作为结果值返回。非常重要的一点是，如果你在调用`runtime/debug.SetMaxThreads`函数时给定的新值比当时M的实际数量还要小，运行时系统就会立即引发一个运行时恐慌。所以，你要非常谨慎地使用这个函数。请记住，如果真的需要设置M的最大数量，那么越早调用`runtime/debug.SetMaxThreads`函数越好。对于它的设定值，你也要仔细斟酌。\n\n### P（执行一个Go代码片段所必需的资源）\nP是G能够在M中运行的关键。Go的运行时系统会适时地让P与不同的M建立或断开关联，以使P中的那些可运行的G能够及时获得运行时机，这与操作系统内核在CPU之上实时地切换不同的进程或线程的情形类似。\n\n改变单个Go程序间接拥有的P的最大数量有两种方法。第一种方法，调用函数`runtime.GOMAXPROCS`并把想要设定的数量作为参数传入。第二种方法，在Go程序运行前设置环境变量`GOMAXPROCS`的值。P的最大数量实际上是对程序中并发运行的G的规模的一种限制。P的数量即为可运行G的队列的数量。一个G在被启用后，会先被追加到某个P的可运行G队列中，以等待运行时机。一个P只有与一个M关联在一起时，才会使其可运行G队列中的G有机会运行。不过，设置P的最大数量只能限制住P的数量，而对G和M的数量没有任何约束。当M因系统调用而阻塞（更确切地说，是它运行的G进入了系统调用）的时候，运行时系统会把该M和与之关联的P分离开来。这时，如果这个P的可运行G队列中还有未被运行的G，那么运行时系统就会找到一个空闲M，或创建一个新的M，并与该P关联以满足这些G的运行需要。因此，M的数量在很多时候也都会比P多。而G的数量，一般取决于Go程序本身。\n\n在Go程序启动之初，引导程序会在初始化调度器时，对P的最大数量进行设置。这里的默认值会与当前CPU的总核心数相同。一旦发现环境变量`GOMAXPROCS`的值大于0，引导程序就会认为我们想要对P的最大数量进行设置。它会先检查一下此值的有效性：\n\n如果不大于预设的硬性上限值（256），就认为是有效的，否则就会被这个硬性上限值取代。也就是说，最终的P的最大数量值绝不会比硬性上限值大。硬性上限值是256的原因是，Go目前还不能保证在256多个P同时存在的情形下仍然保持高效。不过，这个硬性上限值并不是永久的，它可能会在未来改变。\n\n注意，虽然Go并未对何时调用`runtime.GOMAXPROCS`函数作限制，但是该函数调用的执行会暂时让所有的P都脱离运行状态，并试图阻止任何用户级别的G的运行。只有在新的P最大数量设定完成之后，运行时系统才开始陆续恢复它们。这对于程序的性能是非常大的损耗。所以，你最好只在Go程序的`main`函数的最前面调用`runtime.GOMAXPROCS`函数。当然，不在程序中改变P的最大数量最好不过，实际上在大多数情况下也无需改变。\n\n确定P的最大数量之后，运行时系统会根据这个数值重整全局的P列表（`runtime. allp`）。与全局M列表类似，该列表中包含了当前运行时系统创建的所有P。运行时系统会把这些P中的可运行G全部取出，并放入调度器的可运行G队列中。这是调整全局P列表的一个重要前提。被转移的那些G，会在以后经由调度再次放入某个P的可运行G队列。\n\n与空闲M列表类似，运行时系统中也存在一个调度器的空闲P列表（`runtime.sched.pidle`）。当一个P不再与任何M关联的时候，运行时系统就会把它放入该列表；而当运行时系统需要一个空闲的P关联某个M的话，会从此列表中取出一个。注意，P进入空闲P列表的一个前提条件是它的可运行G列表必须为空。例如，在重整全局P列表的时候，P在被清空可运行G队列之后，才会被放入空闲P列表。\n\n与M不同，P本身是有状态的，可能具有的状态如下。\n\n* Pidle 此状态表明当前P未与任何M存在关联。\n\n* Prunning 此状态表明当前P正在与某个M关联。\n\n* Psyscall 此状态表明当前P中的运行的那个G正在进行系统调用。\n\n* Pgcstop 此状态表明运行时系统需要停止调度。例如，运行时系统在开始垃圾回收的某些步骤前，就会试图把全局P列表中的所有P都置于此状态。\n\n* Pdead 此状态表明当前P已经不会再被使用。如果在Go程序运行的过程中，通过调用`runtime.GOMAXPROCS`函数减少了P的最大数量，那么多余的P就会被运行时系统置于此状态。\n\nP在创建之初的状态是`Pgcstop`，虽然这并不意味着运行时系统要在这时进行垃圾回收。不过，P处于这一初始状态的时间会非常短暂。在紧接着的初始化之后，运行时系统会将其状态设置为Pidle，并放入调度器的空闲P列表。图2-4描绘了P在各个状态之间进行流转的具体情况。\n\n![图2-4](\\images\\2-4.png)\n\n##### 图2-4　P的状态转换\n\n可以看到，非`Pdead`状态的P都会在运行时系统欲停止调度时被置于Pgcstop状态。不过，等到需要重启调度的时候（如垃圾回收结束后），它们并不会被恢复至原有状态，而会被统一地转换为`Pidle`状态。也就是说，它们会被放到同一起跑线上，并公平地接受再次调度。另一方面，非`Pgcstop`状态的P都可能因全局P列表的缩小而被认为是多余的，并被置于`Pdead`状态。不过，我们并不用担心其中的G会失去归宿。因为，在P被转换为`Pdead`状态之前，其可运行G队列中的G都会被转移到调度器的可运行G队列，而它的自由G列表中的G也都会被转移到调度器的自由G列表中。\n\n正如前面所述，每个P中除了一个可运行G队列外，还都包含一个自由G列表。这个列表中包含了一些已经运行完成的G。随着运行完成的G的增多，该列表可能会很长。如果它增长到一定程度，运行时系统就会把其中的部分G转移到调度器的自由G列表中。另一方面，当使用`go`语句启用一个G的时候，运行时系统会先试图从相应P的自由G列表中获取一个现成的G，来封装这个`go`语句携带的函数（也称`go`函数），仅当获取不到这样一个G的时候才有可能创建一个新的G。考虑到相应P的自由G列表为空而获取不到自由G的情况，运行时系统会在发现其中的自由G太少时，预先尝试从调度器的自由G列表中转移过来一些G。如此一来，只有在调度器的自由G列表也弹尽粮绝的时候，才会有新的G被创建。这在很大程度上提高了G的复用率。\n\n在P的结构中，可运行G队列和自由G列表是最重要的两个成员。至少对于Go语言的使用者来说是这样。它们间接地体现了运行时系统对G的调度情况。下面就对Go并发模型中的G进行介绍。\n\n### G（Go代码片段）\n一个G就代表一个`goroutine`（或称Go例程），也与go函数相对应。作为编程人员，我们只是使用go语句向Go的运行时系统提交了一个并发任务，而Go的运行时系统则会按照我们的要求并发地执行它。\n\nGo的编译器会把go语句变成对内部函数`newproc`的调用，并把go函数及其参数都作为参数传递给这个函数。这也是你应该了解的第一件与go语句有关的事。其实它并不神秘，只是一种递送并发任务的方法而已。\n\n运行时系统在接到这样一个调用之后，会先检查go函数及其参数的合法性，然后试图从本地P的自由G列表和调度器的自由G列表获取可用的G，如果没有获取到，就新建一个G。与M和P相同，运行时系统也持有一个G的全局列表（`runtime.allgs`）。新建的G会在第一时间被加入该列表。类似地，这个全局列表的主要作用是：集中存放当前运行时系统中的所有G的指针。无论用于封装当前这个go函数的G是否是新创建的，运行时系统都会对它进行一次初始化，包括关联go函数以及设置该G的状态和ID等步骤。在初始化完成后，这个G会立即被存储到本地P的`runnext`字段中；该字段用于存放新鲜出炉的G，以求更早地运行它。如果这时runnext字段已存有一个G，那么这个已有的G就会被“踢到”该P的可运行G队列的末尾。如果该队列已满，那么这个G就只能追加到调度器的可运行G队列中了。\n\n在特定情况下，一旦新启用的G被存于某地，调度就会立即进行以使该G尽早被运行。不过，即使这里不立即调度，我们也无需担心，因为运行时系统总是在为及时运行每个G忙碌着。\n\n每一个G都会由运行时系统根据其实际状况设置不同的状态，其主要状态如下。\n\n* Gidle 表示当前G刚被新分配，但还未初始化。\n\n* Grunnable 表示当前G正在可运行队列中等待运行。\n\n* Grunning 表示当前G正在运行。\n\n* Gsyscall 表示当前G正在执行某个系统调用。\n\n* Gwaiting 表示当前G正在阻塞。\n\n* Gdead 表示当前G正在闲置。\n\n* Gcopystack 表示当前G的栈正被移动，移动的原因可能是栈的扩展或收缩。\n\n除了上述状态，还有一个称为`Gscan`的状态。不过这个状态并不能独立存在，而是组合状态的一部分。比如，`Gscan`与`Grunnable`组合成`Gscanrunnable`状态，代表当前G正等待运行，同时它的栈正被扫描，扫描的原因一般是GC（垃圾回收）任务的执行。又比如，`Gscan`与`Grunning`组合成`Gscanrunning`状态，表示正处于`Grunning`状态的当前G的栈要被GC扫描时的一个短暂时刻。简单起见，我不会在下面对这些组合状态进行说明。你只要知道这些组合状态会在`GC`扫描发生时出现就可以了。\n\n之前讲过，在运行时系统想用一个G封装go函数的时候，会先对这个G进行初始化。一旦该G准备就绪，其状态就会被设置成`Grunnable`。也就是说，一个G真正开始被使用是在其状态设置为`Grunnable`之后。图2-5展示了G在其生命周期内的状态流转情况。\n\n![图2-5](\\images\\2-5.png)\n\n##### 图2-5　G 的状态转换\n\n一个G在运行的过程中，是否会等待某个事件以及会等待什么样的事件，完全由其封装的go函数决定。例如，如果这个函数中包含对通道值的操作，那么在执行到对应代码的时候，这个G就有可能进入`Gwaiting`状态。这可能是在等待从通道类型值中接收值，也可能是在等待向通道类型值发送值。又例如，涉及网络I/O的时候也会导致相应的G进入Gwaiting状态。此外，操纵定时器（`time.Timer`）和调用`time.Sleep`函数同样会造成相应G的等待。在事件到来之后，G会被“唤醒”并被转换至`Grunnable`状态。待时机到来时，它会被再次运行。\n\nG在退出系统调用时的状态转换要比上述情况复杂一些。运行时系统会先尝试直接运行这个G，仅当无法直接运行的时候，才会把它转换为`Grunnable`状态并放入调度器的自由G列表中。显然，对这样一个G来说，在其退出系统调用之时就立即被恢复运行再好不过了。运行时系统当然会为此做出一些努力，不过即使努力失败了，该G也还是会在实时的调度过程中被发现并运行。\n\n最后，值得一提的是，进入死亡状态（`Gdead`）的G是可以重新初始化并使用的。相比之下，P在进入死亡状态（`Pdead`）之后，就只能面临销毁的结局。由此也可以说明`Gdead`状态与`Pdead`状态所表达的含义截然不同。处于`Gdead`状态的G会被放入本地P或调度器的自由G列表，这是它们被重用的前提条件。\n\n\n> 本文转载于[郝林的文章](http://www.ituring.com.cn/book/tupubarticle/16048)\n","categories":["golang"]},{"title":"与运算","url":"/2018/03/19/与运算/","content":"发现了一个有意思的表达式：x&(x-1)，分享给大家！\n### 1、计算输入值转化为二进制后有多少个1\n```go\nfunc count_one(x int) int{\n    for count:=0;;count++{\n        if x==0{\n            return count\n        }else{\n            x=x&(x-1)\n        }\n    }\n}\n```\n### 2、判断输入的i是否是2的n次方\n```go\nfunc index(x int) int{\n    if x&(x-1)==0{\n        return 1\n    }else {\n        return 0\n    }\n}\n```","categories":["golang"]},{"title":"dependency_injection","url":"/2018/03/18/dependency-injection/","content":"# 依赖注入\n\n### 1. 依赖\n如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。\n\n```java\npublic class Human {\n    ...\n    Father father;\n    ...\n    public Human() {\n        father = new Father();\n    }\n}\n```\n仔细看这段代码我们会发现存在一些问题：  \n(1). 如果现在要改变 father 生成方式，如需要用`new Father(String name)`初始化 father，需要修改 Human 代码；  \n(2). 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；  \n(3). 如果`new Father()`过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。  \n\n### 2. 依赖注入\n上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：  \n\n```java\npublic class Human {\n    ...\n    Father father;\n    ...\n    public Human(Father father) {\n        this.father = father;\n    }\n}\n```\n\n上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。**像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。**  \n现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：  \n(1). 解耦，将依赖之间解耦。  \n(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。","categories":["golang"]}]